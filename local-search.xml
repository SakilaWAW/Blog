<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dijkstra</title>
    <link href="/blog/2024/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2024-03-05-Dijkstra/"/>
    <url>/blog/2024/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2024-03-05-Dijkstra/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在计算机科学领域，寻找图中两点之间的最短路径是一个经典且广泛研究的问题。这个问题的解决方案有着各种实际应用，从地图导航系统中规划最短行驶路线，到网络中数据包的最优传输路径。在所有解决这一问题的算法中，Dijkstra算法因其简洁性和高效性而特别著名。这个算法是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）在1956年提出的。Dijkstra算法能够找到有权图中某一节点到其他所有节点的最短路径。由于其广泛的应用前景，Dijkstra算法已成为计算机科学课程的基础内容，并且在实际中得到了广泛的应用。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>Dijkstra算法的核心思想是使用贪心策略逐步扩展最短路径树，从而找到从源点到图中所有其他节点的最短路径。算法维护三个主要的数据结构：一组已知最短路径的节点集合，一个距离数组，以及一个优先队列（或称为最小堆）用于选择下一个最短路径估计最小的节点。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><strong>初始化</strong>：将所有节点的距离值初始化为无穷大，除了源节点自身，其距离值设为0。所有节点都标记为未访问。</li><li><strong>选择最小距离节点</strong>：从未访问的节点中选择一个距离最小的节点，称之为当前节点。</li><li><strong>更新邻接节点的距离</strong>：对于当前节点的每一个邻接节点，检查是否可以通过当前节点到达它的路径比已知的路径更短。如果可以，更新该邻接节点的距离值。</li><li><strong>重复步骤</strong>：重复步骤2和3，直到所有的节点都被访问。</li><li><strong>完成</strong>：算法完成后，距离数组中存储的就是从源节点到图中所有其他节点的最短路径长度。</li></ol><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>Dijkstra算法的时间复杂度和空间复杂度主要取决于使用的数据结构。使用优先队列（特别是二叉堆）实现时，算法的时间复杂度为(O((V+E)\log V))，其中(V)是顶点数，(E)是边数。空间复杂度为(O(V))，因为需要存储每个顶点的距离值和访问状态。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minimumEffortPath = <span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) &#123;<br>  <span class="hljs-comment">// 放节点的queue，对应bfs总的队列</span><br>  <span class="hljs-comment">// 这里使用优先队列提高效率(贪心思想，之前路径短的更容易短)</span><br>  <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinPriorityQueue</span>()<br>  <span class="hljs-comment">// 放置原点</span><br>  q.<span class="hljs-title function_">enqueue</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">// 这个容器盛放最后的结果</span><br>  <span class="hljs-comment">// 可能是最短路径，或者别的，这里是相邻高度差</span><br>  <span class="hljs-comment">// 形态可能是数组或者多维数组，看情况使用</span><br>  <span class="hljs-keyword">let</span> minDelta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(heights.<span class="hljs-property">length</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(heights[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Infinity</span>))<br>  minDelta[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>  <span class="hljs-comment">// 求相邻节点的方法</span><br>  <span class="hljs-comment">// BFS中也需要类似的逻辑</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">adjacent</span> = (<span class="hljs-params">m, n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> [[m + <span class="hljs-number">1</span>, n],[m - <span class="hljs-number">1</span>, n], [m, n + <span class="hljs-number">1</span>], [m, n - <span class="hljs-number">1</span>]]<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">[mi, ni]</span>) =&gt;</span> mi &gt;= <span class="hljs-number">0</span> &amp;&amp; mi &lt; heights.<span class="hljs-property">length</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &lt; heights[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 两个节点之间的距离</span><br>  <span class="hljs-comment">// 节能是简单的计算，也可能计算比较长需要封装</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">getDistance</span> = (<span class="hljs-params">x1, y1, x2, y2</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(heights[x1][y1] - heights[x2][y2])<br>  &#125;<br><br>  <span class="hljs-comment">// 不断从queue弹出节点，这部分和BFS相同</span><br>  <span class="hljs-keyword">while</span> (!q.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>    <span class="hljs-comment">// 弹出的当前节点</span><br>    <span class="hljs-keyword">let</span> [x, y, cost] = q.<span class="hljs-title function_">front</span>().<span class="hljs-property">element</span><br>    q.<span class="hljs-title function_">dequeue</span>()<br><br>    <span class="hljs-comment">// Dijkstra新增的逻辑</span><br>    <span class="hljs-comment">// 由于可能出现重复节点在队列中</span><br>    <span class="hljs-comment">// 如果这个节点的距离已经大于之前的用例，直接跳过</span><br>    <span class="hljs-keyword">if</span> (cost &gt; minDelta[x][y]) &#123;<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果不需要求到所有节点的距离，可以在这里提前退出</span><br>    <span class="hljs-keyword">if</span> (x === heights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &amp;&amp; y === heights[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> cost<br>    &#125;<br><br>    <span class="hljs-comment">// 和BFS一样，遍历当前节点的相邻节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [nextX, nextY] <span class="hljs-keyword">of</span> <span class="hljs-title function_">adjacent</span>(x, y)) &#123;<br>      <span class="hljs-comment">// 新的结果值，计算方式按题意来</span><br>      <span class="hljs-keyword">let</span> nextDis = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">getDistance</span>(x, y, nextX, nextY), minDelta[x][y])<br><br>      <span class="hljs-comment">// 如果本次结果更短，更新结果，并把新节点加入队列</span><br>      <span class="hljs-keyword">if</span> (nextDis &lt; minDelta[nextX][nextY]) &#123;<br>        minDelta[nextX][nextY] = nextDis<br>        q.<span class="hljs-title function_">enqueue</span>([nextX, nextY, nextDis], nextDis)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果不中途退出，minDelta就是到各个节点的结果集合</span><br>  <span class="hljs-keyword">return</span> minDelta[heights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][heights[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Dijkstra算法广泛应用于各种领域，包括：</p><ul><li><strong>地图导航</strong>：计算从一个地点到另一个地点的最短或最快路径。</li><li><strong>网络路由</strong>：找到数据包在网络中从源地址到目的地址的最佳路径。</li><li><strong>社交网络</strong>：寻找两个用户之间的最短联系链。</li></ul><h3 id="算法优化和变体"><a href="#算法优化和变体" class="headerlink" title="算法优化和变体"></a>算法优化和变体</h3><p>虽然Dijkstra算法非常有效，但在处理特定类型的问题时，可以通过各种方式进行优化。例如，A*算法在寻找最短路径的同时使用启发式信息来减少搜索空间。另外，对于大规模图，可以使用斐波那契堆来进一步降低时间复杂度。</p><h3 id="实际案例分析"><a href="#实际案例分析" class="headerlink" title="实际案例分析"></a>实际案例分析</h3><p>考虑一个简单的网络路由问题，其中每个节点代表一个路由器，每条边的权重代表两个路由器之间的延迟。使用Dijkstra算法，可以计算出从任一路由器到网络中任何其他路由器的最短延迟路径。这对于优化数据包的传输非常有用，确保数据以最快的方式到达目的地。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dijkstra算法是解决图中最短路径问题的一种有效方法。它不仅在理论上有着坚实的基础，而且在实际应用中也非常有用。了解和掌握这一算法对于计算机科学学生和专业人士来说都是非常重要的。随着技术的发展，对该算法的研究和优化仍在继续，以适应更加复杂和多样化的应用场景。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript 进阶篇</title>
    <link href="/blog/2024/01/10/Typescript/2024-01-10-Typescript%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <url>/blog/2024/01/10/Typescript/2024-01-10-Typescript%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript-进阶篇"><a href="#Typescript-进阶篇" class="headerlink" title="Typescript 进阶篇"></a>Typescript 进阶篇</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h2><h3 id="1-1-泛型基础"><a href="#1-1-泛型基础" class="headerlink" title="1.1 泛型基础"></a>1.1 泛型基础</h3><p>泛型提供一种方式来使用类型变量，而不是具体的类型，这为类型的复用提供了灵活性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-keyword">let</span> output = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;myString&quot;</span>); <span class="hljs-comment">// 输出类型为 &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-泛型约束"><a href="#1-2-泛型约束" class="headerlink" title="1.2 泛型约束"></a>1.2 泛型约束</h3><p>泛型约束允许你定义一个接口来描述约束条件，确保泛型符合预期的形状。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>); <span class="hljs-comment">// 现在我们知道它有一个 .length 属性</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-泛型接口"><a href="#1-3-泛型接口" class="headerlink" title="1.3 泛型接口"></a>1.3 泛型接口</h3><p>泛型接口使接口的某些部分可以是任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericIdentityFn</span>&lt;T&gt; &#123;<br>  (<span class="hljs-attr">arg</span>: T): T;<br>&#125;<br><br><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">myIdentity</span>: <span class="hljs-title class_">GenericIdentityFn</span>&lt;<span class="hljs-built_in">number</span>&gt; = identity;<br></code></pre></td></tr></table></figure><h3 id="1-4-泛型类"><a href="#1-4-泛型类" class="headerlink" title="1.4 泛型类"></a>1.4 泛型类</h3><p>泛型类具有泛型类型的类成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">zeroValue</span>: T;<br>  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;<br>myGenericNumber.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-5-泛型工具类型"><a href="#1-5-泛型工具类型" class="headerlink" title="1.5 泛型工具类型"></a>1.5 泛型工具类型</h3><p>TypeScript 提供了内置的泛型工具类型，如 <code>Partial&lt;T&gt;</code> 使所有属性为可选，<code>Readonly&lt;T&gt;</code> 使所有属性为只读。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTodo</span>(<span class="hljs-params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo1</span>: <span class="hljs-title class_">Todo</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;organize desk&quot;</span>,<br>  <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;clear clutter&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> todo2 = <span class="hljs-title function_">updateTodo</span>(todo1, &#123;<br>  <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;throw out trash&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-高级类型"><a href="#2-高级类型" class="headerlink" title="2. 高级类型"></a>2. 高级类型</h2><h3 id="2-1-交叉类型和联合类型"><a href="#2-1-交叉类型和联合类型" class="headerlink" title="2.1 交叉类型和联合类型"></a>2.1 交叉类型和联合类型</h3><p>交叉类型是将多个类型合并为一个类型，联合类型则是一个值可以是几种类型之一。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Admin</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">privileges</span>: <span class="hljs-built_in">string</span>[];<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Employee</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">startDate</span>: <span class="hljs-title class_">Date</span>;<br>&#125;;<br><br><span class="hljs-comment">// 交叉类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ElevatedEmployee</span> = <span class="hljs-title class_">Admin</span> &amp; <span class="hljs-title class_">Employee</span>;<br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnknownEmployee</span> = <span class="hljs-title class_">Admin</span> | <span class="hljs-title class_">Employee</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printEmployeeInformation</span>(<span class="hljs-params">emp: UnknownEmployee</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Name: &quot;</span> + emp.<span class="hljs-property">name</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;privileges&quot;</span> <span class="hljs-keyword">in</span> emp) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Privileges: &quot;</span> + emp.<span class="hljs-property">privileges</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;startDate&quot;</span> <span class="hljs-keyword">in</span> emp) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start Date: &quot;</span> + emp.<span class="hljs-property">startDate</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-类型守卫和类型断言"><a href="#2-2-类型守卫和类型断言" class="headerlink" title="2.2 类型守卫和类型断言"></a>2.2 类型守卫和类型断言</h3><p>类型守卫允许你根据条件检查类型，类型断言则是你明确地告诉编译器变量的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 类型断言</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// 类型守卫</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumber</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): val is <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): val is <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;string&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-类型别名"><a href="#2-3-类型别名" class="headerlink" title="2.3 类型别名"></a>2.3 类型别名</h3><p>类型别名用于创建一个新的名字来引用一个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">coord: Point</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-字面量类型"><a href="#2-4-字面量类型" class="headerlink" title="2.4 字面量类型"></a>2.4 字面量类型</h3><p>字面量类型用于限制变量必须是指定的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Easing</span> = <span class="hljs-string">&quot;ease-in&quot;</span> | <span class="hljs-string">&quot;ease-out&quot;</span> | <span class="hljs-string">&quot;ease-in-out&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UIElement</span> &#123;<br>  <span class="hljs-title function_">animate</span>(<span class="hljs-params">dx: <span class="hljs-built_in">number</span>, dy: <span class="hljs-built_in">number</span>, easing: Easing</span>) &#123;<br>    <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">&quot;ease-in&quot;</span>) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">&quot;ease-out&quot;</span>) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">&quot;ease-in-out&quot;</span>) &#123;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// error! 不应该传入 null 或 undefined.</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-可辨识联合（Tagged-Unions）"><a href="#2-5-可辨识联合（Tagged-Unions）" class="headerlink" title="2.5 可辨识联合（Tagged Unions）"></a>2.5 可辨识联合（Tagged Unions）</h3><p>可辨识联合结合了字面量类型和联合类型，用于创建一个有固定数量成员的类型，每个成员都有一个共同的属性用于辨识。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Circle</span> &#123;<br>  <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;circle&quot;</span>;<br>  <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Square</span> &#123;<br>  <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;square&quot;</span>;<br>  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Shape</span> = <span class="hljs-title class_">Circle</span> | <span class="hljs-title class_">Square</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">shape: Shape</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (shape.<span class="hljs-property">kind</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;circle&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * shape.<span class="hljs-property">radius</span> ** <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;square&quot;</span>:<br>      <span class="hljs-keyword">return</span> shape.<span class="hljs-property">sideLength</span> ** <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-映射类型"><a href="#2-6-映射类型" class="headerlink" title="2.6 映射类型"></a>2.6 映射类型</h3><p>映射类型可以从旧类型创建新类型，可以迭代旧类型的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Keys</span> = <span class="hljs-string">&quot;option1&quot;</span> | <span class="hljs-string">&quot;option2&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flags</span> = &#123; [K <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: <span class="hljs-built_in">boolean</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-7-条件类型"><a href="#2-7-条件类型" class="headerlink" title="2.7 条件类型"></a>2.7 条件类型</h3><p>条件类型选择两种类型之一，基于给定的条件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Check</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-string">&quot;String&quot;</span> : <span class="hljs-string">&quot;Not a string&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span> = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// Type is &#x27;String&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NotString</span> = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// NotString is &#x27;Not a string&#x27;</span><br></code></pre></td></tr></table></figure><p>当然，我将继续并调整格式。</p><h2 id="3-模块和命名空间"><a href="#3-模块和命名空间" class="headerlink" title="3. 模块和命名空间"></a>3. 模块和命名空间</h2><h3 id="3-1-模块简介"><a href="#3-1-模块简介" class="headerlink" title="3.1 模块简介"></a>3.1 模块简介</h3><p>模块是 TypeScript 用于组织和封装代码的一种方式。模块可以包含变量、函数、类、接口等，通常是一个文件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// someModule.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-导出和导入模块"><a href="#3-2-导出和导入模块" class="headerlink" title="3.2 导出和导入模块"></a>3.2 导出和导入模块</h3><p>可以通过 <code>export</code> 关键字导出模块中的成员，并通过 <code>import</code> 关键字导入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// someModule.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;<br><br><span class="hljs-comment">// otherModule.ts</span><br><span class="hljs-keyword">import</span> &#123; someFunction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./someModule&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-默认导出"><a href="#3-3-默认导出" class="headerlink" title="3.3 默认导出"></a>3.3 默认导出</h3><p>每个模块可以有一个默认导出，使用 <code>export default</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// calculator.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// app.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./calculator&quot;</span>;<br><span class="hljs-keyword">const</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br></code></pre></td></tr></table></figure><h3 id="3-4-与其他-JavaScript-库和框架的互操作性"><a href="#3-4-与其他-JavaScript-库和框架的互操作性" class="headerlink" title="3.4 与其他 JavaScript 库和框架的互操作性"></a>3.4 与其他 JavaScript 库和框架的互操作性</h3><p>TypeScript 能够和现有的 JavaScript 库和框架无缝合作，通常通过类型声明文件（<code>.d.ts</code>）来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用第三方库 lodash</span><br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br>_.<span class="hljs-title function_">padStart</span>(<span class="hljs-string">&quot;Hello TypeScript&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot; &quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-5-命名空间和模块的区别"><a href="#3-5-命名空间和模块的区别" class="headerlink" title="3.5 命名空间和模块的区别"></a>3.5 命名空间和模块的区别</h3><p>命名空间主要用于组织代码和避免全局作用域的命名冲突，而模块则是文件级别的代码和依赖管理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用命名空间</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyNamespace</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们将探讨 TypeScript 中的装饰器。</p><h2 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4. 装饰器"></a>4. 装饰器</h2><p>装饰器是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上。装饰器使用 <code>@expression</code> 形式，其中 <code>expression</code> 必须求值为一个函数，它会在运行时被调用。</p><h3 id="4-1-类装饰器"><a href="#4-1-类装饰器" class="headerlink" title="4.1 类装饰器"></a>4.1 类装饰器</h3><p>类装饰器在类声明之前被声明，用于观察、修改或替换类定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sealed</span>(<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor);<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>&#125;<br><br><span class="hljs-meta">@sealed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;<br>  &#125;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-方法装饰器"><a href="#4-2-方法装饰器" class="headerlink" title="4.2 方法装饰器"></a>4.2 方法装饰器</h3><p>方法装饰器声明在一个方法的声明之前。用于观察、修改或替换方法定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enumerable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">    propertyKey: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    descriptor: PropertyDescriptor</span><br><span class="hljs-params">  </span>) &#123;<br>    descriptor.<span class="hljs-property">enumerable</span> = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;<br>  &#125;<br><br>  <span class="hljs-meta">@enumerable</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-访问器装饰器"><a href="#4-3-访问器装饰器" class="headerlink" title="4.3 访问器装饰器"></a>4.3 访问器装饰器</h3><p>访问器装饰器可以应用于属性的访问器（getter&#x2F;setter）之上，用于修改属性的行为。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">configurable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    target: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">    propertyKey: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    descriptor: PropertyDescriptor</span><br><span class="hljs-params">  </span>) &#123;<br>    descriptor.<span class="hljs-property">configurable</span> = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_y</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_y</span> = y;<br>  &#125;<br><br>  <span class="hljs-meta">@configurable</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">x</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@configurable</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">y</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_y</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-属性装饰器"><a href="#4-4-属性装饰器" class="headerlink" title="4.4 属性装饰器"></a>4.4 属性装饰器</h3><p>属性装饰器用于处理类的属性，可以用于记录或修改属性的行为。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> value = target[propertyKey];<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getter</span> = (<span class="hljs-params"></span>) =&gt; value;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setter</span> = (<span class="hljs-params">newValue: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    value = newValue.<span class="hljs-title function_">toUpperCase</span>();<br>  &#125;;<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, &#123;<br>    <span class="hljs-attr">get</span>: getter,<br>    <span class="hljs-attr">set</span>: setter,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-meta">@format</span><br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-参数装饰器"><a href="#4-5-参数装饰器" class="headerlink" title="4.5 参数装饰器"></a>4.5 参数装饰器</h3><p>参数装饰器声明在一个参数声明之前，用于监视、修改或替换方法的参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">required</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target: <span class="hljs-built_in">Object</span>,</span><br><span class="hljs-params">  propertyKey: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span><br><span class="hljs-params">  parameterIndex: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">existingRequiredParameters</span>: <span class="hljs-built_in">number</span>[] =<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnMetadata</span>(<span class="hljs-string">&quot;required&quot;</span>, target, propertyKey) || [];<br>  existingRequiredParameters.<span class="hljs-title function_">push</span>(parameterIndex);<br>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<br>    <span class="hljs-string">&quot;required&quot;</span>,<br>    existingRequiredParameters,<br>    target,<br>    propertyKey<br>  );<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-meta">@required</span> name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-混入（Mixins）"><a href="#5-混入（Mixins）" class="headerlink" title="5. 混入（Mixins）"></a>5. 混入（Mixins）</h2><p>混入是一种将一个类的方法和属性添加到另一个类的手段，在 TypeScript 中可以通过类和接口的组合来实现。</p><p>实现混入的一个示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Disposable</span> &#123;<br>  <span class="hljs-attr">isDisposed</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDisposed</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Activatable</span> &#123;<br>  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-title function_">activate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Disposable</span>, <span class="hljs-title class_">Activatable</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setInterval</span>(<br>      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDisposed</span>),<br>      <span class="hljs-number">500</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">interact</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">activate</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Disposable</span><br>  <span class="hljs-attr">isDisposed</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>  <span class="hljs-attr">dispose</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">// Activatable</span><br>  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>  <span class="hljs-attr">activate</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">deactivate</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-title function_">applyMixins</span>(<span class="hljs-title class_">SmartObject</span>, [<span class="hljs-title class_">Disposable</span>, <span class="hljs-title class_">Activatable</span>]);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMixins</span>(<span class="hljs-params">derivedCtor: <span class="hljs-built_in">any</span>, baseCtors: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>  baseCtors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">baseCtor</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(baseCtor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>      derivedCtor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[name] = baseCtor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[name];<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> smartObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartObject</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> smartObj.<span class="hljs-title function_">interact</span>(), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="6-声明合并"><a href="#6-声明合并" class="headerlink" title="6. 声明合并"></a>6. 声明合并</h2><p>TypeScript 允许声明合并，这意味着编译器会将两个同名的声明合并为单一声明。</p><h3 id="6-1-接口合并"><a href="#6-1-接口合并" class="headerlink" title="6.1 接口合并"></a>6.1 接口合并</h3><p>相同名称的接口声明会自动合并其成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> &#123;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> &#123;<br>  <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">Box</span> = &#123; <span class="hljs-attr">height</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">10</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="6-2-命名空间与类、函数、枚举的合并"><a href="#6-2-命名空间与类、函数、枚举的合并" class="headerlink" title="6.2 命名空间与类、函数、枚举的合并"></a>6.2 命名空间与类、函数、枚举的合并</h3><p>命名空间可以与类、函数或枚举合并。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Album</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-title class_">Album</span>.<span class="hljs-property">AlbumLabel</span>;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Album</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlbumLabel</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-使用-d-ts-声明文件"><a href="#7-使用-d-ts-声明文件" class="headerlink" title="7. 使用 d.ts 声明文件"></a>7. 使用 d.ts 声明文件</h2><p><code>.d.ts</code> 声明文件允许 TypeScript 理解非 TypeScript 编写的代码。</p><h3 id="7-1-为-JavaScript-库编写声明文件"><a href="#7-1-为-JavaScript-库编写声明文件" class="headerlink" title="7.1 为 JavaScript 库编写声明文件"></a>7.1 为 JavaScript 库编写声明文件</h3><p>编写声明文件可以让 TypeScript 理解现有的 JavaScript 代码库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// typings/lodash.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;lodash&quot;</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">padStart</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-built_in">string</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    length: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    chars?: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  </span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-DefinitelyTyped-和-types"><a href="#7-2-DefinitelyTyped-和-types" class="headerlink" title="7.2 DefinitelyTyped 和 @types"></a>7.2 DefinitelyTyped 和 @types</h3><p>DefinitelyTyped 提供了许多库的类型定义，可通过 npm 安装对应的 <code>@types</code> 包来使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @types/lodash<br></code></pre></td></tr></table></figure><h2 id="8-编译上下文"><a href="#8-编译上下文" class="headerlink" title="8. 编译上下文"></a>8. 编译上下文</h2><p><code>tsconfig.json</code> 文件定义了 TypeScript 项目的根目录和编译选项。</p><p>使用 <code>tsconfig.json</code> 示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="8-1-项目引用"><a href="#8-1-项目引用" class="headerlink" title="8.1 项目引用"></a>8.1 项目引用</h3><p>项目引用提供了一种方法来组织 TypeScript 项目。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// Base options</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;references&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./sub-project&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="9-与构建工具集成"><a href="#9-与构建工具集成" class="headerlink" title="9. 与构建工具集成"></a>9. 与构建工具集成</h2><p>TypeScript 可以与现代构建工具如 Webpack 集成。</p><p>与 Webpack 集成示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// webpack.config.js</span><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>  entry<span class="hljs-punctuation">:</span> &#x27;./src/app.ts&#x27;<span class="hljs-punctuation">,</span><br>  module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span> /\.tsx?$/<span class="hljs-punctuation">,</span><br>        use<span class="hljs-punctuation">:</span> &#x27;ts-loader&#x27;<span class="hljs-punctuation">,</span><br>        exclude<span class="hljs-punctuation">:</span> /node_modules/<br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  resolve<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    extensions<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;.tsx&#x27;<span class="hljs-punctuation">,</span> &#x27;.ts&#x27;<span class="hljs-punctuation">,</span> &#x27;.js&#x27;<span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    filename<span class="hljs-punctuation">:</span> &#x27;bundle.js&#x27;<span class="hljs-punctuation">,</span><br>    path<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span> &#x27;dist&#x27;)<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>;<br></code></pre></td></tr></table></figure><h2 id="10-调试和测试"><a href="#10-调试和测试" class="headerlink" title="10. 调试和测试"></a>10. 调试和测试</h2><p>TypeScript 支持多种调试和测试策略。</p><h3 id="10-1-TypeScript-的调试技巧"><a href="#10-1-TypeScript-的调试技巧" class="headerlink" title="10.1 TypeScript 的调试技巧"></a>10.1 TypeScript 的调试技巧</h3><p>使用源映射（Source Maps）可以帮助调试 TypeScript 代码。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tsconfig.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="10-2-使用-TypeScript-进行单元测试"><a href="#10-2-使用-TypeScript-进行单元测试" class="headerlink" title="10.2 使用 TypeScript 进行单元测试"></a>10.2 使用 TypeScript 进行单元测试</h3><p>TypeScript 与测试框架如 Jest 可以配合使用，提供类型安全的单元测试。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// example.test.ts</span><br><span class="hljs-keyword">import</span> &#123; sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./sum&quot;</span>;<br><span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;adds 1 + 2 to equal 3&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
      <tag>handbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript 入门篇</title>
    <link href="/blog/2024/01/09/Typescript/2024-01-09-Typescript%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/blog/2024/01/09/Typescript/2024-01-09-Typescript%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript-入门篇"><a href="#Typescript-入门篇" class="headerlink" title="Typescript 入门篇"></a>Typescript 入门篇</h1><h2 id="1-Typescript-简介"><a href="#1-Typescript-简介" class="headerlink" title="1. Typescript 简介"></a>1. Typescript 简介</h2><p>Typescript 是 JavaScript 的一个超集，添加了类型系统和对 ES6+ 的支持。</p><p>什么是 Typescript:</p><ul><li>Typescript 是一种由微软开发的开源语言，它扩展了 JavaScript，增加了类型检查。</li></ul><p>Typescript 与 JavaScript 的区别:</p><ul><li>Typescript 提供了类型检查，能够在编译时发现并纠正错误，而 JavaScript 是动态类型的，只能在运行时发现错误。</li></ul><h2 id="2-安装和配置"><a href="#2-安装和配置" class="headerlink" title="2. 安装和配置"></a>2. 安装和配置</h2><p>Typescript 的安装和配置是入门的第一步。</p><p>安装 Typescript:</p><ul><li>通过 npm 安装：<code>npm install -g typescript</code></li></ul><p>设置和理解 <code>tsconfig.json</code>:<br><code>tsconfig.json</code> 文件定义了 Typescript 项目的编译选项和根文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-基本类型"><a href="#3-基本类型" class="headerlink" title="3. 基本类型"></a>3. 基本类型</h2><p>Typescript 支持 JavaScript 中的大多数基本类型，并引入了一些新的类型。</p><p>字符串、数字、布尔值:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">isStudent</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>数组和元组:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>枚举:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-title class_">Red</span>,<br>  <span class="hljs-title class_">Green</span>,<br>  <span class="hljs-title class_">Blue</span>,<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br></code></pre></td></tr></table></figure><p>Any、Unknown 和 Never 类型:</p><ul><li><code>any</code> 类型可以是任何值，<code>unknown</code> 类型是 <code>any</code> 的安全对应类型，<code>never</code> 类型表示永远不会返回值。</li></ul><p>Void 和 Undefined:</p><ul><li><code>void</code> 表示没有任何类型，<code>undefined</code> 表示值未被定义。</li></ul><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><p>Typescript 中的函数可以为参数和返回值设置类型。</p><p>函数类型:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>可选参数和默认参数:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> lastName ? <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName&#125;</span> <span class="hljs-subst">$&#123;lastName&#125;</span>`</span> : firstName;<br>&#125;<br></code></pre></td></tr></table></figure><p>剩余参数:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, ...restOfName: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + restOfName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h2><p>接口是 Typescript 中定义对象类型的一种方式。</p><p>接口定义:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LabelledValue</span> &#123;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可选属性和只读属性:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数类型接口:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可索引的类型:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringArray</span> &#123;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类类型接口:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>  <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>  <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-类"><a href="#6-类" class="headerlink" title="6. 类"></a>6. 类</h2><p>Typescript 支持面向对象编程特性，如类、接口等。</p><p>类的基本使用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;<br>  &#125;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承和多态:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Animal moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>公共、私有与受保护的修饰符:</p><ul><li>Typescript 支持 <code>public</code>（默认）、<code>private</code> 和 <code>protected</code></li></ul><p>访问修饰符。</p><p>存取器:</p><ul><li>Typescript 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。</li></ul><p>静态属性和方法:</p><ul><li>静态属性和方法是属于类的，而不是类的实例。</li></ul><p>抽象类:</p><ul><li>抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。</li></ul><h2 id="7-类型断言"><a href="#7-类型断言" class="headerlink" title="7. 类型断言"></a>7. 类型断言</h2><p>类型断言提供了一种方式来告诉编译器关于变量的更多信息。</p><p>类型断言的用法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>类型守卫:</p><ul><li>Typescript 使用类型守卫来细化类型的范围。</li></ul><h2 id="8-类型推论"><a href="#8-类型推论" class="headerlink" title="8. 类型推论"></a>8. 类型推论</h2><p>Typescript 会在没有明确指出类型的地方自动推断出一个类型。</p><p>基本规则:</p><ul><li>如果没有明确的指定类型，TypeScript 会依照类型推论的规则推断出一个类型。</li></ul><p>最佳通用类型:</p><ul><li>当需要从几个表达式中推断出一个类型时，TypeScript 会尝试找出这些表达式共同的类型。</li></ul><p>上下文类型:</p><ul><li>Typescript 也会根据上下文进行类型推断，如在事件处理中。</li></ul><h2 id="9-联合类型和交叉类型"><a href="#9-联合类型和交叉类型" class="headerlink" title="9. 联合类型和交叉类型"></a>9. 联合类型和交叉类型</h2><p>联合类型和交叉类型提供了一种有效的方式来表示非统一的类型。</p><p>联合类型:</p><ul><li>联合类型是多个类型之一，表示一个值可以是几种类型之一。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>value = <span class="hljs-string">&quot;My String&quot;</span>; <span class="hljs-comment">// OK</span><br>value = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>交叉类型:</p><ul><li>交叉类型是将多个类型合并为一个类型。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BusinessPartner</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">credit</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identity</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Employee</span> = <span class="hljs-title class_">BusinessPartner</span> &amp; <span class="hljs-title class_">Identity</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: <span class="hljs-title class_">Employee</span> = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">credit</span>: <span class="hljs-number">1000</span> &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
      <tag>handbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript模块化浅析</title>
    <link href="/blog/2023/12/25/Javascript/2023-12-26-Javascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/blog/2023/12/25/Javascript/2023-12-26-Javascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-模块化浅析"><a href="#JavaScript-模块化浅析" class="headerlink" title="JavaScript 模块化浅析"></a>JavaScript 模块化浅析</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代 Web 开发中，模块化是一个核心概念，它允许开发者将大型的程序分解成独立、可重用、更易于管理的小部分。从早期的全局变量和命名空间，到 CommonJS、AMD、以及最新的 ESModule，JavaScript 的模块化标准已经经历了多次演变。本文旨在通过演变进程串联下这些模块化技术，理解它们的特点和适用场景，以及它们是如何影响现代前端和后端开发的。</p><h2 id="模块化的演变历程"><a href="#模块化的演变历程" class="headerlink" title="模块化的演变历程"></a>模块化的演变历程</h2><h3 id="早期-JavaScript"><a href="#早期-JavaScript" class="headerlink" title="早期 JavaScript"></a>早期 JavaScript</h3><p>在 JavaScript 早期，缺乏模块化标准。开发者通常依赖全局变量和函数来构建应用程序，这很容易导致命名冲突和代码维护困难。</p><h3 id="IIFE（立即执行函数表达式）"><a href="#IIFE（立即执行函数表达式）" class="headerlink" title="IIFE（立即执行函数表达式）"></a>IIFE（立即执行函数表达式）</h3><p>为了解决全局命名空间污染问题，开发者们开始使用立即执行函数表达式（IIFE）来创建私有作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> myModule = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateVar = <span class="hljs-string">&#x27;I am private&#x27;</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVar);<br>    &#125;<br>  &#125;;<br>&#125;)();<br>myModule.<span class="hljs-title function_">publicMethod</span>();<br></code></pre></td></tr></table></figure><h3 id="Script-标签"><a href="#Script-标签" class="headerlink" title="Script 标签"></a>Script 标签</h3><p>同时，通过在 HTML 中手动添加 <code>&lt;script&gt;</code> 标签来管理依赖和加载顺序，这种方法在管理大型应用的复杂依赖时显得力不从心。</p><h2 id="CommonJS：Node-js-中的模块化"><a href="#CommonJS：Node-js-中的模块化" class="headerlink" title="CommonJS：Node.js 中的模块化"></a>CommonJS：Node.js 中的模块化</h2><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>CommonJS 规范主要用于服务器端 JavaScript，如 Node.js。它通过 <code>require</code> 函数同步加载模块，这在服务器端是可行的，因为文件通常是本地可用的。</p><h3 id="模块导出和导入"><a href="#模块导出和导入" class="headerlink" title="模块导出和导入"></a>模块导出和导入</h3><p>模块通过 <code>module.exports</code> 导出，通过 <code>require</code> 函数导入。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 导出</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; myFunction &#125;;<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> &#123; myFunction &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>CommonJS 支持运行时动态加载模块，允许根据条件动态地 <code>require</code> 不同的模块。</p><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>在 CommonJS 中，循环引用可能导致模块部分加载或得到不完整的 <code>exports</code> 对象，因为模块在其代码完全执行前就被返回。</p><h2 id="AMD-和-RequireJS：浏览器中的模块化"><a href="#AMD-和-RequireJS：浏览器中的模块化" class="headerlink" title="AMD 和 RequireJS：浏览器中的模块化"></a>AMD 和 RequireJS：浏览器中的模块化</h2><h3 id="异步模块定义"><a href="#异步模块定义" class="headerlink" title="异步模块定义"></a>异步模块定义</h3><p>AMD（Asynchronous Module Definition）规范是为了解决浏览器端模块化的异步加载问题而产生的。RequireJS 是实现 AMD 规范的著名库。</p><h3 id="RequireJS-示例"><a href="#RequireJS-示例" class="headerlink" title="RequireJS 示例"></a>RequireJS 示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 定义模块</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dependency&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">dependency</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">methodName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;;<br>&#125;);<br><br><span class="hljs-comment">// 使用模块</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;myModule&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">myModule</span>) &#123;<br>  myModule.<span class="hljs-title function_">methodName</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="优势和限制"><a href="#优势和限制" class="headerlink" title="优势和限制"></a>优势和限制</h3><p>与 CommonJS 相比，AMD 专注于浏览器端的异步加载，允许在不阻塞浏览器渲染的情况下加载模块。然而，这也带来了额外的复杂性，特别是在模块依赖管理方面。</p><h2 id="ESModule：现代-JavaScript-的模块标准"><a href="#ESModule：现代-JavaScript-的模块标准" class="headerlink" title="ESModule：现代 JavaScript 的模块标准"></a>ESModule：现代 JavaScript 的模块标准</h2><h3 id="静态解析和实时绑定"><a href="#静态解析和实时绑定" class="headerlink" title="静态解析和实时绑定"></a>静态解析和实时绑定</h3><p>ESModule 引入了静态解析和实时绑定的概念。静态解析意味着模块之间的依赖关系在编译时就已经确定，而实时绑定则确保了导出值的动态更新。</p><h3 id="模块语法"><a href="#模块语法" class="headerlink" title="模块语法"></a>模块语法</h3><p>ESModule 使用 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> &#123; myFunction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="浏览器和服务器端支持"><a href="#浏览器和服务器端支持" class="headerlink" title="浏览器和服务器端支持"></a>浏览器和服务器端支持</h3><p>随着现代浏览器和 Node.js 的更新，ESModule 成为了跨平台的模块化解决方案。它在浏览器中原生支持，同时也被 Node.js 逐步采纳。</p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>ESModule 通过实时绑定和静态解析，提供了一种更一致的方式来处理循环引用问题，避免了 CommonJS 中可能出现的部分加载或不完整的模块导出。</p><h2 id="模块化的实际应用"><a href="#模块化的实际应用" class="headerlink" title="模块化的实际应用"></a>模块化的实际应用</h2><h3 id="项目结构与模块组织"><a href="#项目结构与模块组织" class="headerlink" title="项目结构与模块组织"></a>项目结构与模块组织</h3><ul><li><strong>模块划分</strong>：在模块化的项目中，重要的是如何将应用程序划分为独立的模块。每个模块应该有一个清晰定义的功能，负责一个特定的任务。</li><li><strong>目录结构</strong>：合理的目录结构是至关重要的。通常，相关功能的模块应该放在同一个目录下。例如，UI 组件、服务、工具函数等各有不同的目录。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">src/<br>|-- components/<br>|   |-- Button.js<br>|   |-- NavBar.js<br>|<br>|-- services/<br>|   |-- apiService.js<br>|<br>|-- utils/<br><span class="hljs-code">    |-- helpers.js</span><br></code></pre></td></tr></table></figure><h3 id="构建工具和流程"><a href="#构建工具和流程" class="headerlink" title="构建工具和流程"></a>构建工具和流程</h3><ul><li><strong>角色和选择</strong>：构建工具如 Webpack、Rollup 和 Parcel 在模块化项目中扮演着核心角色。它们负责打包模块、转换新的 JavaScript 语法、优化代码等。</li><li><strong>配置示例</strong>：以 Webpack 为例，它不仅打包模块，还可以配置 Loader 和插件来转换和优化代码。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;)<br>  ],<br>  <span class="hljs-comment">// 更多配置...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码拆分与懒加载"><a href="#代码拆分与懒加载" class="headerlink" title="代码拆分与懒加载"></a>代码拆分与懒加载</h3><ul><li><strong>拆分策略</strong>：为了提高应用性能，可以使用代码拆分技术。例如，Webpack 提供了动态导入功能，允许按需加载模块。</li><li><strong>懒加载实现</strong>：通过懒加载，应用可以在初次加载时只加载必要的核心模块，其余模块在需要时才加载。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 示例：动态导入</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;myChunkName&quot; */</span> <span class="hljs-string">&#x27;./path/to/myModule&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 使用 module</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="单元测试与模块"><a href="#单元测试与模块" class="headerlink" title="单元测试与模块"></a>单元测试与模块</h3><ul><li><strong>测试重要性</strong>：模块化代码更容易进行单元测试。每个模块可以被独立测试，确保其功能正确。</li><li><strong>测试工具</strong>：常用的测试框架如 Jest 或 Mocha 提供了强大的工具来测试模块化代码。</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><strong>模块粒度</strong>：保持模块粒度适中，既不过于庞大也不过于细碎。</li><li><strong>避免循环依赖</strong>：循环依赖可能导致难以追踪的问题，应当尽量避免。</li><li><strong>模块的可重用性</strong>：编写模块时考虑其可重用性，避免过度特定化。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>模块化是现代 JavaScript 开发的基石。从 IIFE 到 ESModule，JavaScript 的模块化已经走过了漫长的道路。随着技术的发展，ESModule 正在成为前端和后端开发的标准。了解和掌握不同的模块化技术，对于任何 JavaScript 开发者来说都是必不可少的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN Web Docs - Modules</a></li><li><a href="https://nodejs.org/api/modules.html">Node.js Documentation - Modules</a></li><li><a href="https://requirejs.org/">RequireJS Documentation</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>module</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript中的事件循环和多线程</title>
    <link href="/blog/2023/12/04/Javascript/2023-12-04-Javascript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/blog/2023/12/04/Javascript/2023-12-04-Javascript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="深入探索-Node-js-的事件循环和多线程机制"><a href="#深入探索-Node-js-的事件循环和多线程机制" class="headerlink" title="深入探索 Node.js 的事件循环和多线程机制"></a>深入探索 Node.js 的事件循环和多线程机制</h1><p>Node.js 是一种基于 Chrome V8 引擎的 JavaScript 环境，它通过事件循环和非阻塞 I&#x2F;O 操作，提供了一个高效的方式来处理高并发请求。本文旨在深入解析 Node.js 中的事件循环机制，并探讨其如何与多线程相结合来优化性能。</p><h2 id="Node-js-的事件循环"><a href="#Node-js-的事件循环" class="headerlink" title="Node.js 的事件循环"></a>Node.js 的事件循环</h2><p>事件循环是 Node.js 性能的核心，它使得 Node.js 能够在单线程上执行非阻塞操作，同时处理大量的并发请求。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Node.js 的事件循环分为几个主要阶段：</p><ol><li><strong>Timers 阶段</strong>：处理<code>setTimeout()</code>和<code>setInterval()</code>预定的回调。</li><li><strong>I&#x2F;O Callbacks 阶段</strong>：处理大部分 I&#x2F;O 相关的回调，例如文件系统操作、网络请求。</li><li><strong>Poll 阶段</strong>：轮询新的 I&#x2F;O 事件，执行与 I&#x2F;O 相关的回调。</li><li><strong>Check 阶段</strong>：执行<code>setImmediate()</code>的回调。</li><li><strong>Close Callbacks 阶段</strong>：处理如<code>socket.on(&#39;close&#39;, ...)</code>的回调。</li></ol><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><ul><li><strong>宏任务</strong>：包括各种 I&#x2F;O 操作、<code>setTimeout</code>、<code>setInterval</code>。Node.js 为每种类型的宏任务设置了不同的回调队列。</li><li><strong>微任务</strong>：包括<code>process.nextTick</code>和所有的<code>Promise</code>回调，这些任务在每个事件循环的阶段之后立即执行。</li></ul><p>理解宏任务和微任务的执行顺序和时机对于编写高效的 Node.js 应用程序至关重要。</p><h2 id="Node-js-中的多线程"><a href="#Node-js-中的多线程" class="headerlink" title="Node.js 中的多线程"></a>Node.js 中的多线程</h2><p>尽管 Node.js 在其核心是单线程的，它通过<code>worker_threads</code>模块提供了多线程的能力，以便在不阻塞主事件循环的情况下执行复杂的后台任务。</p><h3 id="使用-worker-threads"><a href="#使用-worker-threads" class="headerlink" title="使用 worker_threads"></a>使用 worker_threads</h3><ol><li><p><strong>引入模块</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;worker_threads&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>创建和使用 Worker</strong>：<br>主线程可以创建 Worker，并在 Worker 中执行独立的任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (isMainThread) &#123;<br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(\_\_filename);<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Worker 线程中的代码</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>主线程和 Worker 之间的通信</strong>：<br>使用<code>postMessage</code>和<code>onmessage</code>进行通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程中</span><br>worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;Hello, worker!&quot;</span>);<br><br><span class="hljs-comment">// Worker 线程中</span><br>parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用多线程时要注意内存和通信的开销。</li><li>适合于执行 CPU 密集型任务，不建议用于 I&#x2F;O 密集型任务。</li></ul><p>通过合理使用多线程，Node.js 可以有效地处理复杂的计算任务，而不会阻塞主线程。</p><h2 id="Node-js-的事件循环与浏览器的差异"><a href="#Node-js-的事件循环与浏览器的差异" class="headerlink" title="Node.js 的事件循环与浏览器的差异"></a>Node.js 的事件循环与浏览器的差异</h2><p>虽然 Node.js 和浏览器都使用事件循环，但它们的实现有所不同。Node.js 的事件循环更加专注于后台服务和 API，而浏览器的事件循环则与用户界面和用户交互更为密切相关。</p><ul><li><strong>浏览器环境</strong>：事件循环处理用户交互、脚本执行、UI 渲染等任务。</li><li><strong>Node.js 环境</strong>：事件循环主要处理 I&#x2F;O 操作，例如文件系统读写、网络请求等。</li></ul><p>理解这两者之间的差异对于跨平台开发和性能优化至关重要。</p><h2 id="事件循环的高级特性"><a href="#事件循环的高级特性" class="headerlink" title="事件循环的高级特性"></a>事件循环的高级特性</h2><p>Node.js 的事件循环拥有一些高级特性，使得它在处理并发和异步操作时更加高效。</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><ul><li><code>process.nextTick</code>允许我们在当前操作结束后，事件循环继续前插入一个回调。这在需要处理紧急事件或延迟操作到栈清空后非常有用。</li><li>这种机制比微任务（如 Promise）有更高的优先级。</li></ul><h3 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate vs setTimeout"></a>setImmediate vs setTimeout</h3><ul><li><code>setImmediate</code>和<code>setTimeout</code>虽然看似相似，但它们在事件循环中的执行时机不同。</li><li><code>setImmediate</code>旨在在当前轮询阶段完成后立即执行，而<code>setTimeout</code>则根据指定的时间延迟执行回调。</li></ul><p>理解这些细微差别有助于更好地安排异步操作和计时器。</p><h2 id="最佳实践和性能考量"><a href="#最佳实践和性能考量" class="headerlink" title="最佳实践和性能考量"></a>最佳实践和性能考量</h2><p>在使用 Node.js 的事件循环和多线程时，以下一些最佳实践可以帮助优化性能：</p><ol><li><strong>避免阻塞事件循环</strong>：尽量减少在主线程上执行长时间运行的操作。考虑使用 worker_threads 来处理 CPU 密集型任务。</li><li><strong>合理安排宏任务和微任务</strong>：理解两者的差异和适用场景，可以帮助你更有效地安排异步逻辑和时间敏感的任务。</li><li><strong>监控和优化性能</strong>：使用 Node.js 的内置工具，如<code>process.monitor</code>，或第三方库来监控应用的性能和资源使用情况。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Node.js 的事件循环和多线程机制是其强大性能和灵活性的基石。深入理解这些概念不仅有助于编写高效的 Node.js 应用程序，还能帮助开发者在遇到性能瓶颈时做出明智的优化决策。随着 Node.js 的不断发展，掌握这些核心概念将使你能够充分利用 Node.js 的强大功能，构建响应迅速、高效可靠的应用。</p><p>希望这篇文章能帮助你更深入地理解 Node.js 的内部工作原理，并有效地应用这些知识到你的开发实践中。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端问答Part1</title>
    <link href="/blog/2023/11/27/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/2023-11-27-%E5%89%8D%E7%AB%AF%E9%97%AE%E7%AD%94Part1/"/>
    <url>/blog/2023/11/27/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/2023-11-27-%E5%89%8D%E7%AB%AF%E9%97%AE%E7%AD%94Part1/</url>
    
    <content type="html"><![CDATA[<h1 id="前端工程师面试问题集"><a href="#前端工程师面试问题集" class="headerlink" title="前端工程师面试问题集"></a>前端工程师面试问题集</h1><h2 id="浏览器技术"><a href="#浏览器技术" class="headerlink" title="浏览器技术"></a>浏览器技术</h2><h3 id="浏览器的关键进程和线程"><a href="#浏览器的关键进程和线程" class="headerlink" title="浏览器的关键进程和线程"></a>浏览器的关键进程和线程</h3><p><strong>问题</strong>: 请讲讲浏览器有哪些关键的进程和线程。<br><strong>回答</strong>:<br>在现代浏览器中，尤其是像Google Chrome这样的浏览器，主要包含以下几种类型的进程和线程：</p><ol><li><p><strong>主进程</strong>：负责浏览器界面的显示和交互，处理用户输入、各种事件的派发、子进程的创建和销毁等。它还负责文件的下载和基本的UI展示。</p></li><li><p><strong>渲染进程</strong>：每个浏览器标签通常对应一个渲染进程，负责页面的渲染，包括HTML的解析、CSS样式的计算、JS脚本的执行等。在多标签的浏览器中，每个标签页一般都有自己的渲染进程。</p></li><li><p><strong>GPU进程</strong>：用于3D绘制等操作，随着现代网页越来越多地采用CSS动画和WebGL等技术，GPU进程变得越发重要。</p></li><li><p><strong>网络进程</strong>：处理页面的网络资源加载。</p></li><li><p><strong>插件进程</strong>：对于每个插件，浏览器为其创建一个独立的进程。</p></li></ol><p>这些进程相互独立，保证了浏览器的稳定性和安全性。当一个页面崩溃时，它不会影响到浏览器中的其他页面。</p><p>此外，还有一些关键的线程，如：</p><ul><li><strong>GUI渲染线程</strong>：负责渲染浏览器的UI界面。</li><li><strong>JavaScript引擎线程</strong>：用于解析和执行JavaScript代码。</li><li><strong>事件触发线程</strong>：用于控制事件循环，处理事件和执行回调函数。</li><li><strong>定时器触发线程</strong>：负责执行异步的setTimeout和setInterval。</li><li><strong>异步HTTP请求线程</strong>：用于执行异步请求的回调。</li></ul><p>这些线程和进程共同构成了浏览器的基础架构，确保了浏览器的快速、稳定和安全运行。</p><h2 id="Web-API-和-JavaScript"><a href="#Web-API-和-JavaScript" class="headerlink" title="Web API 和 JavaScript"></a>Web API 和 JavaScript</h2><h3 id="RequestAnimationFrame方法和RequestIdleCallback方法"><a href="#RequestAnimationFrame方法和RequestIdleCallback方法" class="headerlink" title="RequestAnimationFrame方法和RequestIdleCallback方法"></a>RequestAnimationFrame方法和RequestIdleCallback方法</h3><p><strong>问题</strong>: 了解RequestAnimationFrame方法和RequestIdleCallback方法吗，讲一讲他们是什么和用途。<br><strong>回答</strong>:<br><code>requestAnimationFrame</code>和<code>requestIdleCallback</code>是现代浏览器提供的两个重要的API，用于优化JavaScript动画和背景任务的性能。</p><ul><li><p><strong>requestAnimationFrame</strong>:</p><ul><li><code>requestAnimationFrame</code>主要用于优化动画的性能。传统的使用<code>setTimeout</code>或<code>setInterval</code>方法的动画可能会导致动画不流畅或过度绘制，而<code>requestAnimationFrame</code>提供了一种更高效的方式来请求浏览器在下次重绘前执行动画更新。</li><li>它与浏览器的刷新率同步，可以在浏览器绘制的每一帧中运行动画，从而确保动画的流畅性和高效性。</li></ul></li><li><p><strong>requestIdleCallback</strong>:</p><ul><li><code>requestIdleCallback</code>则用于在浏览器的空闲时段内调用函数，以便不影响关键事件和动画的响应能力。</li><li>它允许开发者在浏览器空闲时执行低优先级或不急迫的任务，如数据预取、分析和背景日志记录等。</li><li>这有助于改善页面的性能，尤其是在复杂或资源密集型应用中，可以在不影响用户体验的情况下完成必要的背景工作。</li></ul></li></ul><p>这两个API在现代Web开发中越来越重要，它们帮助开发者更有效地利用浏览器的能力来提高应用性能和用户体验。</p><h2 id="HTTP-和网络"><a href="#HTTP-和网络" class="headerlink" title="HTTP 和网络"></a>HTTP 和网络</h2><h3 id="常见的Http头字段及其用途"><a href="#常见的Http头字段及其用途" class="headerlink" title="常见的Http头字段及其用途"></a>常见的Http头字段及其用途</h3><p><strong>问题</strong>: 举几个常见的Http头字段，他们分别有什么用途。<br><strong>回答</strong>:<br>在HTTP通信中，头字段用于传递关于请求和响应的额外信息。常见的HTTP头字段包括：</p><ul><li><strong>Content-Type</strong>: 指示资源的MIME类型，如<code>text/html</code>、<code>application/json</code>等。</li><li><strong>Content-Length</strong>: 表示响应体的长度。</li><li><strong>User-Agent</strong>: 包含有关发起请求的客户端信息，如浏览器类型和版本。</li><li><strong>Cookie</strong>: 从服务器发送到客户端并存储在客户端的小数据片段，用于状态管理。</li><li><strong>Set-Cookie</strong>: 由服务器发送，告诉客户端设置一个Cookie。</li><li><strong>Accept</strong>: 表示客户端可以处理的内容类型。</li><li><strong>Authorization</strong>: 包含用于认证的凭据信息，通常用于验证请求。</li><li><strong>Cache-Control</strong>: 指示缓存行为的指令。</li><li><strong>Host</strong>: 指定请求的服务器的域名和端口号。</li><li><strong>Referer</strong>: 表示请求发起的源页面地址。</li><li><strong>Accept-Encoding</strong>: 表示客户端支持的内容编码，如gzip。</li><li><strong>Connection</strong>: 控制客户端和服务器之间的连接管理。</li></ul><p>这些头字段在HTTP请求和响应中起着至关重要的作用，它们影响着资源的加载方式、性能优化、安全策略、用户验证等方面。</p><h3 id="Cookie常用的字段"><a href="#Cookie常用的字段" class="headerlink" title="Cookie常用的字段"></a>Cookie常用的字段</h3><p><strong>问题</strong>: 你提到了cookie，我们知道cookie常用于身份验证，举几个cookie常用的字段的例子。<br><strong>回答</strong>:<br>Cookie是由服务器发送到用户浏览器并存储的小数据片段，用于状态管理和用户跟踪。常见的Cookie字段包括：</p><ul><li><strong>Name</strong>: Cookie的名称。</li><li><strong>Value</strong>: 与Cookie名称关联的值。</li><li><strong>Expires&#x2F;Max-Age</strong>: 定义Cookie的有效期。Expires设置一个过期日期，Max-Age设置Cookie存在的秒数。</li><li><strong>Domain</strong>: 指定哪些域可以接收Cookie。如果未指定，默认为发起请求的域。</li><li><strong>Path</strong>: 指定与Cookie关联的网页路径。</li><li><strong>Secure</strong>: 指示Cookie仅应通过安全协议发送，如HTTPS。</li><li><strong>HttpOnly</strong>: 指示Cookie不应该被JavaScript访问。</li><li><strong>SameSite</strong>: 用于防止CSRF攻击和用户跟踪，它可以有Strict、Lax和None三个值。</li></ul><p>这些字段控制着Cookie的发送、过期和安全性，对于Web应用中的身份验证、会话管理和个性化设置非常重要。</p><h2 id="服务器端渲染-SSR"><a href="#服务器端渲染-SSR" class="headerlink" title="服务器端渲染 (SSR)"></a>服务器端渲染 (SSR)</h2><h3 id="SSR和SEO"><a href="#SSR和SEO" class="headerlink" title="SSR和SEO"></a>SSR和SEO</h3><p><strong>问题</strong>: SSR和SEO相关了解吗，具体讲讲。<br><strong>回答</strong>:<br>服务器端渲染（SSR）是一种在服务器上生成完整HTML页面的技术，对搜索引擎优化（SEO）非常有益。在SSR中，页面的初始渲染发生在服务器上，生成的HTML然后被发送到客户端。这对SEO有几个主要的好处：</p><ol><li><p><strong>更快的加载时间</strong>: SSR可以提供更快的页面加载时间，因为浏览器可以更快地开始渲染页面，不需要等待所有JavaScript下载并执行。</p></li><li><p><strong>更好的搜索引擎抓取</strong>: 由于页面的HTML是预先生成的，搜索引擎抓取器（如Googlebot）可以更容易地抓取和索引内容。</p></li><li><p><strong>改进的可见性和索引</strong>: 对于不执行JavaScript的搜索引擎抓取器，SSR确保了页面内容的可见性，从而有助于更好地理解和索引页面内容。</p></li><li><p><strong>首屏内容快速呈现</strong>: SSR还有助于快速呈现首屏内容，这对于用户体验和搜索引擎排名都是至关重要的。</p></li></ol><p>尽管如此，SSR也带来了一些挑战，如服务器负载的增加、开发复杂性和可能的延迟渲染问题。但总的来说，SSR是提高Web应用SEO性能的有效手段。</p><h3 id="SSR的缺点"><a href="#SSR的缺点" class="headerlink" title="SSR的缺点"></a>SSR的缺点</h3><p><strong>问题</strong>: 简单讲讲SSR的缺点。<br><strong>回答</strong>:<br>尽管服务器端渲染（SSR）对于SEO和首屏加载时间有显著好处，但它也有一些缺点：</p><ol><li><p><strong>服务器负载</strong>: SSR增加了服务器的负载，因为每个页面请求都需要服务器动态生成HTML。这对于高流量网站来说可能成为一个问题。</p></li><li><p><strong>开发复杂性</strong>: SSR可能增加应用的开发和维护复杂性。开发者需要确保代码在服务器和客户端都能正常运行。</p></li><li><p><strong>时间到首字节（TTFB）延迟</strong>: 由于服务器需要处理更多的渲染工作，这可能导致时间到首字节（即从请求开始到接收到第一个响应字节的时间）的延迟。</p></li><li><p><strong>缓存策略限制</strong>: 使用SSR时，缓存策略可能更难实现，因为每个请求可能需要动态渲染内容。</p></li><li><p><strong>水合（Hydration）问题</strong>: 在SSR中，客户端JavaScript需要“水合”服务器渲染的HTML。如果处理不当，这可能导致客户端和服务器渲染内容不同步的问题。</p></li></ol><p>因此，选择SSR还是客户端渲染（CSR）应根据应用的特定需求和资源来决定。</p><h3 id="SSR和异步请求数据"><a href="#SSR和异步请求数据" class="headerlink" title="SSR和异步请求数据"></a>SSR和异步请求数据</h3><p><strong>问题</strong>: SSR每次都返回整个网页，那是不是浏览器就不用进行异步请求数据并部分更新网页了？<br><strong>回答</strong>:<br>在服务器端渲染（SSR）中，虽然初始页面是由服务器完整生成的，但这并不意味着客户端不需要进行异步请求数据或更新页面部分内容。在以下情况中，客户端依然需要进行异步请求：</p><ol><li><p><strong>动态内容更新</strong>: 对于动态网站，页面上的某些内容可能需要根据用户交互或其他事件动态更新。这些情况下，客户端JavaScript仍然需要发起异步请求来获取最新数据，并更新DOM。</p></li><li><p><strong>客户端路由</strong>: 在单页应用（SPA）中，即使使用了SSR，客户端路由（如使用React Router或Vue Router）依然需要在用户浏览不同页面时请求新数据。</p></li><li><p><strong>用户特定数据</strong>: 对于需要根据不同用户展示不同内容的网站，客户端可能需要请求特定于用户的数据，如个人资料信息、购物车内容等。</p></li><li><p><strong>数据预取和懒加载</strong>: 为了优化性能和用户体验，客户端可能会采用数据预取或懒加载策略，这也需要异步请求。</p></li></ol><p>因此，即使在SSR中，异步请求仍然是现代Web应用的重要组成部分。</p><h2 id="前端框架和库"><a href="#前端框架和库" class="headerlink" title="前端框架和库"></a>前端框架和库</h2><h3 id="Vue如何实现SSR"><a href="#Vue如何实现SSR" class="headerlink" title="Vue如何实现SSR"></a>Vue如何实现SSR</h3><p><strong>问题</strong>: 简单讲讲vue如何实现SSR。<br><strong>回答</strong>:<br>Vue.js实现服务器端渲染（SSR）的核心是使用<code>vue-server-renderer</code>包。基本流程大致如下：</p><ol><li><p><strong>服务器设置</strong>: 首先，需要设置一个可以处理服务器端渲染的Node.js服务器。这通常涉及到创建一个Express或Koa的服务器。</p></li><li><p><strong>创建Vue实例</strong>: 在服务器上，创建一个新的Vue实例，这与在客户端创建Vue应用类似，但是它会针对服务器环境进行优化。</p></li><li><p><strong>路由处理</strong>: 使用<code>vue-router</code>在服务器上处理路由。当一个请求到达时，服务器需要解析URL并渲染相应的Vue组件。</p></li><li><p><strong>组件渲染</strong>: 使用<code>vue-server-renderer</code>将Vue实例渲染为HTML。这个过程涉及到将Vue组件和其子组件渲染成服务器端的HTML字符串。</p></li><li><p><strong>数据预取和状态管理</strong>: 对于需要异步获取数据的组件，服务器渲染过程需要等待这些数据获取完成，才能进行渲染。这通常通过在组件的生命周期钩子中获取数据并利用Vuex进行状态管理来实现。</p></li><li><p><strong>客户端激活</strong>: 服务器发送生成的HTML到客户端后，客户端的Vue应用会“激活”这些静态标记。这个过程称为“水合”（Hydration），Vue会将静态内容转化为动态的应用，使其能够响应用户交互。</p></li><li><p><strong>HTML发送至客户端</strong>: 最后，服务器将渲染好的HTML发送给客户端。这个HTML是应用的初始状态，客户端的Vue应用会在此基础上进行交互。</p></li></ol><p>SSR在Vue.js中可以提升首次加载性能，改善SEO，但也增加了开发和服务器处理的复杂性。</p><h3 id="Vue和React的区别"><a href="#Vue和React的区别" class="headerlink" title="Vue和React的区别"></a>Vue和React的区别</h3><p><strong>问题</strong>: 讲一讲vue和React的区别。<br><strong>回答</strong>:<br>Vue和React是两个流行的前端JavaScript框架，它们各有特点和优势：</p><ol><li><p><strong>设计哲学</strong>:</p><ul><li>Vue更倾向于提供一个更全面的解决方案，它在核心库以外提供了诸如路由器（vue-router）、状态管理（Vuex）等官方库。</li><li>React更专注于UI层，它提供了更多的灵活性，允许开发者选择其他库来处理路由、状态管理等功能。</li></ul></li><li><p><strong>模板语法 vs JSX</strong>:</p><ul><li>Vue使用基于HTML的模板语法，这使得编写和理解组件变得非常直观。</li><li>React使用JSX，这是一种JavaScript的语法扩展，允许在JavaScript代码中写入类似HTML的标记。</li></ul></li><li><p><strong>响应式系统</strong>:</p><ul><li>Vue的响应式系统更简单直观，它使用基于getter&#x2F;setter的系统自动追踪依赖。</li><li>React则使用基于状态（state）和属性（props）的概念，通过setState方法来更新UI。</li></ul></li><li><p><strong>生态系统和社区</strong>:</p><ul><li>React由Facebook支持，拥有更大的社区和生态系统。有大量的第三方库和工具可用。</li><li>Vue虽然社区规模较小，但它拥有一个非常活跃和友好的社区，以及一套完整的官方支持库。</li></ul></li><li><p><strong>学习曲线</strong>:</p><ul><li>Vue通常被认为更容易上手，特别是对于那些熟悉HTML和JavaScript的开发者。</li><li>React的学习曲线可能略高一些，特别是对于初学者来说，理解JSX和组件生命周期可能需要一些时间。</li></ul></li></ol><p>总的来说，Vue和React都是优秀的选择，但它们在设计理念、开发模式和生态系统支持上存在差异。选择哪个框架更多地取决于个人或团队的偏好、项目需求以及期望的开发体验。</p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="前端工程化的理解"><a href="#前端工程化的理解" class="headerlink" title="前端工程化的理解"></a>前端工程化的理解</h3><p><strong>问题</strong>: 如何理解前端的工程化？<br><strong>回答</strong>:<br>前端工程化是指将软件工程的方法和实践应用于前端开发，旨在提高代码质量、提升开发效率、促进团队协作和确保项目可持续性。主要包括以下方面：</p><ol><li><p><strong>代码规范化</strong>: 实现代码风格的统一，使用如ESLint、Prettier等工具来自动化代码格式化和质量检查。</p></li><li><p><strong>模块化和组件化</strong>: 将大型代码库分解为可重用的模块和组件，提高代码的可维护性和复用性。</p></li><li><p><strong>自动化构建和部署</strong>: 使用Webpack、Gulp等工具自动化完成构建流程，结合CI&#x2F;CD实现自动化测试和部署。</p></li><li><p><strong>依赖管理</strong>: 使用npm、yarn等包管理工具管理项目依赖。</p></li><li><p><strong>性能优化</strong>: 通过各种策略和实践，如代码分割、懒加载、资源压缩等，提升应用的加载速度和运行效率。</p></li><li><p><strong>测试</strong>: 实施单元测试、集成测试、端到端测试等，确保代码质量。</p></li><li><p><strong>版本控制</strong>: 使用Git等版本控制系统管理代码变更和协作。</p></li><li><p><strong>文档和知识共享</strong>: 编写文档和建立知识共享机制，以促进团队成员之间的信息共享和协作。</p></li><li><p><strong>团队协作和流程优化</strong>: 通过代码审查、敏捷开发方法等提高团队协作效率。</p></li></ol><p>前端工程化不仅关注技术层面的提升，还关注团队协作和项目管理，使得前端开发更加系统化和规范化。</p><h3 id="ESLint中自定义规则的创建"><a href="#ESLint中自定义规则的创建" class="headerlink" title="ESLint中自定义规则的创建"></a>ESLint中自定义规则的创建</h3><p><strong>问题</strong>: 你知道eslint中如何自定义规则吗，举个例子。<br><strong>回答</strong>:<br>在ESLint中自定义规则意味着创建一套自己的代码风格或质量检查规则。这通常涉及以下步骤：</p><ol><li><p><strong>创建规则文件</strong>: 首先创建一个JavaScript文件来定义规则。</p></li><li><p><strong>定义规则逻辑</strong>: 在文件中定义一个对象，该对象包含<code>create</code>方法，该方法返回一个规则对象。这个对象定义了对特定AST节点的处理逻辑。</p></li><li><p><strong>使用AST节点</strong>: 根据需要检查的代码特征，选择相应的AST节点类型。例如，可以选择<code>VariableDeclaration</code>节点来检查变量声明。</p></li><li><p><strong>编写检查逻辑</strong>: 在规则对象中，针对选定的AST节点编写具体的检查逻辑。</p></li></ol><p>例如，创建一个规则来确保所有的变量声明都使用<code>const</code>而非<code>let</code>或<code>var</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">create</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-title class_">VariableDeclaration</span>(node) &#123;<br>                <span class="hljs-keyword">if</span> (node.<span class="hljs-property">kind</span> !== <span class="hljs-string">&#x27;const&#x27;</span>) &#123;<br>                    context.<span class="hljs-title function_">report</span>(&#123;<br>                        node,<br>                        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Use const instead of let or var for variable declarations.&#x27;</span><br>                    &#125;);<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>配置ESLint: 将自定义规则添加到ESLint配置中。<br>通过这种方式，可以根据团队的编码标准和最佳实践自定义ESLint规则。</p><p>ESLint规则钩子的使用<br>问题: 你提到了eslint的create钩子，除了这个还有其他的钩子吗？<br>回答:<br>在ESLint中创建规则时，除了create方法外，还可以使用其他钩子来指定不同的行为。这些钩子对应于JavaScript源代码的AST（抽象语法树）中的不同节点类型。当ESLint解析代码时，会触发与这些节点匹配的钩子函数。以下是一些常用的钩子：</p><ul><li><strong>FunctionDeclaration</strong>: 当遇到函数声明时触发。</li><li><strong>CallExpression</strong>: 当遇到函数或方法调用表达式时触发。</li><li><strong>Literal</strong>: 当遇到字面量（如字符串、数字）时触发。</li><li><strong>IfStatement</strong>: 当遇到if语句时触发。</li><li><strong>VariableDeclaration</strong>: 当遇到变量声明时触发。</li><li><strong>ArrowFunctionExpression</strong>: 当遇到箭头函数表达式时触发。</li><li><strong>MemberExpression</strong>: 当遇到对象成员表达式（如<code>obj.property</code>）时触发。</li><li><strong>AssignmentExpression</strong>: 当遇到赋值表达式时触发。</li><li><strong>ImportDeclaration</strong>: 当遇到ES6模块导入时触发。</li></ul><p>使用这些钩子，可以针对特定的代码模式或结构编写定制的检查逻辑，从而创建出适应特定代码风格和要求的ESLint规则。</p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="前端性能指标"><a href="#前端性能指标" class="headerlink" title="前端性能指标"></a>前端性能指标</h3><p><strong>问题</strong>: 举几个最关键的前端性能指标，系统性的讲讲如何针对他们进行优化。<br><strong>回答</strong>:<br>关键的前端性能指标主要包括：</p><ol><li><p><strong>首次内容绘制（First Contentful Paint, FCP）</strong>: 表示从页面加载开始到页面内容的第一部分被渲染的时间。优化FCP的方法包括减少关键渲染路径的资源、最小化主线程工作、延迟加载非关键资源。</p></li><li><p><strong>首次有意义绘制（First Meaningful Paint, FMP）</strong>: 表示主要内容开始出现在屏幕上的时间。优化策略包括优先加载关键内容、使用服务端渲染。</p></li><li><p><strong>可交互时间（Time to Interactive, TTI）</strong>: 页面变得完全可交互的时间。可以通过代码分割、减少JavaScript执行时间、优化页面元素加载优先级来提高TTI。</p></li><li><p><strong>总阻塞时间（Total Blocking Time, TBT）</strong>: FCP和TTI之间主线程被阻塞的总时长。减少长任务、拆分大型JavaScript文件可以减少TBT。</p></li><li><p><strong>最大内容绘制（Largest Contentful Paint, LCP）</strong>: 页面中最大文本块或图像元素完全加载的时间。优化图像、使用更快的服务端响应、客户端渲染优化可以提高LCP。</p></li><li><p><strong>累积布局偏移（Cumulative Layout Shift, CLS）</strong>: 页面加载过程中视觉布局变化的总和。优化策略包括为图像和视频指定尺寸、动态内容加载时避免突然布局变化。</p></li></ol><p>对这些性能指标的优化有助于提升用户体验、提高应用的可访问性和搜索引擎排名。</p><h3 id="白屏时间对应的指标"><a href="#白屏时间对应的指标" class="headerlink" title="白屏时间对应的指标"></a>白屏时间对应的指标</h3><p><strong>问题</strong>: 白屏时间对应的哪个指标？<br><strong>回答</strong>: 白屏时间通常对应于“首次内容绘制”（First Contentful Paint, FCP）这个性能指标。FCP指的是从页面开始加载到页面上的第一个内容元素（如文本、图片）被绘制的时间。在这个时间点之前，用户通常会看到一个空白屏幕，这就是所谓的“白屏”。</p><h2 id="Webpack配置和优化"><a href="#Webpack配置和优化" class="headerlink" title="Webpack配置和优化"></a>Webpack配置和优化</h2><h3 id="配置资源Preload和Prefetch"><a href="#配置资源Preload和Prefetch" class="headerlink" title="配置资源Preload和Prefetch"></a>配置资源Preload和Prefetch</h3><p><strong>问题</strong>: 在webpack5的项目中，如何配置资源preload和prefetch？<br><strong>回答</strong>:<br>在Webpack 5中，你可以使用<code>HtmlWebpackPlugin</code>来配置资源的预加载（preload）和预获取（prefetch）。这可以通过以下步骤实现：</p><ol><li><p><strong>使用<code>HtmlWebpackPlugin</code></strong>:</p><ul><li>该插件用于生成HTML文件，并可以通过配置来包含特定的资源。</li><li>安装<code>html-webpack-plugin</code>并在webpack配置中添加它。</li></ul></li><li><p><strong>配置Preload</strong>:</p><ul><li>使用<code>preload-webpack-plugin</code>或在<code>HtmlWebpackPlugin</code>配置中手动指定<code>preload</code>属性来预加载关键资源。</li><li>这对于需要尽快加载的资源（如CSS、关键脚本和字体文件）非常有用。</li></ul></li><li><p><strong>配置Prefetch</strong>:</p><ul><li>通过在<code>import()</code>语句中添加<code>webpackPrefetch: true</code>注释来实现资源的预获取。</li><li>这适用于将来可能需要但优先级较低的资源，例如在用户执行特定操作时才需要的脚本。</li></ul></li></ol><p>这种配置方法可以优化资源加载时间和应用性能，特别是对于提高首次内容绘制（FCP）和首次有意义绘制（FMP）非常有效。</p><h3 id="Preload、Defer和Async的区别"><a href="#Preload、Defer和Async的区别" class="headerlink" title="Preload、Defer和Async的区别"></a>Preload、Defer和Async的区别</h3><p><strong>问题</strong>: preload和script标签的defer、async有什么区别？<br><strong>回答</strong>:<br><code>preload</code>、<code>defer</code>和<code>async</code>是HTML中用于控制资源加载行为的不同属性，主要区别如下：</p><ul><li><p><strong>Preload</strong>:</p><ul><li>用于告诉浏览器页面必须立即获取的资源。</li><li>通过<code>&lt;link rel=&quot;preload&quot; href=&quot;...&quot;&gt;</code>标签实现。</li><li>对于关键资源，如关键CSS和JavaScript文件，非常有用。</li></ul></li><li><p><strong>Defer</strong>:</p><ul><li>用于延迟执行脚本，直到HTML文档被完全解析和显示后。</li><li>通过在<code>&lt;script&gt;</code>标签中设置<code>defer</code>属性实现。</li><li>保证脚本按照它们在文档中出现的顺序执行，对于依赖DOM的脚本非常有用。</li></ul></li><li><p><strong>Async</strong>:</p><ul><li>允许脚本异步加载。</li><li>通过在<code>&lt;script&gt;</code>标签中设置<code>async</code>属性实现。</li><li>当脚本可用时立即执行，适用于不依赖DOM或其他脚本的独立模块。</li></ul></li></ul><p>这些属性允许开发者更精细地控制资源的加载和执行，从而优化页面加载性能和用户体验。</p><h3 id="配置Async或Defer"><a href="#配置Async或Defer" class="headerlink" title="配置Async或Defer"></a>配置Async或Defer</h3><p><strong>问题</strong>: 在webpack5组织的项目中，如何配置以使用async或defer呢？<br><strong>回答</strong>:<br>在Webpack 5项目中，可以通过以下方式配置使用<code>async</code>或<code>defer</code>:</p><ul><li><p><strong>配置Defer</strong>:</p><ul><li>使用<code>html-webpack-plugin</code>，可以在其配置中指定<code>scriptLoading: &#39;defer&#39;</code>，这会为所有通过Webpack插入的脚本标签添加<code>defer</code>属性。</li><li>这适用于那些需要在文档解析完成后执行，但在DOMContentLoaded事件之前执行的脚本。</li></ul></li><li><p><strong>配置Async</strong>:</p><ul><li>对于<code>async</code>属性，没有直接的Webpack插件配置。</li><li>可以手动编辑生成的HTML文件或使用自定义的HTML模板来添加<code>async</code>属性。</li><li>适用于那些与DOM的解析顺序无关，并且可以独立于页面其余部分加载和执行的脚本。</li></ul></li></ul><p>通过这些方法，可以更好地控制脚本的加载和执行顺序，优化页面加载时间和用户体验。</p><h3 id="将所有Chunk加上Defer的必要性"><a href="#将所有Chunk加上Defer的必要性" class="headerlink" title="将所有Chunk加上Defer的必要性"></a>将所有Chunk加上Defer的必要性</h3><p><strong>问题</strong>: 有必要将生成的所有chunk都加上defer吗？<br><strong>回答</strong>:<br>是否将所有生成的chunk都加上<code>defer</code>属性取决于应用的特定需求。<code>defer</code>属性的使用适合于那些不会改变DOM结构的脚本，以及那些直到页面完全加载后才需要执行的脚本。以下是考虑是否为所有chunk添加<code>defer</code>属性的几个关键点：</p><ol><li><p><strong>非阻塞加载</strong>:</p><ul><li>使用<code>defer</code>可以使脚本在HTML解析过程中以非阻塞的方式加载，这有助于改善页面的加载性能。</li><li>当脚本不依赖于其他脚本，并且不需要在DOM构建的早期运行时，使用<code>defer</code>是合适的。</li></ul></li><li><p><strong>执行顺序</strong>:</p><ul><li><code>defer</code>脚本保证按照它们在HTML中出现的顺序执行。</li><li>如果应用中的脚本有依赖关系或特定的执行顺序要求，<code>defer</code>可以保证这种顺序。</li></ul></li><li><p><strong>脚本依赖</strong>:</p><ul><li>对于依赖DOM或其他脚本的脚本，可能需要在DOM构建的过程中立即执行，这种情况下使用<code>defer</code>可能不合适。</li></ul></li><li><p><strong>首次交互时间</strong>:</p><ul><li>对于影响用户首次交互的脚本，使用<code>defer</code>可以延迟其执行，从而不会阻碍页面的初始渲染。</li></ul></li></ol><p>综上所述，将所有chunk加上<code>defer</code>可以提升页面加载性能，尤其是对于大型应用或含有多个脚本的页面。然而，这需要根据具体的应用架构和脚本依赖关系来决定是否适用。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gpt4</tag>
      
      <tag>面试问答</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅尝rxjs</title>
    <link href="/blog/2023/04/19/Web/2023-04-19-%E6%B5%85%E5%B0%9Drxjs/"/>
    <url>/blog/2023/04/19/Web/2023-04-19-%E6%B5%85%E5%B0%9Drxjs/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早在一年前，我就被同事安利了ReactiveX的思想，当时没有特意去看。最近正好在做系统架构优化，遂从rxjs进行探索，当前版本为v7.8，今日将我的理解记录在此，顺便给我的博客清个灰(笑)。<br>文中所有例子都没有写import，如果想练手可以去<a href="https://stackblitz.com/edit/rxjs?file=index.ts">这里</a></p></blockquote><h1 id="浅尝rxjs"><a href="#浅尝rxjs" class="headerlink" title="浅尝rxjs"></a>浅尝rxjs</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>**Think of RxJS as Lodash for events.**我认为这句话最能贴合rxjs，翻译过来就是可以把Rxjs理解为Event界的Lodash。</p><ul><li><a href="https://lodash.com/">Lodash</a>是个工具库，里面提供了超多的工具方法，多是面对一些静态数据的，比如字符串、队列、对象、集合等。</li><li>这里的Event可以理解为各种异步操作，常见的有DOM的各种事件，通过后台接口获取数据，可以封装为Promise的各种操作等。</li></ul><p>可以看出来Rxjs是个比较单纯的库，目的很简单，就是让我们更好的掌控项目中的各种Event。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>要想理解rxjs如何使用，必须理解它提出的几个概念:</p><h3 id="Observable-在时间段内定义数据如何抛出"><a href="#Observable-在时间段内定义数据如何抛出" class="headerlink" title="Observable - 在时间段内定义数据如何抛出"></a>Observable - 在时间段内定义数据如何抛出</h3><p>Observable，顾名思义，可观测的，不过这个地方用作名词，可以理解为可观测的东西。这个概念听起来有点抽象，我认为关键就一句话:在时间段内定义数据如何抛出。举个几个例子</p><ul><li>每通过api接口向服务器请求一组数据，就去触发请求的动作，在得到数据后把数据<strong>抛出</strong>。</li><li>每点击网页上的一个按钮，就触发点击的动作，网页在进行一系列处理完后将点击事件<strong>抛出</strong>。</li><li>我想要执行一个Promise，我就会去触发Promise函数，在一段时间后Promise的结果会被<strong>抛出</strong>。</li></ul><p>在以上几个例子中: 请求api-&gt;获得后抛出数据、点击按钮-&gt;处理后抛出事件、Promise-&gt;完成后抛出数据，这些过程都可以理解为一个Observable。这些都是触发了一定事件后抛出一组数据的例子，那假如说我要每隔一秒抛出一个递增的数字，这个东西是否可以称作Observable呢？答案是肯定的。</p><p>用官网的代码来巩固下概念:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observable</span>(<span class="hljs-function">(<span class="hljs-params">subscriber</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 这里面就定义了数据随着时间如何抛出</span><br>  <span class="hljs-comment">// 首先依次抛出1、2、3</span><br>  subscriber.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>)<br>  subscriber.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>)<br>  subscriber.<span class="hljs-title function_">next</span>(<span class="hljs-number">3</span>)<br>  <span class="hljs-comment">// 1s之后抛出4后结束整个过程</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    subscriber.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>)<br>    subscriber.<span class="hljs-title function_">complete</span>()<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>其实在这个例子里我感觉subscriber这个变量可以命名为observer。</p></blockquote><h3 id="Observer-如何处理被抛出的数据"><a href="#Observer-如何处理被抛出的数据" class="headerlink" title="Observer - 如何处理被抛出的数据"></a>Observer - 如何处理被抛出的数据</h3><p>Observer意为观测者，在Observable的概念中我提到了<strong>数据的抛出</strong>，那么抛出来之后总得有东西来接，这个东西就是Observer，我认为Observer要做的就是:如何处理被抛出的数据。在rxjs中呢，就定义了三种常见的可能发生的情况:成功&#x2F;出错&#x2F;结束，还是看官网的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = &#123;<br>  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Observer got a next value: &#x27;</span> + x),<br>  <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Observer got an error: &#x27;</span> + err),<br>  <span class="hljs-attr">complete</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Observer got a complete notification&#x27;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了吧，observer其实就是个简单的对象，定义了三个方法来处理数据: next的意思就是直接处理抛出的数据，error一般在报错的时候被触发，complete在Observable结束的时候被调用。</p><p>其实理解以上两个概念就能理解最简单的rxjs程序了，我们把这两个东西组合起来，还是用官网的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observable = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">const</span> subscription = observable.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x))<br><span class="hljs-comment">// Later:</span><br><span class="hljs-comment">// This cancels the ongoing Observable execution which</span><br><span class="hljs-comment">// was started by calling subscribe with an Observer.</span><br>subscription.<span class="hljs-title function_">unsubscribe</span>()<br></code></pre></td></tr></table></figure><p>是不是突然觉得多了很多不知道的东西，不要慌。这里的interval是一个rxjs提供的工具函数，返回一个Observable，每秒抛出1个数字，从0开始递增。</p><p>然后有人可能问了，为什么没看到之前说的Observer啊？我的next、error和complete呢？不要急，其实*x &#x3D;&gt; console.log(x)*这个函数其实就是observer的简写。我们可以看到observable对象有个函数叫subscribe，这个其实就是另一个概念了，我们下一小节讲，这个函数里面传的就是一个observer，只不过这种传参方式算是一种简写，因为在Observer中next方法使用的最多，所以在只传一个函数的时候视为和下方代码等价:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> subscription = observable.<span class="hljs-title function_">subscribe</span>(&#123; <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) &#125;)<br></code></pre></td></tr></table></figure><h3 id="Subscription-Observable和Observer的桥梁"><a href="#Subscription-Observable和Observer的桥梁" class="headerlink" title="Subscription - Observable和Observer的桥梁"></a>Subscription - Observable和Observer的桥梁</h3><p>这个词的意思是订阅，简单的理解就是沟通Observable和Observer的桥梁。还记得上一小节中留下的问题嘛，这个subscribe函数就是订阅这个动作，他的返回值就是一个Subscription，订阅这个概念的存在是方便我们取消订阅，只需要执行*subscription.unsubscribe()*就可以断开Observable和Observer的连接，很好理解吧。</p><p>这部分就不放代码了，可以看上一小节的代码。</p><h3 id="Operators-流对流的映射方式"><a href="#Operators-流对流的映射方式" class="headerlink" title="Operators - 流对流的映射方式"></a>Operators - 流对流的映射方式</h3><p>Operators意为操作符，我认为这个东西的存在大大增强了Rxjs的功能性，让我们一起好好来品鉴下。在Observable中，我们提到了Observable定义了在一定时间段内定义数据如何抛出，我们如果将Observable抛出的动作转换为图会是什么样呢？举个例子:</p><p>interval(1000)可以转换为下图:</p><p>–1–2–3–4–&gt;</p><p>其中横轴是时间，数字是抛出的值，每次抛出间隔1s。</p><p>Operater的作用就是改变这个图，比如将上图转化下，把每次抛出变为两倍:</p><p>–2–4–6–8–&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observable = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">const</span> subscription = observable.<span class="hljs-title function_">pipe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>).<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x))<br></code></pre></td></tr></table></figure><p>代码如上，x &#x3D;&gt; x * 2就是一个简单的Operator</p><p>rxjs提供了大量的现成方法用来组成Operator，如下就是一个map方法的简单使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> clicks = <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">&#x27;click&#x27;</span>) <span class="hljs-comment">// 将页面点击事件化为一个Observable</span><br><span class="hljs-keyword">const</span> positions = clicks.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.<span class="hljs-property">clientX</span>)) <span class="hljs-comment">// 通过Operator将抛出的数据改为点击位置的横坐标</span><br><br>positions.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)) <span class="hljs-comment">// 订阅，observer每次收到数据就打印</span><br></code></pre></td></tr></table></figure><p>完整的Operator太过繁多，这里推荐一个可视化查看所有Operator的<a href="https://rxmarbles.com/">好网站</a>，这个网站用弹珠图的方式解释了大量Operator，什么？你说你不知道什么叫弹珠图？点进去看看就知道啦~</p><h3 id="Subject-统一上下文，实现多播"><a href="#Subject-统一上下文，实现多播" class="headerlink" title="Subject - 统一上下文，实现多播"></a>Subject - 统一上下文，实现多播</h3><p>知道以上的四个概念，我们对Rxjs的使用又进一步，下面我们来看Subject这个概念。不知大家有没有发现，上面所有的代码都是一对一的订阅，在我们日常的开发中其实很常见一些一个Observable抛出的数据要在多个地方处理的情况。所以Subject就被提出来了，Subject可以作为一个数据派发中转站，实现多播，我当初看到这里的时候很困惑，如果需要多个地方处理，那么我订阅两次不就行了？究竟行不行呢，我们考虑如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">const</span> sub1 = stream.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一个处理&#x27;</span>, num))<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  stream.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;另一个处理&#x27;</span>, num))<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">/* 输出如下</span><br><span class="hljs-comment">  一个处理 0</span><br><span class="hljs-comment">  一个处理 1</span><br><span class="hljs-comment">  另一个处理 0</span><br><span class="hljs-comment">  一个处理 2</span><br><span class="hljs-comment">  另一个处理 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>根据输出结果发现这个Observable实际两次是独立的上下文，并没有说在<strong>第一个处理</strong>中打印1后，下一次在<strong>另一个处理</strong>中直接打印1或者2。这就有局限性了，如果我就想<strong>另一个处理</strong>第一次就打印1呢，这就要用到Subject了，所以Subject的关键用途是<strong>统一上下文，实现多播</strong></p><p>下面来介绍Subject的两大特点:</p><ul><li>Subject是一种Observable</li><li>Subject是一种Observer</li></ul><p>没错，Subject既可以接受Observable抛出的数据，又可以作为Observable抛出数据。Subject，很神奇吧。直观地来讲，他可以让数据流分叉，同时发给多个Observer，就像下图这样:</p><p><img src="/blog/images/rxjs-junior/subject-muticast.png" alt="subject多播示意图"></p><p>Subject还有几种分类，对应不同场景，我打算连同Subject内部原理和分类单写一篇文章，敬请期待。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文着重讲解了rxjs几个基本概念的概念和用法，对于浅尝来讲是足够了，接下来我准备深入理解下Schedule和测试用例的编写方式，在这一切理解之后我会在工作的工程中探索应用场景，敬请期待接下来的文章🍻</p><hr><p>TODO:</p><ul><li>Subject分类原理</li><li>Rxjs的测试用例编写</li><li>理解Schedule调度器</li><li>Rxjs在工作环境中的应用探索</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rxjs</tag>
      
      <tag>轻量框架</tag>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关科学上网的基本原理</title>
    <link href="/blog/2020/11/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB/2020-11-03-%E6%9C%89%E5%85%B3%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/blog/2020/11/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB/2020-11-03-%E6%9C%89%E5%85%B3%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近研究了下有关梯子的原理和构建方法，感到很复杂，很有趣。这篇文章旨在记录我在研究中的一些重要的点(谁叫我记性不好呢)。</p></blockquote><p>一、原理</p><p>主要由于一些政治因素吧，GFW出现了，出现的原因不是我们关心的重点，本节主要说说GFW的基本原理。通俗的来讲就是在网络出口处设置了一个审查装置，来定向的封锁某些符合特征的数据包，在我们大众的视角里体现为一些网站上不去了。我们以时间顺序简单说明下原理的演进:</p><ol><li>最初的时候</li></ol><p><img src="/blog/images/scientific-internet-access/gfw-theory-1.png" alt="gfw原理"></p><p>没有gfw的时候，我们的PC和外网服务器还没有隔阂。和多年前一样，请求经由路由器、骨干网、DNS服务器转发到目标服务器。</p><ol start="2"><li>GFW的出现</li></ol><p>有一天，GFW出现了，那么它都做了些什么呢？</p><ul><li><p>GFW可以在我们进行DNS服务器解析的时候进行<code>域名污染</code>：当GFW发现我们访问的域名为需要拦截的，就返回一个假的结果。</p></li><li><p>GFW查看请求的内容，如果发现需要拦截的关键字，就对其进行阻断，此为<code>关键字阻断</code></p></li><li><p><code>端口阻断</code>：GFW可以对一些常用的端口进行阻断，比如443，22等</p></li><li><p>经过长时间的积累，GFW将可以的IP地址记录下来，如果发现，直接阻断，这就是<code>IP地址阻断</code></p></li></ul><p>当然随着时间的积累，技术也在迭代更新，阻断的方式也会越来越多。</p><p>我们不必强求了解所有的阻断方式，即使强求也得不到所有的，除非你认识GFW的架构师而且他愿意告诉你(ﾟ▽ﾟ)&#x2F;</p><ol start="3"><li>原始的梯子</li></ol><p>就像黑暗和光明是结伴而生，GFW的出现也一定会伴随着破解程序的出现，也就是我们所说的梯子。最早的梯子使用的原理叫做VPN(Virtual Private Network)：</p><p><img src="/blog/images/scientific-internet-access/gfw-theory-2.png" alt="VPN原理"></p><p>通过上图代理的方式确实可以完美规避GFW的监测，但是好景不长，GFW发现短期内出现大量通过VPN上外网的行为，所以出了应对措施：封闭VPN请求需要的端口，如果使用，必须报备，并且记录可疑代理的IP地址实行IP封锁。措施一经推出，基本VPN这种方式就行不通了。</p><ol start="4"><li>救世主ShadowSocks协议<br></li></ol><p>VPN倒下后，难道就没有方法穿过GFW了吗？不，救世主ShadowSocks(以下简称SS)适时的出现了，SS的出现打破了僵局。</p><p><img src="/blog/images/scientific-internet-access/gfw-theory-3.png" alt="SS原理"></p><p>既然建立加密通道请求会被作为特征被识别，我们在通过GFW之前提前加密不就好了。SS这种方式让GFW很难辨别(当然现在这种方式肯定还是可能被嗅探到的，毕竟GFW原理谁也说不清)。</p><ol start="5"><li>新生代V2Ray和Trojan等</li></ol><p>无敌的SS顶住压力后，有一些新生代协议也随之诞生，其中比较有名的要数V2Ray和Trojan，不过一句话来说这些协议都是在SS的基础上构建，各有优劣。V2Ray相比SS多了几次加密，安全性稍好一些，但相对的性能稍差、Trojan在V2Ray的基础上针对TLS+Websocket这个方式进行了优化，但是代价是只能用这个协议，不那么通用。这些协议包括很多没说的协议的原理对于我来说不重要，所以也不多说了。</p><p>二、自建SS还是机场</p><p>其实这些原理说起来也简单，有些人可能会觉得自己做一个会很容易。其实不然，自建SS真正的难点在于GFW对我们来说是一个黑盒，我们对其原理不甚清楚，而且网络数据的流动需要经过多个节点。当我们发现我们自建的SS使用不了时，如何快速定位问题才是难点，即使刚建起来的时候心情非常澎湃，像是干了件多大的丰功伟业，但是当这个SS被封很多次之后，在重建的过程中我们的热情也会被消磨殆尽。</p><p>所以综合来说如果做SS只是为了玩儿，那自建SS的确挺好玩儿的，但是如果我们只是想看看油管，刷刷twitter、ins，那么选择一个好的机场才是正道。</p><p>三、总结</p><p>整体来讲科学上网从原理上还是比较简单的，了解这些底层知识可以有效提高我们对网络基础，特别是网络代理这块的理解。对于我这种一般用户来说，使用机场就足够了，但真要落实到一个性价比高的机场，还得进行不断的尝试，如果有机会，在使用过一些机场后我会新开一篇文章来写一写使用体验。</p>]]></content>
    
    
    <categories>
      
      <category>程序员的基本素养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科学上网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地静态文件调试远程接口的设计</title>
    <link href="/blog/2020/09/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2020-09-15-%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2020/09/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2020-09-15-%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于涉及公司项目，本篇文章只介绍设计没有代码，如果按照这个思路实现的话，代码不会超过100行，请各位看官自行实现-. -</p></blockquote><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>最近在开发的过程中发现一个痛点，花费了一些时间来解决。以本文记录一下思考和解决问题的过程。</p><h4 id="二、痛点与思考"><a href="#二、痛点与思考" class="headerlink" title="二、痛点与思考"></a>二、痛点与思考</h4><p>规模大一些的公司，由于部门众多，员工编码安全意识薄弱，可能会出现内部系统信息泄露，操作权限混乱等安全问题。现在普遍的做法是安全团队提供多种检测手段、各业务自行配置ACL等、部分业务禁止对公网访问等来规避风险。</p><p>但这样可能衍生一个问题: 本地dev服务器可能会有一些接口无法访问，以至于不能在本地完全模拟线上环境。举个例子，如果本地获取用户身份信息接口不通的话，有些权限配置的开发就不好调试。这对我们的开发是及其不友好的。</p><p>所以<strong>如果能做一个工具让我们在调试的时候可以直接调用线上所有接口，但是静态文件又都是本地的，那当真是极好的。</strong></p><h4 id="三、设计"><a href="#三、设计" class="headerlink" title="三、设计"></a>三、设计</h4><p>如何做到这一点呢？很简单，我们做一个代理服务器做数据分发就可以了，地址如果为静态资源就分发到本地dev server，如果是api接口就调用远程接口，这样的话api权限什么的都不用处理，因为网站的host就是线上的。请看图:</p><p><img src="/blog/images/local-static-remote-api-proxy/system-design.png" alt="系统结构图"></p><p>整体来说就是加两个代理服务器，一个代理做隧道，另一个https代理进行请求的分发。<br>下面分步解读下:</p><p>① 本机浏览器通过switchyOmega这个chrome插件将所有需要代理的域名请求映射到http代理服务器上</p><p>② http代理服务器接到请求后通过隧道代理技术将所有请求流入到https代理服务器中，隧道代理的原理请看<a href="https://imququ.com/post/web-proxy.html">这篇文章</a></p><p>③ https代理服务器接到请求后解析url和host，将接口请求分发到线上环境，将其他请求分发到本地Dev server中，这个https服务器使用的方式就是<a href="https://imququ.com/post/web-proxy.html">前面那篇文章</a>中的普通代理模式</p><p>④ https代理服务器将请求的返回内容返回到http代理</p><p>⑤ http代理只是个隧道，会将内容传回浏览器，完</p><p>了解了基本原理之后使用任何后台语言都可以开发，我是使用的nodejs，全部代码80多行，相信你如果看懂了过程也可以自己开发出来。</p><p>开发完成后使用的过程为:<br>开启switchyOmega(第一次用得配置)-&gt;开启我们的两个代理服务器-&gt;访问线上网址<br>也可以关闭switchyOmega直接切换到本机的开发环境</p><p>由于vue是通过长连接来实现热刷新的，所以通过这种代理的方法也可以达到本地更改后自动刷新网页看效果，很方便。</p><h4 id="四、注意的点"><a href="#四、注意的点" class="headerlink" title="四、注意的点"></a>四、注意的点</h4><p>整个过程需要注意的是由于https代理使用https协议，所以需要配置相应的证书，并且需要让本机信任对应的CA证书。有关https协议的基础知识看<a href="https://zhuanlan.zhihu.com/p/57142784">这篇文章</a>，关于如何用openssl签发证书与本篇文章关联不大，会单写篇文章说明。</p><p>另外使用了这种方法后由于接口是线上数据，可不要轻易的做增删改的操作。</p><h4 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h4><p>主要思路已经写得比较清晰了，其实这个工具在公司里还是非常常用的，当初做调研的时候发现网上的文章良莠不齐，比较杂乱，经过几天的思考和学习把这个东西设计并实现出来。希望这篇文章能给大家讲明白。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
      <tag>nodejs</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/blog/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-04-10-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/blog/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-04-10-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>在面试的角度来说，一般字符串操作、数组链表和树&#x2F;图的遍历这些方面的题目会居多，所以本篇文章旨在总结常见的(简单的)有关图的算法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图的遍历与树的遍历不同，我们面临着两大难点：一是有的点可能到达不了，二是有可能会出现闭合回路，所以我们需要在每个位置设置一个标记位，路过的时候标记，下次再经过这里的时候直接结束搜索，从新的未标记顶点重新开始搜索。</p><p>对于图遍历来说，我们通常有两种方法：DFS(深度优先遍历)和 BFS(广度优先遍历)，下面逐一总结。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>先来看下代码模板(伪代码，重在理解意思)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">queue.<span class="hljs-title function_">push</span>(originPos);<br><span class="hljs-keyword">while</span> (!queue.<span class="hljs-title function_">empty</span>()) &#123;<br>  cur = queue.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-keyword">for</span> (pos <span class="hljs-keyword">of</span> <span class="hljs-title function_">possibleNextPos</span>(cur)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(pos) &amp;&amp; <span class="hljs-title function_">notVisited</span>(pos)) queue.<span class="hljs-title function_">push</span>(pos); <span class="hljs-comment">// 这里要注意不要重复添加</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总体而言就是利用队列的先进先出形成广度优先遍历，在<a href="http://leetcode-cn.com/submissions/detail/61540628">这里</a>可以看具体例子。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先遍历，一条路走到黑，如果走不通了，返回上一步走另外的路。看伪代码模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">dfs</span> = (<span class="hljs-params">x, y</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(x, y)) <span class="hljs-title function_">addToList</span>();<br>  <span class="hljs-comment">// 这里判断这个位置是否符合条件</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">for</span> (path <span class="hljs-keyword">of</span> <span class="hljs-title function_">getValidPath</span>(x, y)) &#123;<br>    <span class="hljs-comment">// 可能的下个路径</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValidPath</span>(path)) <span class="hljs-title function_">dfs</span>(path); <span class="hljs-comment">// 这里的判断条件可以进行剪枝，把已经过的路径记录下来，以监视递归的次数，提高效率</span><br>  &#125;<br>&#125;;<br><span class="hljs-title function_">dfs</span>(originPath);<br></code></pre></td></tr></table></figure><p>可以看到深度优先主要利用递归来实现一个路径回溯的效果，在<a href="http://leetcode-cn.com/submissions/detail/61558821">这里</a>可以看具体例子。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法[下]</title>
    <link href="/blog/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-12-sort-part-two/"/>
    <url>/blog/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-12-sort-part-two/</url>
    
    <content type="html"><![CDATA[<p>上篇文章讲述了几种初级排序算法的思想和实现方法，这篇文章我们深入一些，讲一讲归并、快速和堆这三种排序，直接进入正题。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>顾名思义归并排序的核心操作就是“归并操作”:把两个有序数组合并成一个更大的有序数组。原理是这样的：两个数组 A，B 并排放好，都从第一个数开始看，假如 A 的第一个数比较小，就把他拿出来放到新数组的第一个，然后 A 取第二个数和 B 比，反之亦然。</p><p>我们从 A，B 都只有一个数据开始归并，慢慢的把所有数据归并成一个大的有序数列。思路理清了，来看代码:</p><p>先看一步归并的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tempArr = []; <span class="hljs-comment">// 写成全局的可以节省空间</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">arr, lo, mid, hi</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = lo; m &lt;= hi; ++m) &#123;<br>    <span class="hljs-comment">// arr[lo,...hi]=&gt;tempArr[lo, ...hi]</span><br>    tempArr[m] = arr[m];<br>  &#125;<br>  <span class="hljs-keyword">let</span> i = lo;<br>  <span class="hljs-keyword">let</span> j = mid + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = lo; n &lt;= hi; ++n) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; mid) arr[n] = tempArr[j++];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; hi) arr[n] = tempArr[i++];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempArr[i] &lt;= tempArr[j]) arr[n] = tempArr[i++];<br>    <span class="hljs-keyword">else</span> arr[n] = tempArr[j++];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以将数组的前后两部分进行归并，可以看到代码中现将数组复制出来，然后再按顺序放入原数组中，这么做可以降低算法的空间复杂度。</p><p>一步归并不能将整个数组排序，我们要做的是现将子数组一一归并，然后慢慢扩大直到整个数组，这种思想叫做<code>分治法</code>，分而治之，先将数组分开，然后把小数组一步步归并成大数组，典型的实现是通过递归。先看代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr, start, end</span>) &#123;<br>  <span class="hljs-keyword">if</span> (end &lt;= start) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end - start) / <span class="hljs-number">2</span>);<br>  <span class="hljs-title function_">mergeSort</span>(arr, start, mid);<br>  <span class="hljs-title function_">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, end);<br>  <span class="hljs-title function_">merge</span>(arr, start, mid, end);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是自顶向下的，但是我们知道递归往往存在性能问题，所以还有一种自下向上的归并方式，就是用循环来做归并，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iTermergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> N = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> size = <span class="hljs-number">1</span>; size &lt; N; size *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 一个子数组长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>; start &lt; N - size; start += size + size) &#123;<br>      <span class="hljs-comment">// [1,2]、[3，4]...</span><br>      <span class="hljs-title function_">merge</span>(<br>        arr,<br>        start,<br>        start + size - <span class="hljs-number">1</span>,<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(N - <span class="hljs-number">1</span>, start + <span class="hljs-number">2</span> * size - <span class="hljs-number">1</span>)<br>      );<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用迭代的方法比较直接，没有递归那么绕，调整子数组大小，计算出起始与结束还有中间分界的位置就可以了。</p><p>下面总结一下归并排序的效率，由于我们用了分治法，归并排序的效率降到了<code>O(NlogN)</code>，比之前的算法都提高了，但美中不足的是他的空间复杂度是<code>O(N)</code>，在我们的实现中归并排序是稳定的，因为当两个数相等时我们取得是前面的数。</p><p>总体来说归并排序除了空间复杂度不是最优的之外性能已经算很好了，而且最重要的是它用了一种分治法的思想，这种思考方式在别的算法中也经常用到。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>终于到了快速排序出场的时候了，快排由于编写简单，性能非常高，常用于各种情境之下，让我们一起来看看这个传奇算法。</p><p>快排的思想也是分治法：首先选中一个中间数，将比它小的数字放到其左边，比他大的放到其右边，这是一次处理。然后分别对左右两侧的数列进行相同的处理，处理到最后整个数组就有序了。下面来看代码，我们先写整体的分治逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr, lo, hi</span>) &#123;<br>  <span class="hljs-keyword">if</span> (hi &lt;= lo) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> splitIdx = <span class="hljs-title function_">group</span>(arr, lo, hi);<br>  <span class="hljs-title function_">quickSort</span>(arr, lo, splitIdx);<br>  <span class="hljs-title function_">quickSort</span>(arr, splitIdx + <span class="hljs-number">1</span>, hi);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于数组两个位置的交换操作很多，我们封装下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, idx1, idx2</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = arr[idx1];<br>  arr[idx1] = arr[idx2];<br>  arr[idx2] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是每次分组逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">group</span>(<span class="hljs-params">arr, lo, hi</span>) &#123;<br>  <span class="hljs-keyword">let</span> i = lo;<br>  <span class="hljs-keyword">let</span> j = hi + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> splitVal = arr[lo]; <span class="hljs-comment">// 取第一个数当中间数</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr[++i] &lt;= splitVal) <span class="hljs-keyword">if</span> (i === hi) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">while</span> (arr[--j] &gt;= splitVal) <span class="hljs-keyword">if</span> (j == lo) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">swap</span>(arr, i, j);<br>  &#125;<br>  <span class="hljs-title function_">swap</span>(arr, lo, j);<br>  <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速排序的时间复杂度是<code>O(NlogN)</code>，空间复杂度是<code>O(logN)</code>，不过当数组基本倒序的时候每一次移动指针都要交换，相当于变相的冒泡排序了，这时时间复杂度为<code>O(N^2)</code>，所以我们要通过方法防止快排退化成冒泡，我打算有时间再出一篇新文章深入探讨下这个问题。</p><p>综合来看，快速排序及其变型性能很不错，可以大量用于各种情境下，jdk 封装的排序就是用的 DualPivotQuicksort，就是快排的一个变体。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>在了解堆排序之前，我们先想像这么一个业务场景：</p><blockquote><p>有个任务队列，需要做的操作有两个：加入任务和取出到最高优先级的任务。</p></blockquote><p>这个场景在工作中非常常见，我们称之为优先队列，思考下如何设计算法。我们可能会这么做：在插入的时按顺序插入，取出的时候按照选择排序的思想遍历取最大。或者在插入的时候就按大小插入，取出的时候按顺序取，这是插入排序的思想。两种方式的复杂度如下：</p><table><thead><tr><th>算法</th><th>插入复杂度</th><th>取出复杂度</th></tr></thead><tbody><tr><td>插入排序思想</td><td>O(N)</td><td>O(1)</td></tr><tr><td>选择排序思想</td><td>O(1)</td><td>O(N)</td></tr></tbody></table><p>这两种方式都可行，但是有一步都是<code>O(N)</code>级别的，在 N 很大的时候效率不高。有人就提出了一种新的思想，运用堆这种数据结构来完成这个过程，以提高效率。</p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种数据结构，通常情况下我们说的是二叉堆，它满足一下特点：</p><ol><li>它是一棵<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a></li><li>任意父节点的值大于或小于子节点(大顶堆和小顶堆)</li></ol><p><img src="/blog/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%88%9D%E5%A7%8B.png" alt="大顶堆"></p><p>这就是一个典型的大顶堆，我们在代码中为了节省空间，通常用一个数组来表示它，为了方便计算，我们把下标为 0 的位置空出来，如果一个节点的下标是 m，那么他的父节点就是<code>m/2</code>，子节点就是<code>2k</code>和<code>2k+1</code>，这样就可以很好地模拟堆的各种操作。</p><p>我们来看看这个时候插入和取出的效率如何。当我们取最大数的时候，我们可以直接取走根节点 9，然后将末节点 4 放到根节点的位置，之后只要调整 4 到合适的位置就行了，这个调整操作我们可以称之为下沉，交换之后如下图：</p><p><img src="/blog/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8B%E6%B2%89.png" alt="大顶堆堆下沉"></p><p>下沉的逻辑是：将要调整的节点和两个子节点比较，取出一个最大的交换，如果父节点本身最大就停下，如果不是就交换到相应子节点位置，然后继续以这个位置为父节点调整。如图：</p><p><img src="/blog/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8B%E6%B2%89%E8%B0%83%E6%95%B4.png" alt="大顶堆下沉调整"></p><p>其中标红的是下沉的路径，我们来实现一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sink</span>(<span class="hljs-params">arr, i, N</span>) &#123;<br>  <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= N) &#123;<br>    <span class="hljs-comment">// 非叶节点</span><br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span> * i;<br>    <span class="hljs-keyword">if</span> (j &lt; N &amp;&amp; arr[j + <span class="hljs-number">1</span>] &gt; arr[j]) j += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 父节点最大时停止下沉</span><br>    <span class="hljs-title function_">swap</span>(arr, i, j);<br>    i = j;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以算出来下沉一个节点所需的时间复杂度最大为<code>O(logN)</code>(沉到底)，当 N 很大的时候速度快了非常多。</p><p>再看插入的效率如何，插入时直接把数据放到末尾，然后将节点上浮到合适的位置。与下沉的道理差不多。</p><p><img src="/blog/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8A%E6%B5%AE%E8%B0%83%E6%95%B4.png" alt="大顶堆上浮调整"></p><p>比如我们新加入一个数字 9，红色路径就是调整路径，原理比较简单，直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">swim</span>(<span class="hljs-params">arr, i</span>) &#123;<br>  <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; arr[i] &gt; arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>)]) &#123;<br>    <span class="hljs-title function_">swap</span>(arr, i, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>));<br>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑比下潜还简单，因为子节点之间不用比较，我们掐指一算发现最大时间复杂度还是<code>O(logN)</code>，可见在优先队列中，如果 N 比较大，使用堆的方式构建优势很大。</p><h3 id="优先队列和堆排序"><a href="#优先队列和堆排序" class="headerlink" title="优先队列和堆排序"></a>优先队列和堆排序</h3><p>说到这我们已经把堆讲明白了，下面我们把它用到排序上，聪明的同学可能已经想到如何写了：</p><ol><li>把数组构建成一个堆(我们假设从小到大排，构建大顶堆)。</li><li>取出第一个数与最后一个交换，最大的数就被安排到最后一个了。</li><li>下沉第一个数(最后一个数不参与，因为它已经有序了)。</li><li>重复 2，3 步骤直到所有数都有序。</li></ol><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> N = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(N / <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-comment">// 构建堆</span><br>    <span class="hljs-title function_">sink</span>(arr, i, N);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 不断弹出第一个</span><br>    <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">1</span>, N--);<br>    <span class="hljs-title function_">sink</span>(arr, <span class="hljs-number">1</span>, N);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>取所有数的过程复杂度为<code>O(NlogN)</code>，构建堆的过程可以从后往前对每个数依次做上浮，这其实也是一种分治的思想(分治思想无处不在)，先将子树变为堆，然后将多个子树放在一起变为新堆，构建堆需要的操作数计算起来比较复杂 😓，这里直接给出结论吧，是<code>O(N)</code>。所以加起来还是<code>O(NlogN)</code>的复杂度。</p><p>堆排序的的算法写起来非常简单，性能也很高，空间复杂度为<code>O(1)</code>，除了不稳定之外没什么明显缺点，简直是宝藏算法。堆的用法很多，不仅仅可以用于排序，而且我写的基础班堆排序也有可以优化的地方，我打算日后和快速排序一起写一篇新文章。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实还有一些排序，比如桶排序，基数排序等，这里先不做研究了，最后的最后给出各个算法的性能分析表吧：</p><table><thead><tr><th>算法</th><th>稳定性</th><th>是否原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>√</td><td>√</td><td>N^2</td><td>1</td><td></td></tr><tr><td>选择排序</td><td>×</td><td>√</td><td>N^2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>√</td><td>N ~ N^2</td><td>1</td><td>基本有序时效率高</td></tr><tr><td>希尔排序</td><td>×</td><td>√</td><td>N ~ N^2</td><td>1</td><td></td></tr><tr><td>快速排序</td><td>×</td><td>√</td><td>NlogN</td><td>lgN</td><td>三项切分时效率接近线性</td></tr><tr><td>归并排序</td><td>√</td><td>×</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>√</td><td>NlogN</td><td>1</td><td>取前几个最大的数时用堆的思想</td></tr></tbody></table><p>That’s all.</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法[上]</title>
    <link href="/blog/2020/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-11-sort-part-one/"/>
    <url>/blog/2020/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-11-sort-part-one/</url>
    
    <content type="html"><![CDATA[<p>这篇文章是算法系列的第一篇，为什么写这么个系列呢，主要因为我一直对算法这个东西很好奇，非常想学，只有总结才能让我更好的系统学习，不然就是狗熊掰棒子 🙃，而且顺便能给其他同学一点点儿启发也是非常开心的一件事儿。我所有的文章都会以一种讲述的口吻来写，讲给大家听也讲给自己听。好了废话不多说，下面直接进入主题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>排序算法这个东西相信很多同学从很早就开始接触了，最开始是冒泡排序(万年入门排序)，之后再深入一些我们会了解到更多: 选择、插入、希尔、归并、快排、堆排等等，我们一一道来(假设所有的排序都是从小到大)。</p><h2 id="如何判断一个算法好坏"><a href="#如何判断一个算法好坏" class="headerlink" title="如何判断一个算法好坏"></a>如何判断一个算法好坏</h2><p>稍微了解下我们就会发现排序算法多种多样，那么我们怎么判断他们的好坏呢？几个概念应运而生:</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>快慢是衡量一个算法最最直观的方法了，我们可以直接在运行程序前后计时，得出程序的运行时间进行比较，但是有的时候我们手头没有计算机来运行程序，我们就需要一些理论知识来判断程序好坏，时间复杂度就是衡量程序快慢的一个指标，通常是人脑可以推算出来的。</p><p>当输入为 N 时，我们可以大概估出一个时间量级，我们称之为<code>O(..)</code>，当我们考虑时间复杂度的时候，通常会忽略倍数，因为在 N 比较大的时候倍数并不会影响结果，比如<code>O(N^2)</code>和<code>O(3N^2)</code>，当 N 为 100 时，常数 3 对结果影响已经没不大了，更不用说样本更大的时候了。</p><p>常见的复杂度有<code>O(1)</code>,<code>O(N)</code>,<code>O(N^2)</code>,<code>O(N^logN)</code>(出现 log 是因为二分处理情况)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>占用空间大小是另一个衡量因素，这个复杂度的意思是在样本量级为 N 的时候，程序会占用多少内存，这个指标太高也是不行的。空间复杂度也用<code>O(..)</code>表示，比如我们在算法中声明了个长度为 N 的数组来进行中间的数据处理，这时算法的空间复杂度就是<code>O(N)</code>。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>上面两个复杂度对算法都是通用的，对于排序来说还有稳定性这个指标，他是指当我们排完序之后值相同的项顺序还是否都是原来的顺序，如果是的话算法就是稳定的，否则就是不稳定。</p><p>有些时候我们在排序的过程中不想让相同值的项再改变顺序，比如：</p><blockquote><p>一个队列每一项有两个属性 A，B，我们希望整体以 A 属性的大小进行排序，但当 A 相同时我们以 B 的大小来进行排序。</p></blockquote><p>如果我们的排序算法是稳定的，那么我们可以以 B 属性大小进行排列，然后再以 A 属性大小排序。两次排序达到要求。但是如果我们的算法是不稳定的，在第二次排序的时候可能会破坏第一次的结果。</p><p>综上我们也要考虑到排序算法的稳定性。</p><h2 id="排序算法实现"><a href="#排序算法实现" class="headerlink" title="排序算法实现"></a>排序算法实现</h2><p>排序算法里选择排序、冒泡排序、插入排序、希尔排序都属于初级排序算法，相对来说效率不高，真正常用的是快排、归并排序、堆排和他们的一些变型。非常推荐在阅读文章时看看<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法的动画演示</a>，除了堆排序之外都有，堆排序在<a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">这里</a>。阅读的时候边看动画演示边看下面的代码可以让你更好的理解。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>我们从最基本的冒泡排序开始，我们这么做：1-2 比出个较大的，把较大的放到第 2 个，然后 2-3 比，较大的放在第 3 个…以此类推，遍历一轮之后我们可以获得整个数组最大的值，且时候最大的值已经被换到最后一个了。这时第一轮结束，从头遍历开始第二轮。</p><p>这种方式我们可以把它联想为一个个气泡从水底冒到水面的过程，所以称之为冒泡排序，代码实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mock = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arr.<span class="hljs-property">length</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 交换</span><br>        <span class="hljs-keyword">let</span> temp = arr[j];<br>        arr[j] = arr[j + <span class="hljs-number">1</span>];<br>        arr[j + <span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`排序后结果: <span class="hljs-subst">$&#123;bubbleSort(mock)&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>我们从上面的三个维度分析一下，我们遍历了 N 遍数组，数组中有 N 个元素，所以时间复杂度就是<code>O(N^2)</code>。(其实从第二遍起就是 N-1 了，后面越来越少，但是这种细小的次数可以忽略不计，计做 N 次)。空间复杂度上由于我们交换元素时需要有个临时变量，所以是<code>O(1)</code>。最后从稳定性上讲，如果是我上面的实现来看是稳定的，因为当两数相同时并不进行交换，如果比较的时候用<code>&gt;=</code>算法就是不稳定的了。</p><p>可见冒泡虽然实现起来简单，但是效率确实不高。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序思想比冒泡还简单：遍历数组，选择一个最小的，换到第一个位置，遍历第二遍时从第二个开始选出剩下的里面最小的，换到第二个位置…以此类推。思想比较简单，直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> minIdx;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; ++i) &#123;<br>    minIdx = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;<br>    &#125;<br>    <span class="hljs-comment">// 交换i 和 minIdx 的数据</span><br>    <span class="hljs-keyword">let</span> temp = arr[i];<br>    arr[i] = arr[minIdx];<br>    arr[minIdx] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>显而易见，时间复杂度还是<code>O(N^2)</code>，空间复杂度也是<code>O(1)</code>，另外选择排序是不稳定的，举个例子:<code>[3,2,3,1,5]</code>，在第一遍的时候第一个 3 和 1 交换，已经破坏了排序的稳定性。</p><p>选择排序符合一般人的第一想法，但是奈何效率不高还不稳定。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>当我们斗地主抽牌的时候，我们往往一张一张抽，把抽到的牌插到已有手牌的合适位置，这就是插入排序的思想。下面我们来实现一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> target = <span class="hljs-number">0</span>,<br>    nextIdx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; ++i) &#123;<br>    target = arr[i];<br>    nextIdx = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (nextIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[nextIdx] &gt; target) &#123;<br>      arr[nextIdx + <span class="hljs-number">1</span>] = arr[nextIdx];<br>      --nextIdx;<br>    &#125;<br>    arr[nextIdx + <span class="hljs-number">1</span>] = target;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序的时间复杂度也是<code>O(n^2)</code>，空间复杂度也是<code>O(1)</code>，它是一种稳定的排序。看起来和前面的两种一样低效，不过它在特定情况下比前面两种情况快得多，试想下如果数组中绝大部分的数字都已经排好序，时间复杂度会是如何？这是我们发现在向前寻找位置的时候几乎不用遍历，这时候的复杂度趋近<code>O(N)</code>，非常高效。</p><p>总体来说插入排序虽在一般情况下效率不高(但也强于前两种)，但是在特殊情况下还是可以派上用场的。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>人们发现插入排序在数据基本排好序的时候效率极高，那么有人就说了我们能不能大概先给数据排个序，然后再用插入排序？希尔排序就这么产生了。</p><p>由于插入排序只能相邻的元素移动，所以如果有个元素要从数组结尾移动到数组开头就很耗费时间，希尔排序提出一个概念：如果数组中任意间隔为 h 的数据都是有序的，则称这个数组为<code>h有序数组</code>，当 h 为 1 的时候，数组就排好序了。这样在 h 很大的时候，即使要移动距离很远也可以很快的移动过去，我们多排几遍，让 h 慢慢变小最终变为 1，每次排序都用插入排序，数组越来越有序，排序的性能也越来越高，下面看看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shellSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> h = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (h &lt; arr.<span class="hljs-property">length</span> / <span class="hljs-number">3</span>) h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">let</span> target = <span class="hljs-number">0</span>,<br>      nextIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = h; i &lt; arr.<span class="hljs-property">length</span>; i += h) &#123;<br>      target = arr[i];<br>      nextIdx = i - h;<br>      <span class="hljs-keyword">while</span> (nextIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[nextIdx] &gt; target) &#123;<br>        arr[nextIdx + h] = arr[nextIdx];<br>        nextIdx -= h;<br>      &#125;<br>      arr[nextIdx + h] = target;<br>    &#125;<br>    h = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(h / <span class="hljs-number">3</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显能看出来，希尔排序的写法是基于插入排序的，我这里 h 的设置方法是比较常用的。希尔排序是个很神奇的排序，因为他仅仅比插入排序多加了个<code>h有序数组</code>的概念，性能就可以达到插入排序的很多倍。至今专家们也没找到一个 h 数列使性能最大化，但是无论如何都是比插入排序快很多的，小于<code>O(N^2)</code>，空间复杂度上来讲还是<code>O(1)</code>，唯一比插入排序差的就是它不稳定。</p><p>总结一下，希尔排序在插入排序的基础上大大优化了性能，虽然比不上快排、堆排等算法，但胜在编写简单，性能可接受。(虽然还是用不上)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是冒泡、选择、插入、希尔的基本思想和简单实现，这几种排序都被称为初级排序算法，效率并不高，在<code>排序算法[下]</code>中我们将深入了解几种高级算法，敬请期待…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next.js</title>
    <link href="/blog/2020/02/10/2020-02-10-Nextjs/"/>
    <url>/blog/2020/02/10/2020-02-10-Nextjs/</url>
    
    <content type="html"><![CDATA[<p>本篇文章是笔者在实践了官方 tutorial 之后总结出的一些要点，目的在于节省以后复习的时间，如果能帮到大家就最好不过了。</p><h2 id="一、主要优势"><a href="#一、主要优势" class="headerlink" title="一、主要优势"></a>一、主要优势</h2><ol><li>Sever rendering</li><li>Static site 建立极其简单</li><li>CSS-in-JS</li><li>Zero Setup</li><li>Complete over Babel and Webpack</li><li>Smaller build size, faster compilation</li></ol><h2 id="二、实践出真知"><a href="#二、实践出真知" class="headerlink" title="二、实践出真知"></a>二、实践出真知</h2><h3 id="1-Router"><a href="#1-Router" class="headerlink" title="1. Router"></a>1. Router</h3><p>在 page 文件夹中新建一个组件，使用<code>&lt;Link href=&#39;...&#39;&gt;</code>进行页面内跳转，这种跳转是 Client 端的，不对服务器做请求。<code>Link</code>这个组件已经封装好了 location.history 的逻辑，不用自己再写。</p><blockquote><p><code>Link</code>只是用做跳转的一个子组件，在上面加属性是没用的。</p></blockquote><p>router 可以通过 Hook <code>useRouter</code>取得，有一些 api 可用，如简单的有<code>router.query</code>可以取得 query 参数。</p><p>通过<code>[]</code>符号可以在 pages 文件夹中声明动态 url 组件，比如属性为 id 时在跳转的时候写法类似:<code>/xx/[id]</code>，pages 中的文件名就起为<code>[id].js</code>，在页面组件中可通过<code>router.query.id</code>获取。动态表示<code>href</code>的时候可以用<code>as</code>属性来决定 url 中显示的内容。</p><h3 id="2-组件化"><a href="#2-组件化" class="headerlink" title="2. 组件化"></a>2. 组件化</h3><p>组件化和 react 大同小异，传参嵌套，HOC，没有过多可说的。</p><h3 id="3-数据通讯"><a href="#3-数据通讯" class="headerlink" title="3. 数据通讯"></a>3. 数据通讯</h3><p>next 为我们封装了个函数来获取远端数据-<code>getInitialProps</code>，这个函数接受一个参数 context，通过<code>context.query</code>可以获得 url 参数。</p><blockquote><p><code>getInitialProps</code>这个函数只可用于 page 组件中。</p></blockquote><p>由于直接访问页面时是服务器端渲染的，使用<code>console.log</code>打印出的内容也是在服务器端，但是如果是点击<code>Link</code>标签跳转到的页面进行<code>console.log</code>，由于之前也提到过<code>Link</code>跳转实在 Client 端进行的，不请求服务器，所以输出就是在浏览器的终端里，一定要注意。</p><h3 id="4-UI-样式"><a href="#4-UI-样式" class="headerlink" title="4. UI 样式"></a>4. UI 样式</h3><p>next 不同于大多数框架，采用 css-in-js 的方式，在 jsx 中直接添加标签如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style jsx&gt;&#123;<span class="hljs-string">`</span><br><span class="hljs-string">  a &#123; ... &#125;</span><br><span class="hljs-string">`</span>&#125;&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>一定不要忘了<code>&#123;``&#125;</code>。</p><p>另外这种形式的 style 是局部的，也就是于自身存在的 jsx 中有效，对子组件中的内容都无效。如果要全局作用，在 css 中使用伪类<code>:global(..)</code>即可。或者使用<code>&lt;style jsx global&gt;</code>也可以。</p><blockquote><p>官方不建议使用全局样式。</p></blockquote><h3 id="5-API-Routes"><a href="#5-API-Routes" class="headerlink" title="5. API Routes"></a>5. API Routes</h3><p>nextjs 提供一种 serveless 的方式来构建 api。</p><p>只需在<code>/pages/api</code>文件夹下创建 js 文件，默认会变为 api 接口，文件名就是接口名，文件内容类似:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> quotes <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../quotes.json&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> quote = quotes[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * quotes.<span class="hljs-property">length</span>)];<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(quote);<br>&#125;;<br></code></pre></td></tr></table></figure><p>传入的 req 可以用来获取请求信息，比如可以通过<code>req.query</code>获取 url 中的 query 参数。</p><blockquote><p>swr 是一种异步获取数据的<code>React Hook</code>，<code>useSWR(&#39;/api/..&#39;, fetcher)</code>，fetcher 传入 url，返回数据。</p></blockquote><h3 id="6-部署"><a href="#6-部署" class="headerlink" title="6. 部署"></a>6. 部署</h3><p>如果需要单独部署 nextjs 项目，也可以直接使用<code>next build</code>和<code>next start</code>命令进行本地部署，start 的时候可以添加 p 参数，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># package.json中</span><br><span class="hljs-string">&quot;script&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;next&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;next build&quot;</span>,<br>  <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;next start -p <span class="hljs-variable">$PORT</span>&quot;</span><br>  <span class="hljs-comment"># windows 写做next start -p %PORT%</span><br>&#125;<br><br><span class="hljs-comment"># 在运行的时候</span><br>PORT=2333 npm start<br><span class="hljs-comment"># windows 写做 cross-env PORT=2333 npm start</span><br></code></pre></td></tr></table></figure><p>通过官方提供的<code>Zeit now</code>(创办 Zeit 的是个神人，同时也是 Next 的作者，有兴趣可以去了解下)。Now 这个平台的本质是个专门进行部署的网站，还有一些可以帮你快速建站，非常牛逼。</p><p>通过在项目下简单的<code>now</code>命令就可以在 Now 平台上进行部署了(可以获得一个网站的 url 供人访问)。</p><blockquote><p>在使用命令之前，需要在<a href="https://zeit.co/">now 官网</a>中进行注册，然后在命令行中初次使用时需要通过<code>now login</code>进行登录(会给你发个 confirm 邮件，确认时需要翻墙)。</p></blockquote><h3 id="7-支持静态页面导出"><a href="#7-支持静态页面导出" class="headerlink" title="7. 支持静态页面导出"></a>7. 支持静态页面导出</h3><p>通过命令<code>next export</code>可以进行静态页面导出(在 build 之后)，但需要进行一些配置。</p><p>在根目录下创建 next.config.js 配置文件 内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>  <span class="hljs-attr">exportTrailingSlash</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">exportPathMap</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;...&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>如果只是更改了配置文件里的内容，则不用重新 build</p></blockquote><p>其中比较重要的是<code>exportPathMap</code>这个属性，他是一个函数，返回值是 url map，如果一个 url 没有在这个函数返回，那么我们不能在地址栏里手动输入路径以访问此页面(跳转过去是可以的)。</p><p>那么我们可以动态的在<code>exportPathMap</code>中返回路径，这个方法可以是异步的，这意味着我们可以在这个方法里通过调用 api 获取路径并添加到返回值里(添加的路径在输出文件夹中会单独形成一个文件)。</p><h3 id="8-typescript-完美支持"><a href="#8-typescript-完美支持" class="headerlink" title="8. typescript 完美支持"></a>8. typescript 完美支持</h3><p>只需要添加简单的一句<code>cnpm install --save-dev typescript @types/react @types/node</code>，nextjs 完美支持 typescript，超简单。</p><h3 id="9-支持-AMP-没什么好说的"><a href="#9-支持-AMP-没什么好说的" class="headerlink" title="9. 支持 AMP(没什么好说的)"></a>9. 支持 AMP(没什么好说的)</h3><h3 id="10-支持懒加载模块"><a href="#10-支持懒加载模块" class="headerlink" title="10. 支持懒加载模块"></a>10. 支持懒加载模块</h3><p>通过<code>await import(&#39;..&#39;)</code>这种语法可以让程序在第一次执行到这里的时候再加载，大大提高首屏效率。</p><h3 id="三、-总结"><a href="#三、-总结" class="headerlink" title="三、 总结"></a>三、 总结</h3><p>nextjs 提供了很多便捷的一键式的操作，更有 now 平台的各种模板便于用户快速建立并部署自己的网站，而且还提供了 ssr，懒加载等技术进行效率的提高。着实是一个非常出色的框架，笔者过两天会使用此框架重构作品集网站，到时再对此框架做更深入的测评。</p>]]></content>
    
    
    <categories>
      
      <category>javascript框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>nextjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表驱动法</title>
    <link href="/blog/2020/02/09/Code%20Complete/2020-02-09-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/"/>
    <url>/blog/2020/02/09/Code%20Complete/2020-02-09-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在阅读Code Complete，非常有实践性的一本书，通过这本书记录下对第18章表驱动法的一些个人理解和感悟，在构建自己知识体系的基础上产出一些东西，以便于和其他人交流学习。如有不正确的地方，欢迎斧正。</p></blockquote><h2 id="一、何谓表驱动法"><a href="#一、何谓表驱动法" class="headerlink" title="一、何谓表驱动法"></a>一、何谓表驱动法</h2><p>表驱动法实际是一种思想，目标是把复杂的if&#x2F;else程序逻辑语句转换成易维护，高可读的程序。这是一种基本思想，最好能熟练运用，做到如臂使指。</p><h2 id="二、表驱动法的常见分类"><a href="#二、表驱动法的常见分类" class="headerlink" title="二、表驱动法的常见分类"></a>二、表驱动法的常见分类</h2><p>表驱动法的核心是维护一个键值对列表(<strong>y&#x3D;f(x)</strong>)，所以分类也是根据这个列表的形态来分的。如果在逻辑中出现很多if&#x2F;else的并列和嵌套，我们就可以去找找逻辑上的映射关系来简化程序。</p><h3 id="1-直接访问表"><a href="#1-直接访问表" class="headerlink" title="1.直接访问表"></a>1.直接访问表</h3><h4 id="①单一自变量映射"><a href="#①单一自变量映射" class="headerlink" title="①单一自变量映射"></a>①单一自变量映射</h4><p>直接访问表的特征是:以目标值作为索引来获得对应的结果。这里举个简单的栗子🌰:</p><blockquote><p>如果我们想通过周几来取得当天计划</p></blockquote><p>一般的写法可能是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSchedule</span>(<span class="hljs-params">day</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(day) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Mon&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周一去听经&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Tues&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周二住旅馆&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Thurs&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周三看电影&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然用if&#x2F;else也是一样的写法，如果我们用访问表的思想就是这个样子的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSchedule</span>(<span class="hljs-params">day</span>) &#123;<br>  <span class="hljs-keyword">const</span> schedule = &#123;<br>    <span class="hljs-string">&#x27;Mon&#x27;</span>: <span class="hljs-string">&#x27;周一去听经&#x27;</span>,<br>    <span class="hljs-string">&#x27;Tues&#x27;</span>: <span class="hljs-string">&#x27;周二住旅馆&#x27;</span>,<br>    <span class="hljs-string">&#x27;Thurs&#x27;</span>: <span class="hljs-string">&#x27;周三看电影&#x27;</span>,<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> schedule[day];<br>&#125;<br></code></pre></td></tr></table></figure><p>当索引很多的时候，这个时候用访问表的思想可以明显提高可读性，另外这个表也可以是从文件或者别的地方读取的，因而可以做到热部署。也是这种方式的优势之一，</p><h4 id="②多自变量映射"><a href="#②多自变量映射" class="headerlink" title="②多自变量映射"></a>②多自变量映射</h4><p>那么新问题出现了，我们在实际编程中一定遇到过这种情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">whatever</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span>(A) &#123;<br>    <span class="hljs-keyword">if</span>(B) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种嵌套的自变量让人很头疼，我们不能通过单一的A或者B就得出结果(<strong>u&#x3D;f(x,y,z)</strong>)，那么我们应该如何建立映射关系呢？</p><p>答案是一一列举自变量，通过程序一一保存结果到一个映射表里，最后在用的时候达到如下的效果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getResult</span>(A, B, C);<span class="hljs-comment">// getResult从表里向外取之前存好的值</span><br></code></pre></td></tr></table></figure><p>我个人认为这种方式在很多情况下并不优雅，所以多自变量的时候需要我们酌情使用。</p><h4 id="③自变量的范围映射"><a href="#③自变量的范围映射" class="headerlink" title="③自变量的范围映射"></a>③自变量的范围映射</h4><p>比如说某个数据段内是一个值，如第一个例子中如果是:周一到周三都是一个计划，这时就有两种解决方案。一种是冗余一种是简化。</p><p>我们可以在我们的表里把周一的内容复制到周二周三，这样就达到了目的，不过数据会出现冗余，出错概率也会增大。</p><p>我们也可以建立另一个映射，比如当传入的<code>day</code>是周一到周三的时候，都映射到<code>Mon</code>上，这个新映射可以单独封装在一个<code>keyFromDay()</code>函数中。</p><h3 id="2-索引访问表"><a href="#2-索引访问表" class="headerlink" title="2.索引访问表"></a>2.索引访问表</h3><p>当上面的<code>keyFromDay()</code>没法简单的用公式转化的时候，可以在函数里再进行一次访问表，把常用索引列为一个数组使用，个人感觉实用价值不高。</p><h3 id="3-阶梯访问表"><a href="#3-阶梯访问表" class="headerlink" title="3.阶梯访问表"></a>3.阶梯访问表</h3><p>当出现阶段性的索引时，可以用阶梯访问表的方式，比如:</p><p>通过数字大小决定单位:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 由于是例子 不考虑非数字输入</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addUnit</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">const</span> abs = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(num);<br>  <span class="hljs-keyword">if</span>(abs &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;num&#125;</span>个`</span>;<br>  <span class="hljs-keyword">const</span> units = [<span class="hljs-string">&#x27;个&#x27;</span>,<span class="hljs-string">&#x27;千&#x27;</span>,<span class="hljs-string">&#x27;万&#x27;</span>,<span class="hljs-string">&#x27;亿&#x27;</span>];<br>  <span class="hljs-keyword">const</span> limits = [<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000000</span>];<br>  <span class="hljs-keyword">const</span> maxIdx = units.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> idx = maxIdx-<span class="hljs-number">1</span>; idx &gt;= <span class="hljs-number">0</span>; --idx) &#123;<br>    <span class="hljs-keyword">if</span>(abs &gt;= limits[idx]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;num/limits[idx].toFixed(<span class="hljs-number">1</span>)&#125;</span><span class="hljs-subst">$&#123;units[idx]&#125;</span>`</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比一大堆<code>if/else</code>简明，易于扩展和修改。</p>]]></content>
    
    
    <categories>
      
      <category>code-complete</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Table的固定表头表身滚动写法</title>
    <link href="/blog/2018/11/07/2018-11-07-%E5%9B%BA%E5%AE%9A%E8%A1%A8%E5%A4%B4%E8%A1%A8%E8%BA%AB%E6%BB%9A%E5%8A%A8%E5%86%99%E6%B3%95/"/>
    <url>/blog/2018/11/07/2018-11-07-%E5%9B%BA%E5%AE%9A%E8%A1%A8%E5%A4%B4%E8%A1%A8%E8%BA%AB%E6%BB%9A%E5%8A%A8%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在工作中遇到一个需求，固定表头表身滚动，乍看之下非常简单，但是却耗费了我很长时间来解决。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>如果需要列表滚动，只需要简单的<code>overflow-y:auto/scroll</code>就可以轻松实现。<br>如果需要单纯的表格，只需要用 html 基础语法<code>table</code>就可以轻松实现。</p><p>BUT！当<code>overflow-y:auto/scroll</code>遇到<code>table</code>中的<code>tbody</code>，就会阴阳错乱、五行颠倒，列也对不齐了，宽也不为 100%了。是的，他俩单用没问题，合起来简直有毒。这是由于语言本身特性造成的，看来使用通常的方法是行不通了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>索性经过多方调查，还是有解决方案的，那就是：把两个<code>table</code>嵌套到一起。一个表作为表头，隐藏<code>tbody</code>，另一个作为表身，只显示<code>tobdy</code>，使用<code>position:absolute</code>让他们合体。<br><del>竟然要用这种方式来实现，怎么设计的？</del></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>html 部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;kols-tables&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inner-header-table&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inner-body-table&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css 部分(LESS)：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.kols-tables</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span>; <span class="hljs-comment">// 此处要和inner-header-table中的height相等</span><br>  <span class="hljs-selector-class">.inner-header-table</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.inner-body-table</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">// 填满空间</span><br>    <span class="hljs-attribute">overflow-y</span>: auto;<br>    <span class="hljs-selector-tag">table</span> &#123;<br>      <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">30px</span>; <span class="hljs-comment">// 这里通过负margin的方式控制body于表头的距离</span><br>    &#125;<br>    <span class="hljs-selector-tag">th</span> &#123;<br>      <span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">// 表头隐藏但占位</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>css 部分代码总结起来就是：用<code>flex</code>做内容充满，使用<code>absolute</code>做表头固定，使用<code>margin-top</code>负值做 body 的位置调整，<code>visibility</code>使 body 表头占位不显示。<br>虽然一定有别的方法可以实现同样的效果，但是为了避免反复试错可以把这种模式记为公式，以便今后使用。可喜可贺~ ｄ(･∀･*)♪ ﾟ</p>]]></content>
    
    
    <categories>
      
      <category>web基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用DevicePixelRatio来清晰化canvas</title>
    <link href="/blog/2018/11/07/2018-11-07-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE%E6%9D%A5%E6%B8%85%E6%99%B0%E5%8C%96canvas/"/>
    <url>/blog/2018/11/07/2018-11-07-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE%E6%9D%A5%E6%B8%85%E6%99%B0%E5%8C%96canvas/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在工作中需要用到 canvas 来绘制复杂图表，在绘制的过程中出现了图案模糊的问题。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>经过上网搜索，找到了解决方案，先来解释一下原因。</p><p>显示屏有两个重要参数： 1.像素数，指物理像素。一个像素对应一组发光管，多组发光管组成屏幕，一般市面上的笔记本显示屏多是 1920x1080 像素的。 2.设备像素比(DevicePixelRatio，以下简称 dpr)，也就是多少个像素为一个逻辑像素，比如 dpr 为 2 的显示屏它一个逻辑像素点实际是 4 个物理像素组成的(2x2)，dpr 越高，画质越细腻。我们在编程中使用的皆为逻辑像素。</p><p>由于我使用的是 Retina 屏，dpr 为 2。再来说下 Html5 canvas 渲染的机制： 1.画出来：浏览器用位图模式渲染 canvas 中的内容，即用<code>canvas.width</code>x<code>canvas.height</code>的<strong>物理像素</strong>画图。 2.塞进去：将画出来的图“塞进“画布中，画布的宽高为 css 中定义的<code>width</code>x<code>height</code>。</p><p>这样模糊的原因就明了了：在 Retina 屏(Mac)中，dpr 为 2，如果<code>canvas.width</code>和<code>canvas.height</code>被设为逻辑像素，则在“画出来”的时候图案大小就为预想的<code>1/dpr</code>，这时的“塞进去”就变为放大图案了，所以画面就变得模糊了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>分析之后解决方案就十分明显了。我们只需要将<code>canvas.width</code>和<code>canvas.height</code>按照物理像素来设置(<code>width*ptr,height*ptr</code>)就 ok 了，不过要注意的是画布中内容的半径和粗细等参数也得相应扩大 ptr 倍，不然图案放大之后会比预想的要细。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>为了更加清晰，这里把关键代码展示一下(jsx)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;&#123;200*devicePixelRatio&#125;&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;&#123;200*devicePixelRatio&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br>// 另外注意在画图的时候也要 将相应的图案参数 * devicePixelRatio<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">canvas</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决，可喜可贺，可喜可贺~ (*≧∪≦)</p>]]></content>
    
    
    <categories>
      
      <category>web基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SASS知识点总结</title>
    <link href="/blog/2018/06/08/2018-06-08-SASS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2018/06/08/2018-06-08-SASS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>几条基本的命令:</p><ul><li><code>sass-convert xx.sass xx.scss</code>或<code>sass-convert xx.scss xx.sass</code>:sass 与 scss 格式之间的相互转换</li><li><code>sass xx.scss xx.css</code>:编译 scss 文件成为 css</li><li><code>sass --watch xx.scss:xx.css</code>:编译并监控，当 scss 更改时自动生成 css 文件(可以监控一个文件夹)</li><li><code>sass --style compressed xx.scss:xx.css</code>:使用压缩模式编译，除了<code>!</code>型注释都被删除(<code>!</code>型注释见后文)</li></ul><h2 id="二、sass-扩展特性"><a href="#二、sass-扩展特性" class="headerlink" title="二、sass 扩展特性"></a>二、sass 扩展特性</h2><h3 id="1-嵌套规则"><a href="#1-嵌套规则" class="headerlink" title="1. 嵌套规则"></a>1. 嵌套规则</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#outter</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outter</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-id">#outter</span> <span class="hljs-selector-id">#inner</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优势是可以省去嵌套的重复代码。</p><p>扩展特性：</p><ul><li>可以多层嵌套。</li><li>内部可以用<code>&amp;</code>来代指外层元素，用法为<code>&amp;:hover</code>、<code>&amp;-xx</code>等。**&amp;只能出现在选择器最开始的位置**。</li><li>可以通过<code>:</code>实现 css 属性嵌套用法如下:</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span> fantasy &#123;<br>    <span class="hljs-comment">// 外层元素也可以赋值</span><br>    weight: bold;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span> fantasy;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>分两种:<code>//</code>和<code>/* */</code>。在编译为 css 的时候<code>//</code>会被删除，另一种不会。</p><p>扩展特性:</p><ul><li>如果注释为<code>/* */</code>类型且以<code>!</code>开头，则这部分注释在压缩模式编译的时候仍然会保留这部分的注释，常用语作者信息。</li><li>在注释中可以使用插值语法(使用<code>#&#123;$xx&#125;</code>插入 scss 变量)</li></ul><h3 id="3-SassScript"><a href="#3-SassScript" class="headerlink" title="3. SassScript"></a>3. SassScript</h3><p>SassScript 使 sass 成为一种可编程的语言，大大提高了灵活性。</p><h4 id="3-1-变量声明"><a href="#3-1-变量声明" class="headerlink" title="3.1 变量声明"></a>3.1 变量声明</h4><p>我们可以使用<code>$</code>符号进行变量声明，如<code>$w: 5em</code>,在后续代码中我们就可以使用<code>$w</code>这个变量了，在编译的时候会自动进行替换。</p><p>扩展特性:</p><ul><li>我们可以声明局部变量，即在一个选择器的<code>&#123;&#125;</code>之中声明变量，这样只有在这个<code>&#123;&#125;</code>范围内可以使用这个变量。局部变量后面加上<code>!global</code>标记也可以将变量全局化。</li><li>我们可以在变量声明的时候在后面加上<code>!default</code>，这表示如果变量已经有值且不为<code>null</code>，则本次声明跳过，否则不跳过。</li></ul><h4 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h4><p>同一般的语言一样，SassScript 中也内置了一些数据类型:</p><h5 id="3-2-1-numbers-1-2-13-10px-等"><a href="#3-2-1-numbers-1-2-13-10px-等" class="headerlink" title="3.2.1 numbers (1.2,13,10px 等)"></a>3.2.1 numbers (1.2,13,10px 等)</h5><p>只要 number 的单位一致<code>+ - * / % == != &gt;= &lt;= &gt; &lt;</code>都是可用的。比如<code>10px*10px==100px*1px</code>会得到<code>true</code>，注意乘法的时候单位也会变为平方，就是说<code>10px*10px==100px</code>会得到<code>false</code>。</p><blockquote><p><code>== !=</code>这两个运算符是可以用于所有类型的。</p></blockquote><h6 id="3-2-1-1-x2F-注意事项"><a href="#3-2-1-1-x2F-注意事项" class="headerlink" title="3.2.1.1 &#x2F;注意事项"></a>3.2.1.1 &#x2F;注意事项</h6><p><code>/</code>在三种情况下会进行运算编译:</p><ol><li>运算符之一为方法或 scss 变量</li><li>运算式被括号包裹，且不在数组中。</li><li>算式中存在<code>+</code></li></ol><p>如果你就是想得到<code>10px/20px</code>这种形式，分子分母一起用<code>#&#123;$xx&#125;</code>即可。</p><h6 id="3-2-1-2-注意事项"><a href="#3-2-1-2-注意事项" class="headerlink" title="3.2.1.2 -注意事项"></a>3.2.1.2 -注意事项</h6><p><code>-</code>的使用只需要记住以下几点:</p><ol><li>想要减法运算就保持<code>-</code>两边都有空格</li><li>前有空格后没有则表示负数</li><li>在空格分割的数组中，将<code>-$var</code>这种形式的表达式用括号包裹起来，不然会进行减法运算</li></ol><h5 id="3-2-2-strings-三种方式”foo”-’foo’-foo"><a href="#3-2-2-strings-三种方式”foo”-’foo’-foo" class="headerlink" title="3.2.2 strings (三种方式”foo”,’foo’,foo)"></a>3.2.2 strings (三种方式”foo”,’foo’,foo)</h5><p>三种表达方式：单引号、双引号、没引号。使用起来基本没有不同，但有一个特例：如果是使用插值语法(<code>#&#123;$xx&#125;</code>)，且<code>$xx</code>是一个带引号的 string，则会自动去除引号。这个特性一般针对 mixin,如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> f-message(<span class="hljs-variable">$selector</span>) &#123;<br>  <span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.f</span> #&#123;<span class="hljs-variable">$selector</span>&#125;<span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Hello!&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> f-message(<span class="hljs-string">&quot;.header&quot;</span>);<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.f</span> <span class="hljs-selector-class">.header</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-2-2-1-字符串运算注意事项"><a href="#3-2-2-1-字符串运算注意事项" class="headerlink" title="3.2.2.1 字符串运算注意事项"></a>3.2.2.1 字符串运算注意事项</h6><p>字符串可以直接通过<code>+</code>进行相加，在字符串中可以使用插值语法(<code>#&#123;$xx&#125;</code>)来进行动态加法，如果插值内容为 null，则被视为空字符串。</p><h5 id="3-2-3-colors-blue-123-rgba-0-0-0-0-5"><a href="#3-2-3-colors-blue-123-rgba-0-0-0-0-5" class="headerlink" title="3.2.3 colors (blue, #123, rgba(0,0,0,0.5))"></a>3.2.3 colors (blue, #123, rgba(0,0,0,0.5))</h5><p>在压缩模式下编译颜色的时候，引擎会挑选最短的名称，如<code>#FF0000=&gt;red,blanchedalmond=&gt;#FFEBCD</code>。如果要将颜色的字符串，比如<code>blanchedalmond</code>用到选择器插值中，请一定加上引号，如果是如下代码:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$b</span>: blanchedalmond;<br><br><span class="hljs-selector-tag">body</span> #&#123;<span class="hljs-variable">$b</span>&#125; &#123;<br>  <span class="hljs-attribute">background</span>: #&#123;<span class="hljs-variable">$b</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>压缩编译后的结果是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#ffebcd</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffebcd</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就造成了语法错误，这种情况下，请将 blanchedalmond 加上引号，这样压缩模式编译的时候<code>#ffebcd</code>的位置就会变成<code>blanchedalmond</code>。</p><h6 id="3-2-3-1-颜色运算注意事项"><a href="#3-2-3-1-颜色运算注意事项" class="headerlink" title="3.2.3.1 颜色运算注意事项"></a>3.2.3.1 颜色运算注意事项</h6><p>颜色可以直接进行<code>+ - * /</code>，本质是 R、G、B 三种颜色的运算，如果某种颜色超过了<code>ff</code>则结果为<code>ff</code>。支持<code># rgba等形式</code>，在<code>rgba</code>形式中，两个透明度如果相同，则透明度不变，如果不同，则抛出错误。</p><h5 id="3-2-4-booleans-true-x2F-false"><a href="#3-2-4-booleans-true-x2F-false" class="headerlink" title="3.2.4 booleans (true&#x2F;false)"></a>3.2.4 booleans (true&#x2F;false)</h5><blockquote><p>布尔运算支持<code>and</code>、<code>or</code>和<code>not</code></p></blockquote><h5 id="3-2-5-nulls-null"><a href="#3-2-5-nulls-null" class="headerlink" title="3.2.5 nulls (null)"></a>3.2.5 nulls (null)</h5><h5 id="3-2-6-lists-如-1-5em-1em-0-1em-HE-AP"><a href="#3-2-6-lists-如-1-5em-1em-0-1em-HE-AP" class="headerlink" title="3.2.6 lists (如 1.5em 1em 0.1em,HE,AP)"></a>3.2.6 lists (如 1.5em 1em 0.1em,HE,AP)</h5><p>lists 多用于多值的 css 属性，比如 margin，border 等，在 sass 中，单个的值其实也被看作只有一个值的数组。lists 有两种表示形式，以空格分隔和以逗号分隔。</p><p>SassScript 提供了一些关于 list 的使用方法：</p><ul><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#nth-instance_method">nth</a>，访问数组中固定位置的元素。</li><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#join-instance_method">join</a>，组合两个数组。</li><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#append-instance_method">append</a>，添加值到数组。</li><li><a href="https://www.sass.hk/en/documentation/file.SASS_REFERENCE.html#each-directive">@each</a>，遍历数组。</li></ul><p>数组中可以嵌套数组，通过括号的方式:<code>(1px 2px) (3px 4px)</code>编译成 css 之后括号会被去除，但在 scss 中带不带括号是大不相同的。</p><blockquote><p>在 scss 编译的过程中，括号或<code>null</code>或<code>空元素()</code>都会被去掉。<br>使用逗号可以表示单元素数组:<code>(1,)</code>。<br>数组不支持任何运算符，请用封装好的方法进行运算。</p></blockquote><h5 id="3-2-7-maps-如-key1-value1-key2-value2"><a href="#3-2-7-maps-如-key1-value1-key2-value2" class="headerlink" title="3.2.7 maps (如(key1: value1, key2: value2))"></a>3.2.7 maps (如(key1: value1, key2: value2))</h5><p>map 相当于键值对，如<code>$map: (k1: v1, k2: v2, k3: v3);</code>,map 必须被括号包裹，用逗号分割，key 和 value 可以是任何值，key 不能重复。map 有也有一系列的<a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#map-functions">方法</a>，这里不赘述了，请看文档。使用<code>@each</code>遍历的时候，访问顺序和声明顺序一致。我们可以将数组的 list 使用在 map 上，这时 map 会被看作一个数组<code>(k1:v1,k2:v2)=&gt;k1 v1,k2 v2</code>,反之不可。<strong>map 不能直接被转化为 css，只用于中间运算。</strong></p><h4 id="3-3-特殊语法"><a href="#3-3-特殊语法" class="headerlink" title="3.3 特殊语法"></a>3.3 特殊语法</h4><blockquote><p>这里有<a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html">内置函数的列表</a>，使用时可以查阅。</p></blockquote><h5 id="3-3-1-命名参数"><a href="#3-3-1-命名参数" class="headerlink" title="3.3.1 命名参数"></a>3.3.1 命名参数</h5><p><code>hsl($hue: 0, $saturation: 100%, $lightness: 50%)</code>，使用这种命名参数可以在一个函数有多个参数可选的时候明确参数，看起来比较清晰。</p><h5 id="3-3-2-插值"><a href="#3-3-2-插值" class="headerlink" title="3.3.2 插值"></a>3.3.2 插值</h5><p>使用插值语法<code>#&#123;$xx&#125;</code>可以将变量转化为<code>Plain CSS</code>，相邻的运算符不会生效，如<code>#$&#123;a&#125;/#&#123;$b&#125;</code>不会进行计算。</p><h5 id="3-3-3-amp-语法"><a href="#3-3-3-amp-语法" class="headerlink" title="3.3.3 &amp;语法"></a>3.3.3 &amp;语法</h5><p><code>&amp;</code>可以表示父选择器，<code>&amp;</code>可以用作变量进行计算，在做变量的时候是双层嵌套的数组，比如<code>body a</code>的<code>&amp;</code>为<code>((body, a),)</code>。</p><p>如果没有父选择器(mixin)，<code>&amp;</code>为 null，可以通过如下代码判断是否有父选择器:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> does-parent-exist &#123;<br>  <span class="hljs-keyword">@if</span> &amp; &#123;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>  &#125; <span class="hljs-keyword">@else</span> &#123;<br>    <span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-指令集"><a href="#4-指令集" class="headerlink" title="4. @指令集"></a>4. @指令集</h3><h4 id="4-1-import"><a href="#4-1-import" class="headerlink" title="4.1 @import"></a>4.1 @import</h4><p>我们可以通过<code>@import &#39;xx.scss&#39;</code>的形式引入另外的<code>scss</code>文件，如果不加后缀，引擎会自动寻找<code>.scss</code>和<code>.sass</code>文件。</p><p>css 中也有<code>@import</code>这个指令，除了以下 4 种情况直接原文编译成 css，其他的情况都会进行 scss 编译导入:</p><ol><li>文件扩展名为<code>.css</code></li><li>文件名以<code>http://</code>开始</li><li>文件名是<code>url(xx)</code></li><li>@import 中有任何媒体查询</li></ol><blockquote><p><code>@import &quot;a&quot;, &quot;b&quot;;</code>可以同时引入多个文件。</p></blockquote><p>如果不想让 scss 文件编译后导入，可以在要引用的文件名前加<code>_</code>，这样就不会编译成<code>.css</code>文件了。如:<code>_out.scss</code>文件，导入时使用<code>@import &quot;out&quot;;</code>即可，但要注意不要吧前置<code>_</code>和不前置的同名文件放在同一个文件夹下。</p><h4 id="4-2-media"><a href="#4-2-media" class="headerlink" title="4.2 @media"></a>4.2 @media</h4><p><code>@media</code>在 css 可以直接使用，在 scss 中多出一点特性:可以嵌套在 css 规则中。解析的时候会依次寻找到跟选择器，然后把规则加在整体的选择器上，如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: wheat;<br>  inner &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    innner &#123;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>) &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>      &#125;<br>      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: wheat;<br>&#125;<br><span class="hljs-selector-tag">body</span> inner &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span> inner innner &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> inner innner &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> inner innner &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同样在<code>@media</code>语句中可以使用插值语法<code>#&#123;$xx&#125;</code>。</p></blockquote><h4 id="4-3-extend"><a href="#4-3-extend" class="headerlink" title="4.3 @extend"></a>4.3 @extend</h4><p><code>@extend</code>是<code>sass</code>扩展的特性，和<code>Java</code>中的继承类似相当于拷贝了父选择器的所有属性，使用方法如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .father;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span>,<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<code>.son</code>就有了<code>.father</code>的所有属性了!我们可以看到其实他的内部原理就是把所有<code>.father</code>的地方换成<code>.father, .son</code>。如果产生了<code>.father.father</code>或<code>#a#b</code>这种不合理的东西，引擎会自动删减掉，非常智能。</p><blockquote><p>多继承是可以的，基本原理还是一样:把所有<code>.father</code>的地方换成<code>.father, .son</code>，如果有重复属性，则后来者优先。写法上讲可以写两行也可以逗号分割。<br>多重继承也是可以的，即 A extend B，B extend C。最后的结果通过上述原理也可以推出来。</p></blockquote><p>如果父子两个选择器都不是单一元素，都是很长一串的话，有个交叉的合并方法，规则是如果两个没有公用元素，则只会有 a 在 b 前和 b 在 a 前两种。如果有重复元素就把重复的提取出来再做交叉，具体例子如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span>,<br><span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细体会一下。</p><h5 id="4-3-2-extend-only"><a href="#4-3-2-extend-only" class="headerlink" title="4.3.2 @extend-only"></a>4.3.2 @extend-only</h5><p>有些时候有些规则我们只想在<code>@extend</code>中使用，编译时我们想剔除它。这时就要用<code>%</code>来修饰，用法如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> %e &#123;<br>  <span class="hljs-attribute">color</span>: beige;<br>&#125;<br><br><span class="hljs-selector-id">#inner</span> <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %e;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-id">#inner</span> <span class="hljs-selector-tag">b</span>,<br><span class="hljs-selector-id">#inner</span> <span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-attribute">color</span>: beige;<br>&#125;<br></code></pre></td></tr></table></figure><p>在生成的 css 代码中没有<code>#outer a %e</code>这一项，这就是<code>@extend-only</code>的用法。(别忘了这里可以用交叉合并的方式推导出生成的选择器)</p><blockquote><p>注意如果在<code>@media</code>内部使用<code>@extend</code>，则父规则也要在<code>@media</code>里，否则报错。</p></blockquote><h5 id="4-3-3-at-root"><a href="#4-3-3-at-root" class="headerlink" title="4.3.3 @at-root"></a>4.3.3 @at-root</h5><p>这个指令可以让后面的语句声明在全局中，有了它在别的规则中也可以声明全局规则了！还可以多行声明，像这样:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-keyword">@at-root</span> &#123;<br>    <span class="hljs-selector-class">.inner</span> &#123;<br>      <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>    <span class="hljs-selector-class">.inner2</span> &#123;<br>      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-selector-class">.inner3</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.inner</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.inner2</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.outer</span> <span class="hljs-selector-class">.inner3</span> &#123;<br>  <span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以在<code>@at-root</code>后面加上<code>(with: ...)或(without: ...)</code>去添加或者去除父级<code>@指令</code>，默认是不去除的，所以<code>without</code>使用的较多，<code>without: all</code>代表去除所有父级元素，<code>without:rule</code>代表去除所有父级<code>@指令</code>。</p></blockquote><h5 id="4-3-4-debug"><a href="#4-3-4-debug" class="headerlink" title="4.3.4 @debug"></a>4.3.4 @debug</h5><p>这个指令可以用来输出调试信息，我们想看某个变量或者表达式的话，在编译的时候直接可以看到，很方便。</p><blockquote><p>同样类型的还有<code>@warn</code>、<code>@error</code>，<code>@error</code>会直接阻断编译，<code>@warn</code>多用于第三方库警告。</p></blockquote><h5 id="4-3-5-mixin"><a href="#4-3-5-mixin" class="headerlink" title="4.3.5 @mixin"></a>4.3.5 @mixin</h5><p><code>@mixin</code>和<code>@extend</code>都可以进行规则的复用，<code>@mixin</code>可以避免使用<code>@extend</code>必须声明的无语义的类名，甚至我们可以在<code>@mixin</code>中加入参数，增强灵活性。</p><p>基本使用语法如下(参数是可选的):</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> large-text(<span class="hljs-variable">$color</span>) &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    size: <span class="hljs-number">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-keyword">@include</span> large-text(<span class="hljs-number">#fff</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于参数，我们可以使用<strong>关键字参数</strong>来明确参数对应关系，写法如:<code>sexy-border($color: blue)</code>。<br>由于历史原因，mixin 的名字中<code>_</code>和<code>-</code>是可以通用的，这两个字符可以随意互换。<br>多数编程语言中的<code>...</code>语法在 scss 中也可以使用，使用在参数中时可以自动将传入参数包装成一个数组。个人感觉完全可以用数组或 map 变量代替。</p></blockquote><p>通过<code>@include</code>可以引入<code>@mixin</code>规则，<code>@mixin</code>是一组规则的叠加，和<code>@extend</code>的原理是截然不同的。而且<code>@include</code>可以在任何地方使用，这和继承也是不同的。</p><p><code>@mixin</code>可以配合<code>@content</code>实现”插槽”，例如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> test-block &#123;<br>  <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-keyword">@content</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-keyword">@include</span> test-block &#123;<br>    <span class="hljs-selector-id">#abc</span> &#123;<br>      <span class="hljs-attribute">color</span>: black;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果<code>@content</code>被循环包裹，生成的 css 中会有好几组重复的规则，需要注意。<br>内置方法<code>content-exists()</code>用于在运行时判断是否传入规则块，强制传入规则块可以用这个。</p></blockquote><p><code>@mixin</code>也可以嵌套<code>@mixin</code>，规则的叠加，很好理解。</p><h3 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5. 控制语句"></a>5. 控制语句</h3><p>同大部分语言一样，sass 也有控制语句的功能，多配合<code>mixins</code>使用。</p><h4 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if()"></a>5.1 if()</h4><p><code>if()</code>语句是内置函数，使用方式类似三元表达式，如<code>if(1+1==2, 1px, 2px)</code>,可以用于变量赋值。</p><blockquote><p><code>@if</code>语句可用于规则声明，使用方式如<code>@if 1+1==2 &#123;color: white&#125;</code>。后面可以跟一系列的<code>@else if</code>和<code>@else</code>语句，用法和<code>Js</code>中类似。</p></blockquote><h4 id="5-2-for"><a href="#5-2-for" class="headerlink" title="5.2 @for"></a>5.2 @for</h4><p>循环语句，使用方法如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果会是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span>;<br>&#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>;<br>&#125;<br><span class="hljs-selector-class">.item-3</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-each"><a href="#5-3-each" class="headerlink" title="5.3 @each"></a>5.3 @each</h4><p><code>@each</code>也是循环，用来循环数组，使用方式如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/#&#123;$animal&#125;.png&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/puma.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/sea-slug.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/egret.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.salamander-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/salamander.png&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于多维数组，上例中的<code>$animal</code>可以写为一个数组，和多维数组中的数一一对应，访问的时候也是一维一维访问。<br><code>@each</code>也可以用来访问 map，map 中的键和值会当作一个数组，所以<code>$animal</code>的位置应该写两个变量。</p></blockquote><h4 id="5-4-while"><a href="#5-4-while" class="headerlink" title="5.4 @while"></a>5.4 @while</h4><p>这个指令也是循环，用法和<code>js</code>类似，只不过赋值语句变为<code>$i: $i-1</code>这种形式。</p><h4 id="5-5-function"><a href="#5-5-function" class="headerlink" title="5.5 @function"></a>5.5 @function</h4><p>scss 支持函数，使用<code>@function</code>定义函数，使用<code>@return</code>返回值，最好加上前缀，以免和内置函数重名。关于参数的特性其实跟<code>@mixin</code>差不多，都是一些常规功能。由于历史原因，函数名中的<code>-</code>和<code>_</code>是互通的，这和 mixin 也一样。</p><h3 id="5-输出格式参数"><a href="#5-输出格式参数" class="headerlink" title="5. 输出格式参数"></a>5. 输出格式参数</h3><p>虽然默认输出的 css 格式很实用，scss 也提供了一些参数供我们手动调整，我们在命令行中使用<code>--style xx</code>来设置输出格式，格式有如下几种:</p><ul><li>nested</li></ul><p>这是默认的输出格式，每个属性一行，简明易懂，但后大括号不是单占一行的，和我们平时手写的格式有点不同。</p><ul><li>expanded</li></ul><p>在<code>nested</code>基础上，后大括号单占一行，和我们常规手写格式一模一样。</p><ul><li>compact</li></ul><p>每个选择器和它的规则单占一行，压缩率更高。</p><ul><li>compressed</li></ul><p>压缩模式，所有都在一行，需要极致压缩文件时用。</p><h3 id="6-sass-扩展"><a href="#6-sass-扩展" class="headerlink" title="6. sass 扩展"></a>6. sass 扩展</h3><p>我们可以通过<code>Ruby</code>支持的一些函数手动扩展 sass 特性，但是这需要我们对<code>Ruby</code>有很强的理解，这里就不赘述了。</p>]]></content>
    
    
    <categories>
      
      <category>代码样式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode初体验</title>
    <link href="/blog/2018/06/01/2018-06-01-vscode%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/blog/2018/06/01/2018-06-01-vscode%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>其实我本人对微软这家公司出品的产品不怎么感兴趣。<del>算是半个微软黑？</del>，所以当初<code>vscode</code>和<code>atom</code>这两款产品同时出现的我面前的时候，我想也没想直接选择了<code>atom</code>。</p><p>但是最近愈发无法忍受<code>atom</code>安装插件的速度，非常慢，有时还会失败，真的很让人头痛。所以在朋友的大力”怂恿”下我尝试了下微软的<code>Vitual Studio Code</code>这款编辑器。总体感受就两个字–舒服，下载插件的速度基本控制在 10s 以内，在 github 上它的 star 数还高于<code>atom</code>，可见插件库的丰富程度也是可以的。</p><p>所以今天我想在这里记录一下我在<code>vscode</code>中做的一些个人配置和主观感受，以供那些还在犹豫使用哪个文本编辑器的人一些参考。</p><h3 id="二、markdown-篇"><a href="#二、markdown-篇" class="headerlink" title="二、markdown 篇"></a>二、markdown 篇</h3><p>就我个人而言，大部分使用文本编辑器的时间都是在用 markdown 语言写一些记录性的文章，就像我现在在做的:)针对 markdown，我安装了如下插件:</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>:由于<code>vscode</code>是自带 markdown 预览的，所以我们不用为了预览去单独安装插件，但是这个预览有个问题就是背景是跟你所选主题同色的，我个人一般会选择黑色主题，图片一般是白色背景，所以感觉很别扭，这个插件可以把本地预览的效果变为和 github 中一致，这样就不会有任何违和感~</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=goessner.mdmath">Markdown+Math</a>:使用了这个插件后，我们就可以在 markdown 中使用 TeX 数学公式了。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a>:这个插件可以用来 lint 你的 markdown 代码，长期按照一个靠谱的规范书写 markdown 可以方便日后和别人做交流，如果有哪条规则不想要可以手动在配置文件里禁止。</p></li></ul><h3 id="三、通用篇"><a href="#三、通用篇" class="headerlink" title="三、通用篇"></a>三、通用篇</h3><p>还有一些通用的插件能提升我们的编码效率，在这里列举一下:</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) Language Pack for Visual Studio Code</a>:官方中文包，使用与因人而异吧，个人感觉中文看着更舒服。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory">Git History</a>:用来显示 git 历史，显示效果不错。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=spywhere.guides">Guides</a>:用来添加对齐用的辅助线，看着更舒服。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a>:一整套文件图标，更美观。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime">WakaTime</a>:神器，想知道你一天的工作效率如何？wakatime 满足你。</p></li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>总的来说<code>vscode</code>给我的感觉是很惊艳的，用到现在位置非常流畅，以上内容只是<code>vscode</code>的极小部分的功能，如果想了解更多可以到<a href="https://code.visualstudio.com/docs">官网教程</a>自行查看，非常详细。</p><p><strong>Have a nice day!</strong></p>]]></content>
    
    
    <categories>
      
      <category>优质工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[译]简明易懂javascript闭包</title>
    <link href="/blog/2018/05/27/2018-05-27-%5B%E8%AF%91%5D%E7%AE%80%E6%98%8E%E6%98%93%E6%87%82javascript%E9%97%AD%E5%8C%85/"/>
    <url>/blog/2018/05/27/2018-05-27-%5B%E8%AF%91%5D%E7%AE%80%E6%98%8E%E6%98%93%E6%87%82javascript%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天带来一篇关于 javacript 闭包的文章，文章来自 stackoverflow 的一个高票回答，个人感觉非常不错，兴致来了翻译一下，方便大家和我日后回顾，也顺便锻炼下我的英文水平:)。原文地址<a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work">在这</a>，本文目的只是学习研究，如有不妥当之处，请通过邮件告知我，非常感谢！</p></blockquote><h3 id="那么，正文开始～"><a href="#那么，正文开始～" class="headerlink" title="那么，正文开始～"></a>那么，正文开始～</h3><h4 id="一、闭包不是魔法"><a href="#一、闭包不是魔法" class="headerlink" title="一、闭包不是魔法"></a>一、闭包不是魔法</h4><p>本文的目的是通过小段 js 代码为广大程序员说明闭包，目标群体并不是此方面的专家。<br>如果理解了闭包的核心概念，闭包并不是一个很难理解的问题。但是如果仅仅靠阅读学术文章是不可能理解闭包的。这篇文章需要一些基本的编程知识，如果你可以读懂下面这段代码，那么恭喜你，理解这篇文章对你来说不是问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>  &#125;;<br>  <span class="hljs-title function_">say</span>();<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;Joe&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="二、一个栗子"><a href="#二、一个栗子" class="headerlink" title="二、一个栗子"></a>二、一个栗子</h4><p>闭包可以用两种方式来总结，即:</p><ul><li>闭包是一种支持<a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>的方式。他可以引用其第一次声明时的范围内的变量，我们可以任意使用变量，赋值、当作参数传递，或者通过 return 返回都是可以的。</li><li>闭包是当一个函数开始执行的时候，js 内部自动分配的一种堆栈结构，即使函数返回了这个堆栈结构都不会被释放(这种数据结构是分配在堆上而不是栈上的!)。</li></ul><p>如下代码返回了一个函数引用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello2</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello &quot;</span> + name; <span class="hljs-comment">// Local variable</span><br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-keyword">var</span> say2 = <span class="hljs-title function_">sayHello2</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><span class="hljs-title function_">say2</span>(); <span class="hljs-comment">// logs &quot;Hello Bob&quot;</span><br></code></pre></td></tr></table></figure><p>大多数 js 工程师都能理解上述代码中函数引用作为返回值的用法。如果你不能理解，那么你应该先了解一下这部分内容然后再继续学习闭包。一个 C 语言工程师可能会认为这个函数返回了另一个函数的指针，变量<code>say</code>和<code>say2</code>都是函数指针。<br>但是在 js 中上述代码和函数指针有一个重大的不同。在 js 中，你可以把函数引用理解为<strong>函数指针+闭包的隐形引用</strong>。<br>上述代码由于匿名函数<code>function() &#123; console.log(text); &#125;</code>声明在另一个函数(sayHello2)中，所以可以称之为闭包。在 javascript 中，如果你在一个方法中使用<code>function</code>这个关键字，你就创建了一个闭包。<br>在大部分语言中，在一个函数返回后，所有局部变量就都不能访问了，因为他们的堆栈结构都被销毁了。<br>在 js 中，如果你在一个函数中定义另一个函数，在外部函数返回后，外部函数的局部变量仍可以被内部函数访问，上述代码就是这个现象的演示。我们在<code>sayHello2()</code>函数返回后去调用<code>say2()</code>，注意<code>text</code>这个变量是<code>sayHello2()</code>的局部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text); &#125; <span class="hljs-comment">// Output of say2.toString();</span><br></code></pre></td></tr></table></figure><p>上述代码为 say2.toString()的值，我们可以看到上述代码中引用了变量<code>text</code>。这个匿名函数可以引用<code>text</code>这个变量(值为<code>Hello Bob</code>)，这是因为<code>sayHello()</code>的局部变量被保存在了闭包中。<br>神奇之处在于 js 中函数的引用会包含一个隐形的引用指向外部函数的闭包–相当于包含一个函数的指针+一个隐形的对象引用。</p><h4 id="三、更多的栗子"><a href="#三、更多的栗子" class="headerlink" title="三、更多的栗子"></a>三、更多的栗子</h4><p>在你阅读闭包释义的时候很难理解其中奥妙，但是当你看一些例子之后就会明白他们是如何工作的。我建议把下列例子仔细弄明白。如果你在使用闭包之前没有对其有充分的理解，你可能会制造一些十分诡异的 bug。</p><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h5><p>这个例子说明了局部变量并不是被拷贝的–闭包中存的是他们的引用。可以理解为当外部函数退出时，变量的堆栈结构被存储在了内存中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say667</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>  &#125;;<br>  num++;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-keyword">var</span> sayNumber = <span class="hljs-title function_">say667</span>();<br><span class="hljs-title function_">sayNumber</span>(); <span class="hljs-comment">// logs 43</span><br></code></pre></td></tr></table></figure><h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h5><p>这三个全局函数持有同一个闭包的引用，因为他们都被定义在了函数<code>setupSomeGlobals()</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> gLogNumber, gIncreaseNumber, gSetNumber;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupSomeGlobals</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">42</span>;<br>  <span class="hljs-comment">// Store some references to functions as global variables</span><br>  gLogNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>  &#125;;<br>  gIncreaseNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    num++;<br>  &#125;;<br>  gSetNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    num = x;<br>  &#125;;<br>&#125;<br><br><span class="hljs-title function_">setupSomeGlobals</span>();<br><span class="hljs-title function_">gIncreaseNumber</span>();<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 43</span><br><span class="hljs-title function_">gSetNumber</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">var</span> oldLog = gLogNumber;<br><br><span class="hljs-title function_">setupSomeGlobals</span>();<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 42</span><br><br><span class="hljs-title function_">oldLog</span>(); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>这三个函数共享同一个闭包–函数<code>setupSomeGlobals()</code>的局部变量。<br>注意在以上例子中，如果你又调用了一次<code>setupSomeGlobals()</code>函数，一个新的闭包(堆栈结构)就会被创建。旧的<code>gLogNumber</code>、<code>gIncreaseNumber</code>、<code>gSetNumber</code>这三个变量会被拥有新闭包的新函数覆盖。(在 js 中，当你创建这种嵌套 function 的关系后，每次调用外部函数都会生成新的闭包)。</p><h5 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h5><p>这个例子向我们说明了，闭包会涵盖外部函数结束前声明的所有局部变量。注意变量<code>alice</code>实际上是在匿名函数之后声明的。匿名函数先声明，但是在匿名函数之中可以访问<code>alice</code>变量(js 有<a href="https://stackoverflow.com/a/3725763/1269037">变量提升</a>的机制)。<code>sayAlice()()</code>直接调用<code>sayAlice()</code>返回的函数引用-这样调用哦不需要临时变量。</p><blockquote><p><code>say</code>这个变量也被保存在闭包中，所有在<code>sayAlice()</code>中声明的内部函数都可以调用他，甚至<code>say()</code>函数中也可以进行递归调用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayAlice</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice);<br>  &#125;;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> alice = <span class="hljs-string">&quot;Hello Alice&quot;</span>;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-title function_">sayAlice</span>()(); <span class="hljs-comment">// logs &quot;Hello Alice&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6"></a>Example 6</h5><p>这个例子很多人已经理解原因了，所以你也要了解一下。当我们在循环中定义方法的时候要格外小心，闭包中包含的局部变量可能会出人意料。<br>在看这个例子之前，你要先理解之前提到的变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildList</span>(<span class="hljs-params">list</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> item = <span class="hljs-string">&quot;item&quot;</span> + i;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item + <span class="hljs-string">&quot; &quot;</span> + list[i]);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> fnlist = <span class="hljs-title function_">buildList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>  <span class="hljs-comment">// Using j only to help prevent confusion -- could use i.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; fnlist.<span class="hljs-property">length</span>; j++) &#123;<br>    fnlist[j]();<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">testList</span>(); <span class="hljs-comment">//logs &quot;item2 undefined&quot; 3 times</span><br></code></pre></td></tr></table></figure><p><code>result.push( function() &#123;console.log(item + &#39; &#39; + list[i])&#125; );</code>这行三次将匿名函数的引用加入到<code>result</code>数组中，如果你对匿名函数不了解，你可以将其看作如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pointer = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item + <span class="hljs-string">&quot; &quot;</span> + list[i]);<br>&#125;;<br>result.<span class="hljs-title function_">push</span>(pointer);<br></code></pre></td></tr></table></figure><p>这段代码的输出是三次<code>item2 undefined</code>!其中的原因类似之前的例子，这三个匿名函数包含同一个<code>buildList</code>闭包(其中包含<code>result</code>、<code>i</code>和<code>item</code>变量)。当<code>fnlist[j]();</code>这句代码运行的时候，他们使用的都是同一个闭包，同一组变量。这时<code>i</code>循环完毕，被累加到 3(<code>i++</code>),<code>item</code>变量一次次被覆盖，最后结果为<code>item2</code>。</p><p>当我们使用块级作用域声明<code>item</code>(通过<code>let</code>关键字)而不是使用函数作用域(通过<code>var</code>关键字)的时候，在<code>result</code>数组中存放的每个匿名函数都会有一个单独的闭包。输出会变为下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">item0 <span class="hljs-literal">undefined</span><br>item1 <span class="hljs-literal">undefined</span><br>item2 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>如果再把循环中使用的<code>i</code>通过<code>let</code>改为块级作用域的时候，我们会发现结果正常了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">item0 <span class="hljs-number">1</span><br>item1 <span class="hljs-number">2</span><br>item2 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="Example-7"><a href="#Example-7" class="headerlink" title="Example 7"></a>Example 7</h5><p>最后一个例子，每次调用<code>newClosure()</code>函数的时候都会新建一个单独的闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newClosure</span>(<span class="hljs-params">someNum, someRef</span>) &#123;<br>  <span class="hljs-comment">// Local variables that end up within closure</span><br>  <span class="hljs-keyword">var</span> num = someNum;<br>  <span class="hljs-keyword">var</span> anArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> ref = someRef;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    num += x;<br>    anArray.<span class="hljs-title function_">push</span>(num);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">&quot;num: &quot;</span> +<br>        num +<br>        <span class="hljs-string">&quot;; anArray: &quot;</span> +<br>        anArray.<span class="hljs-title function_">toString</span>() +<br>        <span class="hljs-string">&quot;; ref.someVar: &quot;</span> +<br>        ref.<span class="hljs-property">someVar</span> +<br>        <span class="hljs-string">&quot;;&quot;</span><br>    );<br>  &#125;;<br>&#125;<br>obj = &#123; <span class="hljs-attr">someVar</span>: <span class="hljs-number">4</span> &#125;;<br>fn1 = <span class="hljs-title function_">newClosure</span>(<span class="hljs-number">4</span>, obj);<br>fn2 = <span class="hljs-title function_">newClosure</span>(<span class="hljs-number">5</span>, obj);<br><span class="hljs-title function_">fn1</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// num: 5; anArray: 1,2,3,5; ref.someVar: 4;</span><br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// num: 6; anArray: 1,2,3,6; ref.someVar: 4;</span><br>obj.<span class="hljs-property">someVar</span>++;<br><span class="hljs-title function_">fn1</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;</span><br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;</span><br></code></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>如果还有任何不清晰的地方，可以自己再研究运行下上面的例子。通过代码梳理思路比看释义要简单的多。我对闭包的堆栈结构之类的分析，在技术上来讲不完全准确–但这样解释可以明显的简化概念，便于理解。先搞懂大体的逻辑，具体的细节可以在日后使用的时候慢慢理解。</p><h4 id="五、知识点"><a href="#五、知识点" class="headerlink" title="五、知识点"></a>五、知识点</h4><ul><li>每当你在一个函数中声明另一个函数中时，闭包就出现了。</li><li>当你在一个函数中使用<code>eval()</code>时，闭包出现。你在参数中可以调用外部函数的局部变量，在<code>eval</code>内你甚至可以通过<code>eval(&#39;var foo=...&#39;)</code>来创建新的局部变量。</li><li>当你在一个函数中使用<code>new Function(...)</code>(函数的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">构造器</a>，并不会产生闭包(在内部函数中不能使用外部函数的局部变量)。</li><li>闭包包含所有外部函数中的所有局部变量，只要在外部函数返回前声明的都会包含。</li><li>我们可以这么想，一个闭包只是创建了一个函数入口，局部变量被加入到闭包中。</li><li>每当外部函数被调用时，一个新的闭包被创建。</li><li>两个函数可能内容相同，但是运行出来的结果不同，这可能是因为隐藏的闭包。</li><li>函数的多层嵌套是可能的，你可能获得多级的闭包。(即内部函数的内部函数可以访问外部函数的局部变量)。</li><li>我通常认为闭包是函数声明和局部变量的集合体，虽然我在本篇文章中没有使用这个方式定义。</li><li>我怀疑 js 中的闭包和一般的函数式语言的实现方式不同。</li></ul><h4 id="六、相关链接"><a href="#六、相关链接" class="headerlink" title="六、相关链接"></a>六、相关链接</h4><ul><li>Douglas Crockford 通过闭包来实现<a href="http://www.crockford.com/javascript/private.html">私有方法和私有变量的模拟</a>。</li><li>一个很好的<a href="https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited">例子</a>，这个例子解释了闭包在 IE 中是如何导致内存泄漏的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue基础篇:动画和过渡</title>
    <link href="/blog/2018/05/24/2018-05-24-vue%E5%9F%BA%E7%A1%80%E7%AF%87:%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/"/>
    <url>/blog/2018/05/24/2018-05-24-vue%E5%9F%BA%E7%A1%80%E7%AF%87:%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>动态效果是可以大幅度提高网站美观度的，vue 当然也进行了相应的封装。下面总结一下这些效果的用法。</p><h4 id="二、过渡"><a href="#二、过渡" class="headerlink" title="二、过渡"></a>二、过渡</h4><p>过渡是可以在元素创建、删除、更新时(<code>v-if</code>、<code>v-show</code>)附加上的动态效果。</p><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isDisplay&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test-enter-active</span>,<br><span class="hljs-selector-class">.test-leave-active</span> &#123;<br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span>;<br>&#125;<br><span class="hljs-selector-class">.test-enter</span>,<br><span class="hljs-selector-class">.test-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本原理是 vue 引擎在侦测到 transition 组件存在的时候，会在恰当的时机对目标元素插入 css 类，插入的类总体有六个，示意图如下(按照添加顺序排列)，六个类的第一个单词应替换为 transition 组件中的 name：<br><img src="https://cn.vuejs.org/images/transition.png" alt="过渡的css类加载流程"></p><p>通过在 transition 属性中自定义过渡类别和持续时间，我们可以实现很丰富的动态效果。</p><h4 id="三、动画"><a href="#三、动画" class="headerlink" title="三、动画"></a>三、动画</h4><p>将过渡的用法稍微改变一下:在 css 代码中将 transition 替换为 animation+keyframes，就可以将 css 中的动画附加到过渡效果中，举个栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test-enter-active</span> &#123;<br>  <span class="hljs-attribute">animation</span>: test <span class="hljs-number">0.5s</span>;<br>&#125;<br><span class="hljs-selector-class">.test-leave-active</span> &#123;<br>  <span class="hljs-attribute">animation</span>: test <span class="hljs-number">0.5s</span> reverse;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> test &#123;<br>  <span class="hljs-number">20%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">40%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">60%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">80%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这动画效果最后会走出一个菱形。总体来说，动画和过渡都依赖于 transition 这个属性，在 css 属性上过渡使用 transition 属性，动画使用 animation 属性。</p><h4 id="四、自定义类名"><a href="#四、自定义类名" class="headerlink" title="四、自定义类名"></a>四、自定义类名</h4><p>一些简单的动画和过渡效果我们可以手动编写，但是遇到一些复杂的动态效果再手动编写就不太方便了。所以 vue 提供了自定义类名的功能。栗子继续(需要事先引入第三方库<a href="https://github.com/daneden/animate.css">animate.css</a>)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">&quot;animated tada&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">&quot;animated bounceOutRight&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样，对应之前提到的 6 个状态分别有 6 个类：<br><code>enter-class</code>、<code>enter-active-class</code>、<code>enter-to-class</code>、<code>leave-class</code>、<code>leave-active-class</code>、<code>leave-to-class</code></p><p>通过这种方式我们就可以方便的使用第三方库中已经封装好的动态效果。</p><blockquote><p>transition 组件可以通过传递 duration 属性来确定动画时间，如<code>:duration=&quot;&#123;enter: 1000, leave: 2000&#125;&quot;</code>指的是进入效果 1s，离开效果 2s，如果只是一个数字则进入离开都是这个时间。</p></blockquote><h4 id="五、javascript-钩子"><a href="#五、javascript-钩子" class="headerlink" title="五、javascript 钩子"></a>五、javascript 钩子</h4><p>transition 不光可以和第三方 css 库结合，还可以和第三方 js 库结合，通过 js 钩子的形式，动态效果的编写变得更加灵活简单。可用的钩子有<code>@before-enter</code>、<code>@enter</code>、<code>@after-enter</code>、<code>@enter-cancelled</code>、<code>@before-leave</code>、<code>@leave</code>、<code>@after-leave</code>、<code>@leave-cancelled</code>，字面意思很直观的表现出了具体对应哪个阶段。代码片段如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> @<span class="hljs-attr">enter</span>=<span class="hljs-string">&quot;enter&quot;</span>&gt;</span><br>  xxx<br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">enter</span>(<span class="hljs-params">el, done</span>) &#123;<br>    <span class="hljs-title class_">Velocity</span>(el, &#123;<span class="hljs-attr">translateX</span>: <span class="hljs-string">&#x27;50px&#x27;</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>&#125;,&#123; <span class="hljs-attr">duration</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">complete</span>: done &#125;);<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>类似如此写法就可以轻易的将第三方 js 库 velocity.js 融入到 vuejs 中，相当方便。需要注意的是如果使用的是 enter 或 leave 这两个钩子，在最后需要手动调用 done 方法，上述代码就是在 Velocity 的回调中调用了 done 方法。</p><h4 id="六、初始渲染"><a href="#六、初始渲染" class="headerlink" title="六、初始渲染"></a>六、初始渲染</h4><p>在最初渲染时也有对应的一套钩子和属性，初始渲染可以这么写:<code>&lt;transition appear&gt;&lt;/transition&gt;</code>，css 对应的属性为<code>appear-class</code>、<code>appear-to-class</code>、<code>appear-active-class</code>这三个，用法和第三节自定义类名相同。<br>钩子对应的是<code>@before-appear</code>、<code>@appear</code>、<code>@after-appear</code>、<code>@appear-cancelled</code>这四个，用法同第五节。</p><h4 id="七、transition-group"><a href="#七、transition-group" class="headerlink" title="七、transition-group"></a>七、transition-group</h4><p>截止当前，transition 的相关使用方式已经讲解的差不多了。但是 transition 有个知名弱点就是他不能同时包裹多个元素。但多个元素同时添加过渡效果又是很常用的场景，所以<code>transition-group</code>闪亮登场。</p><p><code>transition-group</code>的使用方式和<code>transition</code>极其类似，前几章列举的集中用法:js 钩子、自定义类、初始渲染、动画，都可以直接用在<code>transition-group</code>上。</p><p>下面说多出的特性：</p><ol><li>这个组件在 vue 引擎渲染的时候会自动退化为一个 span 元素，可以通过 tag 属性来设置退化成的元素类型。比如<code>tag=&quot;ul&quot;</code>就会让组件自动退化成 ul 元素，这在子元素是 li 循环的时候是很好用的。</li><li><code>v-move</code>特性，这个特性让一个，他会在元素改变定位的过程中使用。比如，多个元素换位置，这个过程既不是新增又不是删除，之前说的<code>v-enter</code>、<code>v-leave</code>那一套都控制不了这个过程，这时<code>v-move</code>就派上用场了，用法和<code>v-leave</code>相同，都是将<code>v-</code>替换成相应的前缀即可，这样在所有元素进行为止移动的时候都会按照<code>v-move</code>定义的方式进行动态效果渲染。</li><li>多个组件渲染过渡效果就有了一个先后顺序的问题。官方网站给出的例子是使用<strong>js 钩子</strong>+<strong>Velocity.js</strong>+<strong>setTimeOut</strong>,通过回调方法，来随时间推移设置过渡，代码如下:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">enter</span>(<span class="hljs-params">el, done</span>) &#123;<br>  <span class="hljs-keyword">const</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">500</span>;<br>  <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title class_">Velocity</span>(el, &#123;..&#125;, &#123;<span class="hljs-attr">complete</span>: done&#125;);<br>  &#125;, delay);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顺带一提，el.dataset.index 的方式可以从 el 元素上提取附带的数据。html 中的写法是<code>&lt;x data-index=&quot;&quot;&gt;&lt;/x&gt;</code>,这是 html 规范，并不是 vuejs 中定义的内容。</p></blockquote><h4 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h4><p>vue 过渡的用法封装的简单明了，最后附上导图以便理清思路:<br><img src="https://i.loli.net/2018/05/24/5b06699797362.png" alt="Vue过渡与动画导图.png"></p>]]></content>
    
    
    <categories>
      
      <category>javascript框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
