<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>有关科学上网的基本原理</title>
    <link href="/2020/11/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB/2020-11-03-%E6%9C%89%E5%85%B3%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2020/11/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB/2020-11-03-%E6%9C%89%E5%85%B3%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近研究了下有关梯子的原理和构建方法，感到很复杂，很有趣。这篇文章旨在记录我在研究中的一些重要的点(谁叫我记性不好呢)。</p></blockquote><p>一、原理</p><p>主要由于一些政治因素吧，GFW出现了，出现的原因不是我们关心的重点，本节主要说说GFW的基本原理。通俗的来讲就是在网络出口处设置了一个审查装置，来定向的封锁某些符合特征的数据包，在我们大众的视角里体现为一些网站上不去了。我们以时间顺序简单说明下原理的演进:</p><ol><li>最初的时候</li></ol><p><img src="/images/scientific-internet-access/gfw-theory-1.png" alt="gfw原理"></p><p>没有gfw的时候，我们的PC和外网服务器还没有隔阂。和多年前一样，请求经由路由器、骨干网、DNS服务器转发到目标服务器。</p><ol start="2"><li>GFW的出现</li></ol><p>有一天，GFW出现了，那么它都做了些什么呢？</p><ul><li><p>GFW可以在我们进行DNS服务器解析的时候进行<code>域名污染</code>：当GFW发现我们访问的域名为需要拦截的，就返回一个假的结果。</p></li><li><p>GFW查看请求的内容，如果发现需要拦截的关键字，就对其进行阻断，此为<code>关键字阻断</code></p></li><li><p><code>端口阻断</code>：GFW可以对一些常用的端口进行阻断，比如443，22等</p></li><li><p>经过长时间的积累，GFW将可以的IP地址记录下来，如果发现，直接阻断，这就是<code>IP地址阻断</code></p></li></ul><p>当然随着时间的积累，技术也在迭代更新，阻断的方式也会越来越多。</p><p>我们不必强求了解所有的阻断方式，即使强求也得不到所有的，除非你认识GFW的架构师而且他愿意告诉你(ﾟ▽ﾟ)&#x2F;</p><ol start="3"><li>原始的梯子</li></ol><p>就像黑暗和光明是结伴而生，GFW的出现也一定会伴随着破解程序的出现，也就是我们所说的梯子。最早的梯子使用的原理叫做VPN(Virtual Private Network)：</p><p><img src="/images/scientific-internet-access/gfw-theory-2.png" alt="VPN原理"></p><p>通过上图代理的方式确实可以完美规避GFW的监测，但是好景不长，GFW发现短期内出现大量通过VPN上外网的行为，所以出了应对措施：封闭VPN请求需要的端口，如果使用，必须报备，并且记录可疑代理的IP地址实行IP封锁。措施一经推出，基本VPN这种方式就行不通了。</p><ol start="4"><li>救世主ShadowSocks协议<br></li></ol><p>VPN倒下后，难道就没有方法穿过GFW了吗？不，救世主ShadowSocks(以下简称SS)适时的出现了，SS的出现打破了僵局。</p><p><img src="/images/scientific-internet-access/gfw-theory-3.png" alt="SS原理"></p><p>既然建立加密通道请求会被作为特征被识别，我们在通过GFW之前提前加密不就好了。SS这种方式让GFW很难辨别(当然现在这种方式肯定还是可能被嗅探到的，毕竟GFW原理谁也说不清)。</p><ol start="5"><li>新生代V2Ray和Trojan等</li></ol><p>无敌的SS顶住压力后，有一些新生代协议也随之诞生，其中比较有名的要数V2Ray和Trojan，不过一句话来说这些协议都是在SS的基础上构建，各有优劣。V2Ray相比SS多了几次加密，安全性稍好一些，但相对的性能稍差、Trojan在V2Ray的基础上针对TLS+Websocket这个方式进行了优化，但是代价是只能用这个协议，不那么通用。这些协议包括很多没说的协议的原理对于我来说不重要，所以也不多说了。</p><p>二、自建SS还是机场</p><p>其实这些原理说起来也简单，有些人可能会觉得自己做一个会很容易。其实不然，自建SS真正的难点在于GFW对我们来说是一个黑盒，我们对其原理不甚清楚，而且网络数据的流动需要经过多个节点。当我们发现我们自建的SS使用不了时，如何快速定位问题才是难点，即使刚建起来的时候心情非常澎湃，像是干了件多大的丰功伟业，但是当这个SS被封很多次之后，在重建的过程中我们的热情也会被消磨殆尽。</p><p>所以综合来说如果做SS只是为了玩儿，那自建SS的确挺好玩儿的，但是如果我们只是想看看油管，刷刷twitter、ins，那么选择一个好的机场才是正道。</p><p>三、总结</p><p>整体来讲科学上网从原理上还是比较简单的，了解这些底层知识可以有效提高我们对网络基础，特别是网络代理这块的理解。对于我这种一般用户来说，使用机场就足够了，但真要落实到一个性价比高的机场，还得进行不断的尝试，如果有机会，在使用过一些机场后我会新开一篇文章来写一写使用体验。</p>]]></content>
    
    
    <categories>
      
      <category>程序员的基本素养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科学上网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地静态文件调试远程接口的设计</title>
    <link href="/2020/09/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2020-09-15-%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/09/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2020-09-15-%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于涉及公司项目，本篇文章只介绍设计没有代码，如果按照这个思路实现的话，代码不会超过100行，请各位看官自行实现-. -</p></blockquote><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>最近在开发的过程中发现一个痛点，花费了一些时间来解决。以本文记录一下思考和解决问题的过程。</p><h4 id="二、痛点与思考"><a href="#二、痛点与思考" class="headerlink" title="二、痛点与思考"></a>二、痛点与思考</h4><p>规模大一些的公司，由于部门众多，员工编码安全意识薄弱，可能会出现内部系统信息泄露，操作权限混乱等安全问题。现在普遍的做法是安全团队提供多种检测手段、各业务自行配置ACL等、部分业务禁止对公网访问等来规避风险。</p><p>但这样可能衍生一个问题: 本地dev服务器可能会有一些接口无法访问，以至于不能在本地完全模拟线上环境。举个例子，如果本地获取用户身份信息接口不通的话，有些权限配置的开发就不好调试。这对我们的开发是及其不友好的。</p><p>所以<strong>如果能做一个工具让我们在调试的时候可以直接调用线上所有接口，但是静态文件又都是本地的，那当真是极好的。</strong></p><h4 id="三、设计"><a href="#三、设计" class="headerlink" title="三、设计"></a>三、设计</h4><p>如何做到这一点呢？很简单，我们做一个代理服务器做数据分发就可以了，地址如果为静态资源就分发到本地dev server，如果是api接口就调用远程接口，这样的话api权限什么的都不用处理，因为网站的host就是线上的。请看图:</p><p><img src="/images/local-static-remote-api-proxy/system-design.png" alt="系统结构图"></p><p>整体来说就是加两个代理服务器，一个代理做隧道，另一个https代理进行请求的分发。<br>下面分步解读下:</p><p>① 本机浏览器通过switchyOmega这个chrome插件将所有需要代理的域名请求映射到http代理服务器上</p><p>② http代理服务器接到请求后通过隧道代理技术将所有请求流入到https代理服务器中，隧道代理的原理请看<a href="https://imququ.com/post/web-proxy.html">这篇文章</a></p><p>③ https代理服务器接到请求后解析url和host，将接口请求分发到线上环境，将其他请求分发到本地Dev server中，这个https服务器使用的方式就是<a href="https://imququ.com/post/web-proxy.html">前面那篇文章</a>中的普通代理模式</p><p>④ https代理服务器将请求的返回内容返回到http代理</p><p>⑤ http代理只是个隧道，会将内容传回浏览器，完</p><p>了解了基本原理之后使用任何后台语言都可以开发，我是使用的nodejs，全部代码80多行，相信你如果看懂了过程也可以自己开发出来。</p><p>开发完成后使用的过程为:<br>开启switchyOmega(第一次用得配置)-&gt;开启我们的两个代理服务器-&gt;访问线上网址<br>也可以关闭switchyOmega直接切换到本机的开发环境</p><p>由于vue是通过长连接来实现热刷新的，所以通过这种代理的方法也可以达到本地更改后自动刷新网页看效果，很方便。</p><h4 id="四、注意的点"><a href="#四、注意的点" class="headerlink" title="四、注意的点"></a>四、注意的点</h4><p>整个过程需要注意的是由于https代理使用https协议，所以需要配置相应的证书，并且需要让本机信任对应的CA证书。有关https协议的基础知识看<a href="https://zhuanlan.zhihu.com/p/57142784">这篇文章</a>，关于如何用openssl签发证书与本篇文章关联不大，会单写篇文章说明。</p><p>另外使用了这种方法后由于接口是线上数据，可不要轻易的做增删改的操作。</p><h4 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h4><p>主要思路已经写得比较清晰了，其实这个工具在公司里还是非常常用的，当初做调研的时候发现网上的文章良莠不齐，比较杂乱，经过几天的思考和学习把这个东西设计并实现出来。希望这篇文章能给大家讲明白。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
      <tag>nodejs</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-04-10-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-04-10-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>在面试的角度来说，一般字符串操作、数组链表和树&#x2F;图的遍历这些方面的题目会居多，所以本篇文章旨在总结常见的(简单的)有关图的算法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图的遍历与树的遍历不同，我们面临着两大难点：一是有的点可能到达不了，二是有可能会出现闭合回路，所以我们需要在每个位置设置一个标记位，路过的时候标记，下次再经过这里的时候直接结束搜索，从新的未标记顶点重新开始搜索。</p><p>对于图遍历来说，我们通常有两种方法：DFS(深度优先遍历)和 BFS(广度优先遍历)，下面逐一总结。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>先来看下代码模板(伪代码，重在理解意思)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">queue.<span class="hljs-title function_">push</span>(originPos);<br><span class="hljs-keyword">while</span> (!queue.<span class="hljs-title function_">empty</span>()) &#123;<br>  cur = queue.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-keyword">for</span> (pos <span class="hljs-keyword">of</span> <span class="hljs-title function_">possibleNextPos</span>(cur)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(pos) &amp;&amp; <span class="hljs-title function_">notVisited</span>(pos)) queue.<span class="hljs-title function_">push</span>(pos); <span class="hljs-comment">// 这里要注意不要重复添加</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总体而言就是利用队列的先进先出形成广度优先遍历，在<a href="http://leetcode-cn.com/submissions/detail/61540628">这里</a>可以看具体例子。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先遍历，一条路走到黑，如果走不通了，返回上一步走另外的路。看伪代码模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">dfs</span> = (<span class="hljs-params">x, y</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(x, y)) <span class="hljs-title function_">addToList</span>();<br>  <span class="hljs-comment">// 这里判断这个位置是否符合条件</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">for</span> (path <span class="hljs-keyword">of</span> <span class="hljs-title function_">getValidPath</span>(x, y)) &#123;<br>    <span class="hljs-comment">// 可能的下个路径</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValidPath</span>(path)) <span class="hljs-title function_">dfs</span>(path); <span class="hljs-comment">// 这里的判断条件可以进行剪枝，把已经过的路径记录下来，以监视递归的次数，提高效率</span><br>  &#125;<br>&#125;;<br><span class="hljs-title function_">dfs</span>(originPath);<br></code></pre></td></tr></table></figure><p>可以看到深度优先主要利用递归来实现一个路径回溯的效果，在<a href="http://leetcode-cn.com/submissions/detail/61558821">这里</a>可以看具体例子。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法[下]</title>
    <link href="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-12-sort-part-two/"/>
    <url>/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-12-sort-part-two/</url>
    
    <content type="html"><![CDATA[<p>上篇文章讲述了几种初级排序算法的思想和实现方法，这篇文章我们深入一些，讲一讲归并、快速和堆这三种排序，直接进入正题。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>顾名思义归并排序的核心操作就是“归并操作”:把两个有序数组合并成一个更大的有序数组。原理是这样的：两个数组 A，B 并排放好，都从第一个数开始看，假如 A 的第一个数比较小，就把他拿出来放到新数组的第一个，然后 A 取第二个数和 B 比，反之亦然。</p><p>我们从 A，B 都只有一个数据开始归并，慢慢的把所有数据归并成一个大的有序数列。思路理清了，来看代码:</p><p>先看一步归并的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tempArr = []; <span class="hljs-comment">// 写成全局的可以节省空间</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">arr, lo, mid, hi</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = lo; m &lt;= hi; ++m) &#123;<br>    <span class="hljs-comment">// arr[lo,...hi]=&gt;tempArr[lo, ...hi]</span><br>    tempArr[m] = arr[m];<br>  &#125;<br>  <span class="hljs-keyword">let</span> i = lo;<br>  <span class="hljs-keyword">let</span> j = mid + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = lo; n &lt;= hi; ++n) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; mid) arr[n] = tempArr[j++];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; hi) arr[n] = tempArr[i++];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempArr[i] &lt;= tempArr[j]) arr[n] = tempArr[i++];<br>    <span class="hljs-keyword">else</span> arr[n] = tempArr[j++];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以将数组的前后两部分进行归并，可以看到代码中现将数组复制出来，然后再按顺序放入原数组中，这么做可以降低算法的空间复杂度。</p><p>一步归并不能将整个数组排序，我们要做的是现将子数组一一归并，然后慢慢扩大直到整个数组，这种思想叫做<code>分治法</code>，分而治之，先将数组分开，然后把小数组一步步归并成大数组，典型的实现是通过递归。先看代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr, start, end</span>) &#123;<br>  <span class="hljs-keyword">if</span> (end &lt;= start) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> mid = start + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end - start) / <span class="hljs-number">2</span>);<br>  <span class="hljs-title function_">mergeSort</span>(arr, start, mid);<br>  <span class="hljs-title function_">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, end);<br>  <span class="hljs-title function_">merge</span>(arr, start, mid, end);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是自顶向下的，但是我们知道递归往往存在性能问题，所以还有一种自下向上的归并方式，就是用循环来做归并，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iTermergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> N = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> size = <span class="hljs-number">1</span>; size &lt; N; size *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 一个子数组长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>; start &lt; N - size; start += size + size) &#123;<br>      <span class="hljs-comment">// [1,2]、[3，4]...</span><br>      <span class="hljs-title function_">merge</span>(<br>        arr,<br>        start,<br>        start + size - <span class="hljs-number">1</span>,<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(N - <span class="hljs-number">1</span>, start + <span class="hljs-number">2</span> * size - <span class="hljs-number">1</span>)<br>      );<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用迭代的方法比较直接，没有递归那么绕，调整子数组大小，计算出起始与结束还有中间分界的位置就可以了。</p><p>下面总结一下归并排序的效率，由于我们用了分治法，归并排序的效率降到了<code>O(NlogN)</code>，比之前的算法都提高了，但美中不足的是他的空间复杂度是<code>O(N)</code>，在我们的实现中归并排序是稳定的，因为当两个数相等时我们取得是前面的数。</p><p>总体来说归并排序除了空间复杂度不是最优的之外性能已经算很好了，而且最重要的是它用了一种分治法的思想，这种思考方式在别的算法中也经常用到。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>终于到了快速排序出场的时候了，快排由于编写简单，性能非常高，常用于各种情境之下，让我们一起来看看这个传奇算法。</p><p>快排的思想也是分治法：首先选中一个中间数，将比它小的数字放到其左边，比他大的放到其右边，这是一次处理。然后分别对左右两侧的数列进行相同的处理，处理到最后整个数组就有序了。下面来看代码，我们先写整体的分治逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr, lo, hi</span>) &#123;<br>  <span class="hljs-keyword">if</span> (hi &lt;= lo) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> splitIdx = <span class="hljs-title function_">group</span>(arr, lo, hi);<br>  <span class="hljs-title function_">quickSort</span>(arr, lo, splitIdx);<br>  <span class="hljs-title function_">quickSort</span>(arr, splitIdx + <span class="hljs-number">1</span>, hi);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于数组两个位置的交换操作很多，我们封装下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, idx1, idx2</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = arr[idx1];<br>  arr[idx1] = arr[idx2];<br>  arr[idx2] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是每次分组逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">group</span>(<span class="hljs-params">arr, lo, hi</span>) &#123;<br>  <span class="hljs-keyword">let</span> i = lo;<br>  <span class="hljs-keyword">let</span> j = hi + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> splitVal = arr[lo]; <span class="hljs-comment">// 取第一个数当中间数</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr[++i] &lt;= splitVal) <span class="hljs-keyword">if</span> (i === hi) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">while</span> (arr[--j] &gt;= splitVal) <span class="hljs-keyword">if</span> (j == lo) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">swap</span>(arr, i, j);<br>  &#125;<br>  <span class="hljs-title function_">swap</span>(arr, lo, j);<br>  <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速排序的时间复杂度是<code>O(NlogN)</code>，空间复杂度是<code>O(logN)</code>，不过当数组基本倒序的时候每一次移动指针都要交换，相当于变相的冒泡排序了，这时时间复杂度为<code>O(N^2)</code>，所以我们要通过方法防止快排退化成冒泡，我打算有时间再出一篇新文章深入探讨下这个问题。</p><p>综合来看，快速排序及其变型性能很不错，可以大量用于各种情境下，jdk 封装的排序就是用的 DualPivotQuicksort，就是快排的一个变体。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>在了解堆排序之前，我们先想像这么一个业务场景：</p><blockquote><p>有个任务队列，需要做的操作有两个：加入任务和取出到最高优先级的任务。</p></blockquote><p>这个场景在工作中非常常见，我们称之为优先队列，思考下如何设计算法。我们可能会这么做：在插入的时按顺序插入，取出的时候按照选择排序的思想遍历取最大。或者在插入的时候就按大小插入，取出的时候按顺序取，这是插入排序的思想。两种方式的复杂度如下：</p><table><thead><tr><th>算法</th><th>插入复杂度</th><th>取出复杂度</th></tr></thead><tbody><tr><td>插入排序思想</td><td>O(N)</td><td>O(1)</td></tr><tr><td>选择排序思想</td><td>O(1)</td><td>O(N)</td></tr></tbody></table><p>这两种方式都可行，但是有一步都是<code>O(N)</code>级别的，在 N 很大的时候效率不高。有人就提出了一种新的思想，运用堆这种数据结构来完成这个过程，以提高效率。</p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种数据结构，通常情况下我们说的是二叉堆，它满足一下特点：</p><ol><li>它是一棵<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a></li><li>任意父节点的值大于或小于子节点(大顶堆和小顶堆)</li></ol><p><img src="/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%88%9D%E5%A7%8B.png" alt="大顶堆"></p><p>这就是一个典型的大顶堆，我们在代码中为了节省空间，通常用一个数组来表示它，为了方便计算，我们把下标为 0 的位置空出来，如果一个节点的下标是 m，那么他的父节点就是<code>m/2</code>，子节点就是<code>2k</code>和<code>2k+1</code>，这样就可以很好地模拟堆的各种操作。</p><p>我们来看看这个时候插入和取出的效率如何。当我们取最大数的时候，我们可以直接取走根节点 9，然后将末节点 4 放到根节点的位置，之后只要调整 4 到合适的位置就行了，这个调整操作我们可以称之为下沉，交换之后如下图：</p><p><img src="/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8B%E6%B2%89.png" alt="大顶堆堆下沉"></p><p>下沉的逻辑是：将要调整的节点和两个子节点比较，取出一个最大的交换，如果父节点本身最大就停下，如果不是就交换到相应子节点位置，然后继续以这个位置为父节点调整。如图：</p><p><img src="/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8B%E6%B2%89%E8%B0%83%E6%95%B4.png" alt="大顶堆下沉调整"></p><p>其中标红的是下沉的路径，我们来实现一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sink</span>(<span class="hljs-params">arr, i, N</span>) &#123;<br>  <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= N) &#123;<br>    <span class="hljs-comment">// 非叶节点</span><br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span> * i;<br>    <span class="hljs-keyword">if</span> (j &lt; N &amp;&amp; arr[j + <span class="hljs-number">1</span>] &gt; arr[j]) j += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 父节点最大时停止下沉</span><br>    <span class="hljs-title function_">swap</span>(arr, i, j);<br>    i = j;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以算出来下沉一个节点所需的时间复杂度最大为<code>O(logN)</code>(沉到底)，当 N 很大的时候速度快了非常多。</p><p>再看插入的效率如何，插入时直接把数据放到末尾，然后将节点上浮到合适的位置。与下沉的道理差不多。</p><p><img src="/images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8A%E6%B5%AE%E8%B0%83%E6%95%B4.png" alt="大顶堆上浮调整"></p><p>比如我们新加入一个数字 9，红色路径就是调整路径，原理比较简单，直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">swim</span>(<span class="hljs-params">arr, i</span>) &#123;<br>  <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; arr[i] &gt; arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>)]) &#123;<br>    <span class="hljs-title function_">swap</span>(arr, i, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>));<br>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i / <span class="hljs-number">2</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑比下潜还简单，因为子节点之间不用比较，我们掐指一算发现最大时间复杂度还是<code>O(logN)</code>，可见在优先队列中，如果 N 比较大，使用堆的方式构建优势很大。</p><h3 id="优先队列和堆排序"><a href="#优先队列和堆排序" class="headerlink" title="优先队列和堆排序"></a>优先队列和堆排序</h3><p>说到这我们已经把堆讲明白了，下面我们把它用到排序上，聪明的同学可能已经想到如何写了：</p><ol><li>把数组构建成一个堆(我们假设从小到大排，构建大顶堆)。</li><li>取出第一个数与最后一个交换，最大的数就被安排到最后一个了。</li><li>下沉第一个数(最后一个数不参与，因为它已经有序了)。</li><li>重复 2，3 步骤直到所有数都有序。</li></ol><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> N = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(N / <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-comment">// 构建堆</span><br>    <span class="hljs-title function_">sink</span>(arr, i, N);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 不断弹出第一个</span><br>    <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">1</span>, N--);<br>    <span class="hljs-title function_">sink</span>(arr, <span class="hljs-number">1</span>, N);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>取所有数的过程复杂度为<code>O(NlogN)</code>，构建堆的过程可以从后往前对每个数依次做上浮，这其实也是一种分治的思想(分治思想无处不在)，先将子树变为堆，然后将多个子树放在一起变为新堆，构建堆需要的操作数计算起来比较复杂 😓，这里直接给出结论吧，是<code>O(N)</code>。所以加起来还是<code>O(NlogN)</code>的复杂度。</p><p>堆排序的的算法写起来非常简单，性能也很高，空间复杂度为<code>O(1)</code>，除了不稳定之外没什么明显缺点，简直是宝藏算法。堆的用法很多，不仅仅可以用于排序，而且我写的基础班堆排序也有可以优化的地方，我打算日后和快速排序一起写一篇新文章。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实还有一些排序，比如桶排序，基数排序等，这里先不做研究了，最后的最后给出各个算法的性能分析表吧：</p><table><thead><tr><th>算法</th><th>稳定性</th><th>是否原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>√</td><td>√</td><td>N^2</td><td>1</td><td></td></tr><tr><td>选择排序</td><td>×</td><td>√</td><td>N^2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>√</td><td>N ~ N^2</td><td>1</td><td>基本有序时效率高</td></tr><tr><td>希尔排序</td><td>×</td><td>√</td><td>N ~ N^2</td><td>1</td><td></td></tr><tr><td>快速排序</td><td>×</td><td>√</td><td>NlogN</td><td>lgN</td><td>三项切分时效率接近线性</td></tr><tr><td>归并排序</td><td>√</td><td>×</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>√</td><td>NlogN</td><td>1</td><td>取前几个最大的数时用堆的思想</td></tr></tbody></table><p>That’s all.</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法[上]</title>
    <link href="/2020/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-11-sort-part-one/"/>
    <url>/2020/02/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020-02-11-sort-part-one/</url>
    
    <content type="html"><![CDATA[<p>这篇文章是算法系列的第一篇，为什么写这么个系列呢，主要因为我一直对算法这个东西很好奇，非常想学，只有总结才能让我更好的系统学习，不然就是狗熊掰棒子 🙃，而且顺便能给其他同学一点点儿启发也是非常开心的一件事儿。我所有的文章都会以一种讲述的口吻来写，讲给大家听也讲给自己听。好了废话不多说，下面直接进入主题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>排序算法这个东西相信很多同学从很早就开始接触了，最开始是冒泡排序(万年入门排序)，之后再深入一些我们会了解到更多: 选择、插入、希尔、归并、快排、堆排等等，我们一一道来(假设所有的排序都是从小到大)。</p><h2 id="如何判断一个算法好坏"><a href="#如何判断一个算法好坏" class="headerlink" title="如何判断一个算法好坏"></a>如何判断一个算法好坏</h2><p>稍微了解下我们就会发现排序算法多种多样，那么我们怎么判断他们的好坏呢？几个概念应运而生:</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>快慢是衡量一个算法最最直观的方法了，我们可以直接在运行程序前后计时，得出程序的运行时间进行比较，但是有的时候我们手头没有计算机来运行程序，我们就需要一些理论知识来判断程序好坏，时间复杂度就是衡量程序快慢的一个指标，通常是人脑可以推算出来的。</p><p>当输入为 N 时，我们可以大概估出一个时间量级，我们称之为<code>O(..)</code>，当我们考虑时间复杂度的时候，通常会忽略倍数，因为在 N 比较大的时候倍数并不会影响结果，比如<code>O(N^2)</code>和<code>O(3N^2)</code>，当 N 为 100 时，常数 3 对结果影响已经没不大了，更不用说样本更大的时候了。</p><p>常见的复杂度有<code>O(1)</code>,<code>O(N)</code>,<code>O(N^2)</code>,<code>O(N^logN)</code>(出现 log 是因为二分处理情况)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>占用空间大小是另一个衡量因素，这个复杂度的意思是在样本量级为 N 的时候，程序会占用多少内存，这个指标太高也是不行的。空间复杂度也用<code>O(..)</code>表示，比如我们在算法中声明了个长度为 N 的数组来进行中间的数据处理，这时算法的空间复杂度就是<code>O(N)</code>。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>上面两个复杂度对算法都是通用的，对于排序来说还有稳定性这个指标，他是指当我们排完序之后值相同的项顺序还是否都是原来的顺序，如果是的话算法就是稳定的，否则就是不稳定。</p><p>有些时候我们在排序的过程中不想让相同值的项再改变顺序，比如：</p><blockquote><p>一个队列每一项有两个属性 A，B，我们希望整体以 A 属性的大小进行排序，但当 A 相同时我们以 B 的大小来进行排序。</p></blockquote><p>如果我们的排序算法是稳定的，那么我们可以以 B 属性大小进行排列，然后再以 A 属性大小排序。两次排序达到要求。但是如果我们的算法是不稳定的，在第二次排序的时候可能会破坏第一次的结果。</p><p>综上我们也要考虑到排序算法的稳定性。</p><h2 id="排序算法实现"><a href="#排序算法实现" class="headerlink" title="排序算法实现"></a>排序算法实现</h2><p>排序算法里选择排序、冒泡排序、插入排序、希尔排序都属于初级排序算法，相对来说效率不高，真正常用的是快排、归并排序、堆排和他们的一些变型。非常推荐在阅读文章时看看<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法的动画演示</a>，除了堆排序之外都有，堆排序在<a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">这里</a>。阅读的时候边看动画演示边看下面的代码可以让你更好的理解。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>我们从最基本的冒泡排序开始，我们这么做：1-2 比出个较大的，把较大的放到第 2 个，然后 2-3 比，较大的放在第 3 个…以此类推，遍历一轮之后我们可以获得整个数组最大的值，且时候最大的值已经被换到最后一个了。这时第一轮结束，从头遍历开始第二轮。</p><p>这种方式我们可以把它联想为一个个气泡从水底冒到水面的过程，所以称之为冒泡排序，代码实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mock = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arr.<span class="hljs-property">length</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 交换</span><br>        <span class="hljs-keyword">let</span> temp = arr[j];<br>        arr[j] = arr[j + <span class="hljs-number">1</span>];<br>        arr[j + <span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`排序后结果: <span class="hljs-subst">$&#123;bubbleSort(mock)&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>我们从上面的三个维度分析一下，我们遍历了 N 遍数组，数组中有 N 个元素，所以时间复杂度就是<code>O(N^2)</code>。(其实从第二遍起就是 N-1 了，后面越来越少，但是这种细小的次数可以忽略不计，计做 N 次)。空间复杂度上由于我们交换元素时需要有个临时变量，所以是<code>O(1)</code>。最后从稳定性上讲，如果是我上面的实现来看是稳定的，因为当两数相同时并不进行交换，如果比较的时候用<code>&gt;=</code>算法就是不稳定的了。</p><p>可见冒泡虽然实现起来简单，但是效率确实不高。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序思想比冒泡还简单：遍历数组，选择一个最小的，换到第一个位置，遍历第二遍时从第二个开始选出剩下的里面最小的，换到第二个位置…以此类推。思想比较简单，直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> minIdx;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; ++i) &#123;<br>    minIdx = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;<br>    &#125;<br>    <span class="hljs-comment">// 交换i 和 minIdx 的数据</span><br>    <span class="hljs-keyword">let</span> temp = arr[i];<br>    arr[i] = arr[minIdx];<br>    arr[minIdx] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>显而易见，时间复杂度还是<code>O(N^2)</code>，空间复杂度也是<code>O(1)</code>，另外选择排序是不稳定的，举个例子:<code>[3,2,3,1,5]</code>，在第一遍的时候第一个 3 和 1 交换，已经破坏了排序的稳定性。</p><p>选择排序符合一般人的第一想法，但是奈何效率不高还不稳定。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>当我们斗地主抽牌的时候，我们往往一张一张抽，把抽到的牌插到已有手牌的合适位置，这就是插入排序的思想。下面我们来实现一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> target = <span class="hljs-number">0</span>,<br>    nextIdx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; ++i) &#123;<br>    target = arr[i];<br>    nextIdx = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (nextIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[nextIdx] &gt; target) &#123;<br>      arr[nextIdx + <span class="hljs-number">1</span>] = arr[nextIdx];<br>      --nextIdx;<br>    &#125;<br>    arr[nextIdx + <span class="hljs-number">1</span>] = target;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序的时间复杂度也是<code>O(n^2)</code>，空间复杂度也是<code>O(1)</code>，它是一种稳定的排序。看起来和前面的两种一样低效，不过它在特定情况下比前面两种情况快得多，试想下如果数组中绝大部分的数字都已经排好序，时间复杂度会是如何？这是我们发现在向前寻找位置的时候几乎不用遍历，这时候的复杂度趋近<code>O(N)</code>，非常高效。</p><p>总体来说插入排序虽在一般情况下效率不高(但也强于前两种)，但是在特殊情况下还是可以派上用场的。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>人们发现插入排序在数据基本排好序的时候效率极高，那么有人就说了我们能不能大概先给数据排个序，然后再用插入排序？希尔排序就这么产生了。</p><p>由于插入排序只能相邻的元素移动，所以如果有个元素要从数组结尾移动到数组开头就很耗费时间，希尔排序提出一个概念：如果数组中任意间隔为 h 的数据都是有序的，则称这个数组为<code>h有序数组</code>，当 h 为 1 的时候，数组就排好序了。这样在 h 很大的时候，即使要移动距离很远也可以很快的移动过去，我们多排几遍，让 h 慢慢变小最终变为 1，每次排序都用插入排序，数组越来越有序，排序的性能也越来越高，下面看看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shellSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> h = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (h &lt; arr.<span class="hljs-property">length</span> / <span class="hljs-number">3</span>) h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">let</span> target = <span class="hljs-number">0</span>,<br>      nextIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = h; i &lt; arr.<span class="hljs-property">length</span>; i += h) &#123;<br>      target = arr[i];<br>      nextIdx = i - h;<br>      <span class="hljs-keyword">while</span> (nextIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[nextIdx] &gt; target) &#123;<br>        arr[nextIdx + h] = arr[nextIdx];<br>        nextIdx -= h;<br>      &#125;<br>      arr[nextIdx + h] = target;<br>    &#125;<br>    h = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(h / <span class="hljs-number">3</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显能看出来，希尔排序的写法是基于插入排序的，我这里 h 的设置方法是比较常用的。希尔排序是个很神奇的排序，因为他仅仅比插入排序多加了个<code>h有序数组</code>的概念，性能就可以达到插入排序的很多倍。至今专家们也没找到一个 h 数列使性能最大化，但是无论如何都是比插入排序快很多的，小于<code>O(N^2)</code>，空间复杂度上来讲还是<code>O(1)</code>，唯一比插入排序差的就是它不稳定。</p><p>总结一下，希尔排序在插入排序的基础上大大优化了性能，虽然比不上快排、堆排等算法，但胜在编写简单，性能可接受。(虽然还是用不上)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是冒泡、选择、插入、希尔的基本思想和简单实现，这几种排序都被称为初级排序算法，效率并不高，在<code>排序算法[下]</code>中我们将深入了解几种高级算法，敬请期待…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next.js</title>
    <link href="/2020/02/10/2020-02-10-Nextjs/"/>
    <url>/2020/02/10/2020-02-10-Nextjs/</url>
    
    <content type="html"><![CDATA[<p>本篇文章是笔者在实践了官方 tutorial 之后总结出的一些要点，目的在于节省以后复习的时间，如果能帮到大家就最好不过了。</p><h2 id="一、主要优势"><a href="#一、主要优势" class="headerlink" title="一、主要优势"></a>一、主要优势</h2><ol><li>Sever rendering</li><li>Static site 建立极其简单</li><li>CSS-in-JS</li><li>Zero Setup</li><li>Complete over Babel and Webpack</li><li>Smaller build size, faster compilation</li></ol><h2 id="二、实践出真知"><a href="#二、实践出真知" class="headerlink" title="二、实践出真知"></a>二、实践出真知</h2><h3 id="1-Router"><a href="#1-Router" class="headerlink" title="1. Router"></a>1. Router</h3><p>在 page 文件夹中新建一个组件，使用<code>&lt;Link href=&#39;...&#39;&gt;</code>进行页面内跳转，这种跳转是 Client 端的，不对服务器做请求。<code>Link</code>这个组件已经封装好了 location.history 的逻辑，不用自己再写。</p><blockquote><p><code>Link</code>只是用做跳转的一个子组件，在上面加属性是没用的。</p></blockquote><p>router 可以通过 Hook <code>useRouter</code>取得，有一些 api 可用，如简单的有<code>router.query</code>可以取得 query 参数。</p><p>通过<code>[]</code>符号可以在 pages 文件夹中声明动态 url 组件，比如属性为 id 时在跳转的时候写法类似:<code>/xx/[id]</code>，pages 中的文件名就起为<code>[id].js</code>，在页面组件中可通过<code>router.query.id</code>获取。动态表示<code>href</code>的时候可以用<code>as</code>属性来决定 url 中显示的内容。</p><h3 id="2-组件化"><a href="#2-组件化" class="headerlink" title="2. 组件化"></a>2. 组件化</h3><p>组件化和 react 大同小异，传参嵌套，HOC，没有过多可说的。</p><h3 id="3-数据通讯"><a href="#3-数据通讯" class="headerlink" title="3. 数据通讯"></a>3. 数据通讯</h3><p>next 为我们封装了个函数来获取远端数据-<code>getInitialProps</code>，这个函数接受一个参数 context，通过<code>context.query</code>可以获得 url 参数。</p><blockquote><p><code>getInitialProps</code>这个函数只可用于 page 组件中。</p></blockquote><p>由于直接访问页面时是服务器端渲染的，使用<code>console.log</code>打印出的内容也是在服务器端，但是如果是点击<code>Link</code>标签跳转到的页面进行<code>console.log</code>，由于之前也提到过<code>Link</code>跳转实在 Client 端进行的，不请求服务器，所以输出就是在浏览器的终端里，一定要注意。</p><h3 id="4-UI-样式"><a href="#4-UI-样式" class="headerlink" title="4. UI 样式"></a>4. UI 样式</h3><p>next 不同于大多数框架，采用 css-in-js 的方式，在 jsx 中直接添加标签如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style jsx&gt;&#123;<span class="hljs-string">`</span><br><span class="hljs-string">  a &#123; ... &#125;</span><br><span class="hljs-string">`</span>&#125;&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>一定不要忘了<code>&#123;``&#125;</code>。</p><p>另外这种形式的 style 是局部的，也就是于自身存在的 jsx 中有效，对子组件中的内容都无效。如果要全局作用，在 css 中使用伪类<code>:global(..)</code>即可。或者使用<code>&lt;style jsx global&gt;</code>也可以。</p><blockquote><p>官方不建议使用全局样式。</p></blockquote><h3 id="5-API-Routes"><a href="#5-API-Routes" class="headerlink" title="5. API Routes"></a>5. API Routes</h3><p>nextjs 提供一种 serveless 的方式来构建 api。</p><p>只需在<code>/pages/api</code>文件夹下创建 js 文件，默认会变为 api 接口，文件名就是接口名，文件内容类似:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> quotes <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../quotes.json&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> quote = quotes[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * quotes.<span class="hljs-property">length</span>)];<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(quote);<br>&#125;;<br></code></pre></td></tr></table></figure><p>传入的 req 可以用来获取请求信息，比如可以通过<code>req.query</code>获取 url 中的 query 参数。</p><blockquote><p>swr 是一种异步获取数据的<code>React Hook</code>，<code>useSWR(&#39;/api/..&#39;, fetcher)</code>，fetcher 传入 url，返回数据。</p></blockquote><h3 id="6-部署"><a href="#6-部署" class="headerlink" title="6. 部署"></a>6. 部署</h3><p>如果需要单独部署 nextjs 项目，也可以直接使用<code>next build</code>和<code>next start</code>命令进行本地部署，start 的时候可以添加 p 参数，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># package.json中</span><br><span class="hljs-string">&quot;script&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;next&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;next build&quot;</span>,<br>  <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;next start -p <span class="hljs-variable">$PORT</span>&quot;</span><br>  <span class="hljs-comment"># windows 写做next start -p %PORT%</span><br>&#125;<br><br><span class="hljs-comment"># 在运行的时候</span><br>PORT=2333 npm start<br><span class="hljs-comment"># windows 写做 cross-env PORT=2333 npm start</span><br></code></pre></td></tr></table></figure><p>通过官方提供的<code>Zeit now</code>(创办 Zeit 的是个神人，同时也是 Next 的作者，有兴趣可以去了解下)。Now 这个平台的本质是个专门进行部署的网站，还有一些可以帮你快速建站，非常牛逼。</p><p>通过在项目下简单的<code>now</code>命令就可以在 Now 平台上进行部署了(可以获得一个网站的 url 供人访问)。</p><blockquote><p>在使用命令之前，需要在<a href="https://zeit.co/">now 官网</a>中进行注册，然后在命令行中初次使用时需要通过<code>now login</code>进行登录(会给你发个 confirm 邮件，确认时需要翻墙)。</p></blockquote><h3 id="7-支持静态页面导出"><a href="#7-支持静态页面导出" class="headerlink" title="7. 支持静态页面导出"></a>7. 支持静态页面导出</h3><p>通过命令<code>next export</code>可以进行静态页面导出(在 build 之后)，但需要进行一些配置。</p><p>在根目录下创建 next.config.js 配置文件 内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>  <span class="hljs-attr">exportTrailingSlash</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">exportPathMap</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;...&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>如果只是更改了配置文件里的内容，则不用重新 build</p></blockquote><p>其中比较重要的是<code>exportPathMap</code>这个属性，他是一个函数，返回值是 url map，如果一个 url 没有在这个函数返回，那么我们不能在地址栏里手动输入路径以访问此页面(跳转过去是可以的)。</p><p>那么我们可以动态的在<code>exportPathMap</code>中返回路径，这个方法可以是异步的，这意味着我们可以在这个方法里通过调用 api 获取路径并添加到返回值里(添加的路径在输出文件夹中会单独形成一个文件)。</p><h3 id="8-typescript-完美支持"><a href="#8-typescript-完美支持" class="headerlink" title="8. typescript 完美支持"></a>8. typescript 完美支持</h3><p>只需要添加简单的一句<code>cnpm install --save-dev typescript @types/react @types/node</code>，nextjs 完美支持 typescript，超简单。</p><h3 id="9-支持-AMP-没什么好说的"><a href="#9-支持-AMP-没什么好说的" class="headerlink" title="9. 支持 AMP(没什么好说的)"></a>9. 支持 AMP(没什么好说的)</h3><h3 id="10-支持懒加载模块"><a href="#10-支持懒加载模块" class="headerlink" title="10. 支持懒加载模块"></a>10. 支持懒加载模块</h3><p>通过<code>await import(&#39;..&#39;)</code>这种语法可以让程序在第一次执行到这里的时候再加载，大大提高首屏效率。</p><h3 id="三、-总结"><a href="#三、-总结" class="headerlink" title="三、 总结"></a>三、 总结</h3><p>nextjs 提供了很多便捷的一键式的操作，更有 now 平台的各种模板便于用户快速建立并部署自己的网站，而且还提供了 ssr，懒加载等技术进行效率的提高。着实是一个非常出色的框架，笔者过两天会使用此框架重构作品集网站，到时再对此框架做更深入的测评。</p>]]></content>
    
    
    <categories>
      
      <category>javascript框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>nextjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表驱动法</title>
    <link href="/2020/02/09/Code%20Complete/2020-02-09-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/"/>
    <url>/2020/02/09/Code%20Complete/2020-02-09-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在阅读Code Complete，非常有实践性的一本书，通过这本书记录下对第18章表驱动法的一些个人理解和感悟，在构建自己知识体系的基础上产出一些东西，以便于和其他人交流学习。如有不正确的地方，欢迎斧正。</p></blockquote><h2 id="一、何谓表驱动法"><a href="#一、何谓表驱动法" class="headerlink" title="一、何谓表驱动法"></a>一、何谓表驱动法</h2><p>表驱动法实际是一种思想，目标是把复杂的if&#x2F;else程序逻辑语句转换成易维护，高可读的程序。这是一种基本思想，最好能熟练运用，做到如臂使指。</p><h2 id="二、表驱动法的常见分类"><a href="#二、表驱动法的常见分类" class="headerlink" title="二、表驱动法的常见分类"></a>二、表驱动法的常见分类</h2><p>表驱动法的核心是维护一个键值对列表(<strong>y&#x3D;f(x)</strong>)，所以分类也是根据这个列表的形态来分的。如果在逻辑中出现很多if&#x2F;else的并列和嵌套，我们就可以去找找逻辑上的映射关系来简化程序。</p><h3 id="1-直接访问表"><a href="#1-直接访问表" class="headerlink" title="1.直接访问表"></a>1.直接访问表</h3><h4 id="①单一自变量映射"><a href="#①单一自变量映射" class="headerlink" title="①单一自变量映射"></a>①单一自变量映射</h4><p>直接访问表的特征是:以目标值作为索引来获得对应的结果。这里举个简单的栗子🌰:</p><blockquote><p>如果我们想通过周几来取得当天计划</p></blockquote><p>一般的写法可能是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSchedule</span>(<span class="hljs-params">day</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(day) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Mon&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周一去听经&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Tues&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周二住旅馆&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Thurs&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周三看电影&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然用if&#x2F;else也是一样的写法，如果我们用访问表的思想就是这个样子的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSchedule</span>(<span class="hljs-params">day</span>) &#123;<br>  <span class="hljs-keyword">const</span> schedule = &#123;<br>    <span class="hljs-string">&#x27;Mon&#x27;</span>: <span class="hljs-string">&#x27;周一去听经&#x27;</span>,<br>    <span class="hljs-string">&#x27;Tues&#x27;</span>: <span class="hljs-string">&#x27;周二住旅馆&#x27;</span>,<br>    <span class="hljs-string">&#x27;Thurs&#x27;</span>: <span class="hljs-string">&#x27;周三看电影&#x27;</span>,<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> schedule[day];<br>&#125;<br></code></pre></td></tr></table></figure><p>当索引很多的时候，这个时候用访问表的思想可以明显提高可读性，另外这个表也可以是从文件或者别的地方读取的，因而可以做到热部署。也是这种方式的优势之一，</p><h4 id="②多自变量映射"><a href="#②多自变量映射" class="headerlink" title="②多自变量映射"></a>②多自变量映射</h4><p>那么新问题出现了，我们在实际编程中一定遇到过这种情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">whatever</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span>(A) &#123;<br>    <span class="hljs-keyword">if</span>(B) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种嵌套的自变量让人很头疼，我们不能通过单一的A或者B就得出结果(<strong>u&#x3D;f(x,y,z)</strong>)，那么我们应该如何建立映射关系呢？</p><p>答案是一一列举自变量，通过程序一一保存结果到一个映射表里，最后在用的时候达到如下的效果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getResult</span>(A, B, C);<span class="hljs-comment">// getResult从表里向外取之前存好的值</span><br></code></pre></td></tr></table></figure><p>我个人认为这种方式在很多情况下并不优雅，所以多自变量的时候需要我们酌情使用。</p><h4 id="③自变量的范围映射"><a href="#③自变量的范围映射" class="headerlink" title="③自变量的范围映射"></a>③自变量的范围映射</h4><p>比如说某个数据段内是一个值，如第一个例子中如果是:周一到周三都是一个计划，这时就有两种解决方案。一种是冗余一种是简化。</p><p>我们可以在我们的表里把周一的内容复制到周二周三，这样就达到了目的，不过数据会出现冗余，出错概率也会增大。</p><p>我们也可以建立另一个映射，比如当传入的<code>day</code>是周一到周三的时候，都映射到<code>Mon</code>上，这个新映射可以单独封装在一个<code>keyFromDay()</code>函数中。</p><h3 id="2-索引访问表"><a href="#2-索引访问表" class="headerlink" title="2.索引访问表"></a>2.索引访问表</h3><p>当上面的<code>keyFromDay()</code>没法简单的用公式转化的时候，可以在函数里再进行一次访问表，把常用索引列为一个数组使用，个人感觉实用价值不高。</p><h3 id="3-阶梯访问表"><a href="#3-阶梯访问表" class="headerlink" title="3.阶梯访问表"></a>3.阶梯访问表</h3><p>当出现阶段性的索引时，可以用阶梯访问表的方式，比如:</p><p>通过数字大小决定单位:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 由于是例子 不考虑非数字输入</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addUnit</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">const</span> abs = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(num);<br>  <span class="hljs-keyword">if</span>(abs &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;num&#125;</span>个`</span>;<br>  <span class="hljs-keyword">const</span> units = [<span class="hljs-string">&#x27;个&#x27;</span>,<span class="hljs-string">&#x27;千&#x27;</span>,<span class="hljs-string">&#x27;万&#x27;</span>,<span class="hljs-string">&#x27;亿&#x27;</span>];<br>  <span class="hljs-keyword">const</span> limits = [<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000000</span>];<br>  <span class="hljs-keyword">const</span> maxIdx = units.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> idx = maxIdx-<span class="hljs-number">1</span>; idx &gt;= <span class="hljs-number">0</span>; --idx) &#123;<br>    <span class="hljs-keyword">if</span>(abs &gt;= limits[idx]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;num/limits[idx].toFixed(<span class="hljs-number">1</span>)&#125;</span><span class="hljs-subst">$&#123;units[idx]&#125;</span>`</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比一大堆<code>if/else</code>简明，易于扩展和修改。</p>]]></content>
    
    
    <categories>
      
      <category>code-complete</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Table的固定表头表身滚动写法</title>
    <link href="/2018/11/07/2018-11-07-%E5%9B%BA%E5%AE%9A%E8%A1%A8%E5%A4%B4%E8%A1%A8%E8%BA%AB%E6%BB%9A%E5%8A%A8%E5%86%99%E6%B3%95/"/>
    <url>/2018/11/07/2018-11-07-%E5%9B%BA%E5%AE%9A%E8%A1%A8%E5%A4%B4%E8%A1%A8%E8%BA%AB%E6%BB%9A%E5%8A%A8%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在工作中遇到一个需求，固定表头表身滚动，乍看之下非常简单，但是却耗费了我很长时间来解决。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>如果需要列表滚动，只需要简单的<code>overflow-y:auto/scroll</code>就可以轻松实现。<br>如果需要单纯的表格，只需要用 html 基础语法<code>table</code>就可以轻松实现。</p><p>BUT！当<code>overflow-y:auto/scroll</code>遇到<code>table</code>中的<code>tbody</code>，就会阴阳错乱、五行颠倒，列也对不齐了，宽也不为 100%了。是的，他俩单用没问题，合起来简直有毒。这是由于语言本身特性造成的，看来使用通常的方法是行不通了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>索性经过多方调查，还是有解决方案的，那就是：把两个<code>table</code>嵌套到一起。一个表作为表头，隐藏<code>tbody</code>，另一个作为表身，只显示<code>tobdy</code>，使用<code>position:absolute</code>让他们合体。<br><del>竟然要用这种方式来实现，怎么设计的？</del></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>html 部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;kols-tables&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inner-header-table&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inner-body-table&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        // 中间省略<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css 部分(LESS)：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.kols-tables</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span>; <span class="hljs-comment">// 此处要和inner-header-table中的height相等</span><br>  <span class="hljs-selector-class">.inner-header-table</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.inner-body-table</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">// 填满空间</span><br>    <span class="hljs-attribute">overflow-y</span>: auto;<br>    <span class="hljs-selector-tag">table</span> &#123;<br>      <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">30px</span>; <span class="hljs-comment">// 这里通过负margin的方式控制body于表头的距离</span><br>    &#125;<br>    <span class="hljs-selector-tag">th</span> &#123;<br>      <span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">// 表头隐藏但占位</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>css 部分代码总结起来就是：用<code>flex</code>做内容充满，使用<code>absolute</code>做表头固定，使用<code>margin-top</code>负值做 body 的位置调整，<code>visibility</code>使 body 表头占位不显示。<br>虽然一定有别的方法可以实现同样的效果，但是为了避免反复试错可以把这种模式记为公式，以便今后使用。可喜可贺~ ｄ(･∀･*)♪ ﾟ</p>]]></content>
    
    
    <categories>
      
      <category>web基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用DevicePixelRatio来清晰化canvas</title>
    <link href="/2018/11/07/2018-11-07-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE%E6%9D%A5%E6%B8%85%E6%99%B0%E5%8C%96canvas/"/>
    <url>/2018/11/07/2018-11-07-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE%E6%9D%A5%E6%B8%85%E6%99%B0%E5%8C%96canvas/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在工作中需要用到 canvas 来绘制复杂图表，在绘制的过程中出现了图案模糊的问题。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>经过上网搜索，找到了解决方案，先来解释一下原因。</p><p>显示屏有两个重要参数： 1.像素数，指物理像素。一个像素对应一组发光管，多组发光管组成屏幕，一般市面上的笔记本显示屏多是 1920x1080 像素的。 2.设备像素比(DevicePixelRatio，以下简称 dpr)，也就是多少个像素为一个逻辑像素，比如 dpr 为 2 的显示屏它一个逻辑像素点实际是 4 个物理像素组成的(2x2)，dpr 越高，画质越细腻。我们在编程中使用的皆为逻辑像素。</p><p>由于我使用的是 Retina 屏，dpr 为 2。再来说下 Html5 canvas 渲染的机制： 1.画出来：浏览器用位图模式渲染 canvas 中的内容，即用<code>canvas.width</code>x<code>canvas.height</code>的<strong>物理像素</strong>画图。 2.塞进去：将画出来的图“塞进“画布中，画布的宽高为 css 中定义的<code>width</code>x<code>height</code>。</p><p>这样模糊的原因就明了了：在 Retina 屏(Mac)中，dpr 为 2，如果<code>canvas.width</code>和<code>canvas.height</code>被设为逻辑像素，则在“画出来”的时候图案大小就为预想的<code>1/dpr</code>，这时的“塞进去”就变为放大图案了，所以画面就变得模糊了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>分析之后解决方案就十分明显了。我们只需要将<code>canvas.width</code>和<code>canvas.height</code>按照物理像素来设置(<code>width*ptr,height*ptr</code>)就 ok 了，不过要注意的是画布中内容的半径和粗细等参数也得相应扩大 ptr 倍，不然图案放大之后会比预想的要细。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>为了更加清晰，这里把关键代码展示一下(jsx)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;&#123;200*devicePixelRatio&#125;&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;&#123;200*devicePixelRatio&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br>// 另外注意在画图的时候也要 将相应的图案参数 * devicePixelRatio<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">canvas</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决，可喜可贺，可喜可贺~ (*≧∪≦)</p>]]></content>
    
    
    <categories>
      
      <category>web基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SASS知识点总结</title>
    <link href="/2018/06/08/2018-06-08-SASS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2018/06/08/2018-06-08-SASS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>几条基本的命令:</p><ul><li><code>sass-convert xx.sass xx.scss</code>或<code>sass-convert xx.scss xx.sass</code>:sass 与 scss 格式之间的相互转换</li><li><code>sass xx.scss xx.css</code>:编译 scss 文件成为 css</li><li><code>sass --watch xx.scss:xx.css</code>:编译并监控，当 scss 更改时自动生成 css 文件(可以监控一个文件夹)</li><li><code>sass --style compressed xx.scss:xx.css</code>:使用压缩模式编译，除了<code>!</code>型注释都被删除(<code>!</code>型注释见后文)</li></ul><h2 id="二、sass-扩展特性"><a href="#二、sass-扩展特性" class="headerlink" title="二、sass 扩展特性"></a>二、sass 扩展特性</h2><h3 id="1-嵌套规则"><a href="#1-嵌套规则" class="headerlink" title="1. 嵌套规则"></a>1. 嵌套规则</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#outter</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outter</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-id">#outter</span> <span class="hljs-selector-id">#inner</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优势是可以省去嵌套的重复代码。</p><p>扩展特性：</p><ul><li>可以多层嵌套。</li><li>内部可以用<code>&amp;</code>来代指外层元素，用法为<code>&amp;:hover</code>、<code>&amp;-xx</code>等。**&amp;只能出现在选择器最开始的位置**。</li><li>可以通过<code>:</code>实现 css 属性嵌套用法如下:</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span> fantasy &#123;<br>    <span class="hljs-comment">// 外层元素也可以赋值</span><br>    weight: bold;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span> fantasy;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>分两种:<code>//</code>和<code>/* */</code>。在编译为 css 的时候<code>//</code>会被删除，另一种不会。</p><p>扩展特性:</p><ul><li>如果注释为<code>/* */</code>类型且以<code>!</code>开头，则这部分注释在压缩模式编译的时候仍然会保留这部分的注释，常用语作者信息。</li><li>在注释中可以使用插值语法(使用<code>#&#123;$xx&#125;</code>插入 scss 变量)</li></ul><h3 id="3-SassScript"><a href="#3-SassScript" class="headerlink" title="3. SassScript"></a>3. SassScript</h3><p>SassScript 使 sass 成为一种可编程的语言，大大提高了灵活性。</p><h4 id="3-1-变量声明"><a href="#3-1-变量声明" class="headerlink" title="3.1 变量声明"></a>3.1 变量声明</h4><p>我们可以使用<code>$</code>符号进行变量声明，如<code>$w: 5em</code>,在后续代码中我们就可以使用<code>$w</code>这个变量了，在编译的时候会自动进行替换。</p><p>扩展特性:</p><ul><li>我们可以声明局部变量，即在一个选择器的<code>&#123;&#125;</code>之中声明变量，这样只有在这个<code>&#123;&#125;</code>范围内可以使用这个变量。局部变量后面加上<code>!global</code>标记也可以将变量全局化。</li><li>我们可以在变量声明的时候在后面加上<code>!default</code>，这表示如果变量已经有值且不为<code>null</code>，则本次声明跳过，否则不跳过。</li></ul><h4 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h4><p>同一般的语言一样，SassScript 中也内置了一些数据类型:</p><h5 id="3-2-1-numbers-1-2-13-10px-等"><a href="#3-2-1-numbers-1-2-13-10px-等" class="headerlink" title="3.2.1 numbers (1.2,13,10px 等)"></a>3.2.1 numbers (1.2,13,10px 等)</h5><p>只要 number 的单位一致<code>+ - * / % == != &gt;= &lt;= &gt; &lt;</code>都是可用的。比如<code>10px*10px==100px*1px</code>会得到<code>true</code>，注意乘法的时候单位也会变为平方，就是说<code>10px*10px==100px</code>会得到<code>false</code>。</p><blockquote><p><code>== !=</code>这两个运算符是可以用于所有类型的。</p></blockquote><h6 id="3-2-1-1-x2F-注意事项"><a href="#3-2-1-1-x2F-注意事项" class="headerlink" title="3.2.1.1 &#x2F;注意事项"></a>3.2.1.1 &#x2F;注意事项</h6><p><code>/</code>在三种情况下会进行运算编译:</p><ol><li>运算符之一为方法或 scss 变量</li><li>运算式被括号包裹，且不在数组中。</li><li>算式中存在<code>+</code></li></ol><p>如果你就是想得到<code>10px/20px</code>这种形式，分子分母一起用<code>#&#123;$xx&#125;</code>即可。</p><h6 id="3-2-1-2-注意事项"><a href="#3-2-1-2-注意事项" class="headerlink" title="3.2.1.2 -注意事项"></a>3.2.1.2 -注意事项</h6><p><code>-</code>的使用只需要记住以下几点:</p><ol><li>想要减法运算就保持<code>-</code>两边都有空格</li><li>前有空格后没有则表示负数</li><li>在空格分割的数组中，将<code>-$var</code>这种形式的表达式用括号包裹起来，不然会进行减法运算</li></ol><h5 id="3-2-2-strings-三种方式”foo”-’foo’-foo"><a href="#3-2-2-strings-三种方式”foo”-’foo’-foo" class="headerlink" title="3.2.2 strings (三种方式”foo”,’foo’,foo)"></a>3.2.2 strings (三种方式”foo”,’foo’,foo)</h5><p>三种表达方式：单引号、双引号、没引号。使用起来基本没有不同，但有一个特例：如果是使用插值语法(<code>#&#123;$xx&#125;</code>)，且<code>$xx</code>是一个带引号的 string，则会自动去除引号。这个特性一般针对 mixin,如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> f-message(<span class="hljs-variable">$selector</span>) &#123;<br>  <span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.f</span> #&#123;<span class="hljs-variable">$selector</span>&#125;<span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Hello!&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> f-message(<span class="hljs-string">&quot;.header&quot;</span>);<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.f</span> <span class="hljs-selector-class">.header</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-2-2-1-字符串运算注意事项"><a href="#3-2-2-1-字符串运算注意事项" class="headerlink" title="3.2.2.1 字符串运算注意事项"></a>3.2.2.1 字符串运算注意事项</h6><p>字符串可以直接通过<code>+</code>进行相加，在字符串中可以使用插值语法(<code>#&#123;$xx&#125;</code>)来进行动态加法，如果插值内容为 null，则被视为空字符串。</p><h5 id="3-2-3-colors-blue-123-rgba-0-0-0-0-5"><a href="#3-2-3-colors-blue-123-rgba-0-0-0-0-5" class="headerlink" title="3.2.3 colors (blue, #123, rgba(0,0,0,0.5))"></a>3.2.3 colors (blue, #123, rgba(0,0,0,0.5))</h5><p>在压缩模式下编译颜色的时候，引擎会挑选最短的名称，如<code>#FF0000=&gt;red,blanchedalmond=&gt;#FFEBCD</code>。如果要将颜色的字符串，比如<code>blanchedalmond</code>用到选择器插值中，请一定加上引号，如果是如下代码:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$b</span>: blanchedalmond;<br><br><span class="hljs-selector-tag">body</span> #&#123;<span class="hljs-variable">$b</span>&#125; &#123;<br>  <span class="hljs-attribute">background</span>: #&#123;<span class="hljs-variable">$b</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>压缩编译后的结果是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#ffebcd</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffebcd</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就造成了语法错误，这种情况下，请将 blanchedalmond 加上引号，这样压缩模式编译的时候<code>#ffebcd</code>的位置就会变成<code>blanchedalmond</code>。</p><h6 id="3-2-3-1-颜色运算注意事项"><a href="#3-2-3-1-颜色运算注意事项" class="headerlink" title="3.2.3.1 颜色运算注意事项"></a>3.2.3.1 颜色运算注意事项</h6><p>颜色可以直接进行<code>+ - * /</code>，本质是 R、G、B 三种颜色的运算，如果某种颜色超过了<code>ff</code>则结果为<code>ff</code>。支持<code># rgba等形式</code>，在<code>rgba</code>形式中，两个透明度如果相同，则透明度不变，如果不同，则抛出错误。</p><h5 id="3-2-4-booleans-true-x2F-false"><a href="#3-2-4-booleans-true-x2F-false" class="headerlink" title="3.2.4 booleans (true&#x2F;false)"></a>3.2.4 booleans (true&#x2F;false)</h5><blockquote><p>布尔运算支持<code>and</code>、<code>or</code>和<code>not</code></p></blockquote><h5 id="3-2-5-nulls-null"><a href="#3-2-5-nulls-null" class="headerlink" title="3.2.5 nulls (null)"></a>3.2.5 nulls (null)</h5><h5 id="3-2-6-lists-如-1-5em-1em-0-1em-HE-AP"><a href="#3-2-6-lists-如-1-5em-1em-0-1em-HE-AP" class="headerlink" title="3.2.6 lists (如 1.5em 1em 0.1em,HE,AP)"></a>3.2.6 lists (如 1.5em 1em 0.1em,HE,AP)</h5><p>lists 多用于多值的 css 属性，比如 margin，border 等，在 sass 中，单个的值其实也被看作只有一个值的数组。lists 有两种表示形式，以空格分隔和以逗号分隔。</p><p>SassScript 提供了一些关于 list 的使用方法：</p><ul><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#nth-instance_method">nth</a>，访问数组中固定位置的元素。</li><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#join-instance_method">join</a>，组合两个数组。</li><li><a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#append-instance_method">append</a>，添加值到数组。</li><li><a href="https://www.sass.hk/en/documentation/file.SASS_REFERENCE.html#each-directive">@each</a>，遍历数组。</li></ul><p>数组中可以嵌套数组，通过括号的方式:<code>(1px 2px) (3px 4px)</code>编译成 css 之后括号会被去除，但在 scss 中带不带括号是大不相同的。</p><blockquote><p>在 scss 编译的过程中，括号或<code>null</code>或<code>空元素()</code>都会被去掉。<br>使用逗号可以表示单元素数组:<code>(1,)</code>。<br>数组不支持任何运算符，请用封装好的方法进行运算。</p></blockquote><h5 id="3-2-7-maps-如-key1-value1-key2-value2"><a href="#3-2-7-maps-如-key1-value1-key2-value2" class="headerlink" title="3.2.7 maps (如(key1: value1, key2: value2))"></a>3.2.7 maps (如(key1: value1, key2: value2))</h5><p>map 相当于键值对，如<code>$map: (k1: v1, k2: v2, k3: v3);</code>,map 必须被括号包裹，用逗号分割，key 和 value 可以是任何值，key 不能重复。map 有也有一系列的<a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html#map-functions">方法</a>，这里不赘述了，请看文档。使用<code>@each</code>遍历的时候，访问顺序和声明顺序一致。我们可以将数组的 list 使用在 map 上，这时 map 会被看作一个数组<code>(k1:v1,k2:v2)=&gt;k1 v1,k2 v2</code>,反之不可。<strong>map 不能直接被转化为 css，只用于中间运算。</strong></p><h4 id="3-3-特殊语法"><a href="#3-3-特殊语法" class="headerlink" title="3.3 特殊语法"></a>3.3 特殊语法</h4><blockquote><p>这里有<a href="https://www.sass.hk/en/documentation/Sass/Script/Functions.html">内置函数的列表</a>，使用时可以查阅。</p></blockquote><h5 id="3-3-1-命名参数"><a href="#3-3-1-命名参数" class="headerlink" title="3.3.1 命名参数"></a>3.3.1 命名参数</h5><p><code>hsl($hue: 0, $saturation: 100%, $lightness: 50%)</code>，使用这种命名参数可以在一个函数有多个参数可选的时候明确参数，看起来比较清晰。</p><h5 id="3-3-2-插值"><a href="#3-3-2-插值" class="headerlink" title="3.3.2 插值"></a>3.3.2 插值</h5><p>使用插值语法<code>#&#123;$xx&#125;</code>可以将变量转化为<code>Plain CSS</code>，相邻的运算符不会生效，如<code>#$&#123;a&#125;/#&#123;$b&#125;</code>不会进行计算。</p><h5 id="3-3-3-amp-语法"><a href="#3-3-3-amp-语法" class="headerlink" title="3.3.3 &amp;语法"></a>3.3.3 &amp;语法</h5><p><code>&amp;</code>可以表示父选择器，<code>&amp;</code>可以用作变量进行计算，在做变量的时候是双层嵌套的数组，比如<code>body a</code>的<code>&amp;</code>为<code>((body, a),)</code>。</p><p>如果没有父选择器(mixin)，<code>&amp;</code>为 null，可以通过如下代码判断是否有父选择器:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> does-parent-exist &#123;<br>  <span class="hljs-keyword">@if</span> &amp; &#123;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>  &#125; <span class="hljs-keyword">@else</span> &#123;<br>    <span class="hljs-selector-tag">a</span> &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-指令集"><a href="#4-指令集" class="headerlink" title="4. @指令集"></a>4. @指令集</h3><h4 id="4-1-import"><a href="#4-1-import" class="headerlink" title="4.1 @import"></a>4.1 @import</h4><p>我们可以通过<code>@import &#39;xx.scss&#39;</code>的形式引入另外的<code>scss</code>文件，如果不加后缀，引擎会自动寻找<code>.scss</code>和<code>.sass</code>文件。</p><p>css 中也有<code>@import</code>这个指令，除了以下 4 种情况直接原文编译成 css，其他的情况都会进行 scss 编译导入:</p><ol><li>文件扩展名为<code>.css</code></li><li>文件名以<code>http://</code>开始</li><li>文件名是<code>url(xx)</code></li><li>@import 中有任何媒体查询</li></ol><blockquote><p><code>@import &quot;a&quot;, &quot;b&quot;;</code>可以同时引入多个文件。</p></blockquote><p>如果不想让 scss 文件编译后导入，可以在要引用的文件名前加<code>_</code>，这样就不会编译成<code>.css</code>文件了。如:<code>_out.scss</code>文件，导入时使用<code>@import &quot;out&quot;;</code>即可，但要注意不要吧前置<code>_</code>和不前置的同名文件放在同一个文件夹下。</p><h4 id="4-2-media"><a href="#4-2-media" class="headerlink" title="4.2 @media"></a>4.2 @media</h4><p><code>@media</code>在 css 可以直接使用，在 scss 中多出一点特性:可以嵌套在 css 规则中。解析的时候会依次寻找到跟选择器，然后把规则加在整体的选择器上，如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: wheat;<br>  inner &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    innner &#123;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>) &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>      &#125;<br>      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: wheat;<br>&#125;<br><span class="hljs-selector-tag">body</span> inner &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span> inner innner &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> inner innner &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> inner innner &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同样在<code>@media</code>语句中可以使用插值语法<code>#&#123;$xx&#125;</code>。</p></blockquote><h4 id="4-3-extend"><a href="#4-3-extend" class="headerlink" title="4.3 @extend"></a>4.3 @extend</h4><p><code>@extend</code>是<code>sass</code>扩展的特性，和<code>Java</code>中的继承类似相当于拷贝了父选择器的所有属性，使用方法如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .father;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span>,<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<code>.son</code>就有了<code>.father</code>的所有属性了!我们可以看到其实他的内部原理就是把所有<code>.father</code>的地方换成<code>.father, .son</code>。如果产生了<code>.father.father</code>或<code>#a#b</code>这种不合理的东西，引擎会自动删减掉，非常智能。</p><blockquote><p>多继承是可以的，基本原理还是一样:把所有<code>.father</code>的地方换成<code>.father, .son</code>，如果有重复属性，则后来者优先。写法上讲可以写两行也可以逗号分割。<br>多重继承也是可以的，即 A extend B，B extend C。最后的结果通过上述原理也可以推出来。</p></blockquote><p>如果父子两个选择器都不是单一元素，都是很长一串的话，有个交叉的合并方法，规则是如果两个没有公用元素，则只会有 a 在 b 前和 b 在 a 前两种。如果有重复元素就把重复的提取出来再做交叉，具体例子如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span>,<br><span class="hljs-selector-id">#demo</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.fakelink</span>,<br><span class="hljs-selector-id">#admin</span> <span class="hljs-selector-class">.overview</span> <span class="hljs-selector-class">.tabbar</span> <span class="hljs-selector-class">.fakelink</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细体会一下。</p><h5 id="4-3-2-extend-only"><a href="#4-3-2-extend-only" class="headerlink" title="4.3.2 @extend-only"></a>4.3.2 @extend-only</h5><p>有些时候有些规则我们只想在<code>@extend</code>中使用，编译时我们想剔除它。这时就要用<code>%</code>来修饰，用法如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> %e &#123;<br>  <span class="hljs-attribute">color</span>: beige;<br>&#125;<br><br><span class="hljs-selector-id">#inner</span> <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %e;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-id">#inner</span> <span class="hljs-selector-tag">b</span>,<br><span class="hljs-selector-id">#inner</span> <span class="hljs-selector-id">#outer</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-attribute">color</span>: beige;<br>&#125;<br></code></pre></td></tr></table></figure><p>在生成的 css 代码中没有<code>#outer a %e</code>这一项，这就是<code>@extend-only</code>的用法。(别忘了这里可以用交叉合并的方式推导出生成的选择器)</p><blockquote><p>注意如果在<code>@media</code>内部使用<code>@extend</code>，则父规则也要在<code>@media</code>里，否则报错。</p></blockquote><h5 id="4-3-3-at-root"><a href="#4-3-3-at-root" class="headerlink" title="4.3.3 @at-root"></a>4.3.3 @at-root</h5><p>这个指令可以让后面的语句声明在全局中，有了它在别的规则中也可以声明全局规则了！还可以多行声明，像这样:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-keyword">@at-root</span> &#123;<br>    <span class="hljs-selector-class">.inner</span> &#123;<br>      <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>    <span class="hljs-selector-class">.inner2</span> &#123;<br>      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-selector-class">.inner3</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.inner</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.inner2</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.outer</span> <span class="hljs-selector-class">.inner3</span> &#123;<br>  <span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以在<code>@at-root</code>后面加上<code>(with: ...)或(without: ...)</code>去添加或者去除父级<code>@指令</code>，默认是不去除的，所以<code>without</code>使用的较多，<code>without: all</code>代表去除所有父级元素，<code>without:rule</code>代表去除所有父级<code>@指令</code>。</p></blockquote><h5 id="4-3-4-debug"><a href="#4-3-4-debug" class="headerlink" title="4.3.4 @debug"></a>4.3.4 @debug</h5><p>这个指令可以用来输出调试信息，我们想看某个变量或者表达式的话，在编译的时候直接可以看到，很方便。</p><blockquote><p>同样类型的还有<code>@warn</code>、<code>@error</code>，<code>@error</code>会直接阻断编译，<code>@warn</code>多用于第三方库警告。</p></blockquote><h5 id="4-3-5-mixin"><a href="#4-3-5-mixin" class="headerlink" title="4.3.5 @mixin"></a>4.3.5 @mixin</h5><p><code>@mixin</code>和<code>@extend</code>都可以进行规则的复用，<code>@mixin</code>可以避免使用<code>@extend</code>必须声明的无语义的类名，甚至我们可以在<code>@mixin</code>中加入参数，增强灵活性。</p><p>基本使用语法如下(参数是可选的):</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> large-text(<span class="hljs-variable">$color</span>) &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    size: <span class="hljs-number">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-keyword">@include</span> large-text(<span class="hljs-number">#fff</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于参数，我们可以使用<strong>关键字参数</strong>来明确参数对应关系，写法如:<code>sexy-border($color: blue)</code>。<br>由于历史原因，mixin 的名字中<code>_</code>和<code>-</code>是可以通用的，这两个字符可以随意互换。<br>多数编程语言中的<code>...</code>语法在 scss 中也可以使用，使用在参数中时可以自动将传入参数包装成一个数组。个人感觉完全可以用数组或 map 变量代替。</p></blockquote><p>通过<code>@include</code>可以引入<code>@mixin</code>规则，<code>@mixin</code>是一组规则的叠加，和<code>@extend</code>的原理是截然不同的。而且<code>@include</code>可以在任何地方使用，这和继承也是不同的。</p><p><code>@mixin</code>可以配合<code>@content</code>实现”插槽”，例如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> test-block &#123;<br>  <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-keyword">@content</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-keyword">@include</span> test-block &#123;<br>    <span class="hljs-selector-id">#abc</span> &#123;<br>      <span class="hljs-attribute">color</span>: black;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会被编译为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-id">#abc</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果<code>@content</code>被循环包裹，生成的 css 中会有好几组重复的规则，需要注意。<br>内置方法<code>content-exists()</code>用于在运行时判断是否传入规则块，强制传入规则块可以用这个。</p></blockquote><p><code>@mixin</code>也可以嵌套<code>@mixin</code>，规则的叠加，很好理解。</p><h3 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5. 控制语句"></a>5. 控制语句</h3><p>同大部分语言一样，sass 也有控制语句的功能，多配合<code>mixins</code>使用。</p><h4 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if()"></a>5.1 if()</h4><p><code>if()</code>语句是内置函数，使用方式类似三元表达式，如<code>if(1+1==2, 1px, 2px)</code>,可以用于变量赋值。</p><blockquote><p><code>@if</code>语句可用于规则声明，使用方式如<code>@if 1+1==2 &#123;color: white&#125;</code>。后面可以跟一系列的<code>@else if</code>和<code>@else</code>语句，用法和<code>Js</code>中类似。</p></blockquote><h4 id="5-2-for"><a href="#5-2-for" class="headerlink" title="5.2 @for"></a>5.2 @for</h4><p>循环语句，使用方法如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果会是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span>;<br>&#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>;<br>&#125;<br><span class="hljs-selector-class">.item-3</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-each"><a href="#5-3-each" class="headerlink" title="5.3 @each"></a>5.3 @each</h4><p><code>@each</code>也是循环，用来循环数组，使用方式如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/#&#123;$animal&#125;.png&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被编译成:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/puma.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/sea-slug.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/egret.png&quot;</span>);<br>&#125;<br><span class="hljs-selector-class">.salamander-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/salamander.png&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于多维数组，上例中的<code>$animal</code>可以写为一个数组，和多维数组中的数一一对应，访问的时候也是一维一维访问。<br><code>@each</code>也可以用来访问 map，map 中的键和值会当作一个数组，所以<code>$animal</code>的位置应该写两个变量。</p></blockquote><h4 id="5-4-while"><a href="#5-4-while" class="headerlink" title="5.4 @while"></a>5.4 @while</h4><p>这个指令也是循环，用法和<code>js</code>类似，只不过赋值语句变为<code>$i: $i-1</code>这种形式。</p><h4 id="5-5-function"><a href="#5-5-function" class="headerlink" title="5.5 @function"></a>5.5 @function</h4><p>scss 支持函数，使用<code>@function</code>定义函数，使用<code>@return</code>返回值，最好加上前缀，以免和内置函数重名。关于参数的特性其实跟<code>@mixin</code>差不多，都是一些常规功能。由于历史原因，函数名中的<code>-</code>和<code>_</code>是互通的，这和 mixin 也一样。</p><h3 id="5-输出格式参数"><a href="#5-输出格式参数" class="headerlink" title="5. 输出格式参数"></a>5. 输出格式参数</h3><p>虽然默认输出的 css 格式很实用，scss 也提供了一些参数供我们手动调整，我们在命令行中使用<code>--style xx</code>来设置输出格式，格式有如下几种:</p><ul><li>nested</li></ul><p>这是默认的输出格式，每个属性一行，简明易懂，但后大括号不是单占一行的，和我们平时手写的格式有点不同。</p><ul><li>expanded</li></ul><p>在<code>nested</code>基础上，后大括号单占一行，和我们常规手写格式一模一样。</p><ul><li>compact</li></ul><p>每个选择器和它的规则单占一行，压缩率更高。</p><ul><li>compressed</li></ul><p>压缩模式，所有都在一行，需要极致压缩文件时用。</p><h3 id="6-sass-扩展"><a href="#6-sass-扩展" class="headerlink" title="6. sass 扩展"></a>6. sass 扩展</h3><p>我们可以通过<code>Ruby</code>支持的一些函数手动扩展 sass 特性，但是这需要我们对<code>Ruby</code>有很强的理解，这里就不赘述了。</p>]]></content>
    
    
    <categories>
      
      <category>代码样式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode初体验</title>
    <link href="/2018/06/01/2018-06-01-vscode%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2018/06/01/2018-06-01-vscode%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>其实我本人对微软这家公司出品的产品不怎么感兴趣。<del>算是半个微软黑？</del>，所以当初<code>vscode</code>和<code>atom</code>这两款产品同时出现的我面前的时候，我想也没想直接选择了<code>atom</code>。</p><p>但是最近愈发无法忍受<code>atom</code>安装插件的速度，非常慢，有时还会失败，真的很让人头痛。所以在朋友的大力”怂恿”下我尝试了下微软的<code>Vitual Studio Code</code>这款编辑器。总体感受就两个字–舒服，下载插件的速度基本控制在 10s 以内，在 github 上它的 star 数还高于<code>atom</code>，可见插件库的丰富程度也是可以的。</p><p>所以今天我想在这里记录一下我在<code>vscode</code>中做的一些个人配置和主观感受，以供那些还在犹豫使用哪个文本编辑器的人一些参考。</p><h3 id="二、markdown-篇"><a href="#二、markdown-篇" class="headerlink" title="二、markdown 篇"></a>二、markdown 篇</h3><p>就我个人而言，大部分使用文本编辑器的时间都是在用 markdown 语言写一些记录性的文章，就像我现在在做的:)针对 markdown，我安装了如下插件:</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>:由于<code>vscode</code>是自带 markdown 预览的，所以我们不用为了预览去单独安装插件，但是这个预览有个问题就是背景是跟你所选主题同色的，我个人一般会选择黑色主题，图片一般是白色背景，所以感觉很别扭，这个插件可以把本地预览的效果变为和 github 中一致，这样就不会有任何违和感~</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=goessner.mdmath">Markdown+Math</a>:使用了这个插件后，我们就可以在 markdown 中使用 TeX 数学公式了。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a>:这个插件可以用来 lint 你的 markdown 代码，长期按照一个靠谱的规范书写 markdown 可以方便日后和别人做交流，如果有哪条规则不想要可以手动在配置文件里禁止。</p></li></ul><h3 id="三、通用篇"><a href="#三、通用篇" class="headerlink" title="三、通用篇"></a>三、通用篇</h3><p>还有一些通用的插件能提升我们的编码效率，在这里列举一下:</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) Language Pack for Visual Studio Code</a>:官方中文包，使用与因人而异吧，个人感觉中文看着更舒服。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory">Git History</a>:用来显示 git 历史，显示效果不错。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=spywhere.guides">Guides</a>:用来添加对齐用的辅助线，看着更舒服。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a>:一整套文件图标，更美观。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime">WakaTime</a>:神器，想知道你一天的工作效率如何？wakatime 满足你。</p></li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>总的来说<code>vscode</code>给我的感觉是很惊艳的，用到现在位置非常流畅，以上内容只是<code>vscode</code>的极小部分的功能，如果想了解更多可以到<a href="https://code.visualstudio.com/docs">官网教程</a>自行查看，非常详细。</p><p><strong>Have a nice day!</strong></p>]]></content>
    
    
    <categories>
      
      <category>优质工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[译]简明易懂javascript闭包</title>
    <link href="/2018/05/27/2018-05-27-%5B%E8%AF%91%5D%E7%AE%80%E6%98%8E%E6%98%93%E6%87%82javascript%E9%97%AD%E5%8C%85/"/>
    <url>/2018/05/27/2018-05-27-%5B%E8%AF%91%5D%E7%AE%80%E6%98%8E%E6%98%93%E6%87%82javascript%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天带来一篇关于 javacript 闭包的文章，文章来自 stackoverflow 的一个高票回答，个人感觉非常不错，兴致来了翻译一下，方便大家和我日后回顾，也顺便锻炼下我的英文水平:)。原文地址<a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work">在这</a>，本文目的只是学习研究，如有不妥当之处，请通过邮件告知我，非常感谢！</p></blockquote><h3 id="那么，正文开始～"><a href="#那么，正文开始～" class="headerlink" title="那么，正文开始～"></a>那么，正文开始～</h3><h4 id="一、闭包不是魔法"><a href="#一、闭包不是魔法" class="headerlink" title="一、闭包不是魔法"></a>一、闭包不是魔法</h4><p>本文的目的是通过小段 js 代码为广大程序员说明闭包，目标群体并不是此方面的专家。<br>如果理解了闭包的核心概念，闭包并不是一个很难理解的问题。但是如果仅仅靠阅读学术文章是不可能理解闭包的。这篇文章需要一些基本的编程知识，如果你可以读懂下面这段代码，那么恭喜你，理解这篇文章对你来说不是问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>  &#125;;<br>  <span class="hljs-title function_">say</span>();<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;Joe&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="二、一个栗子"><a href="#二、一个栗子" class="headerlink" title="二、一个栗子"></a>二、一个栗子</h4><p>闭包可以用两种方式来总结，即:</p><ul><li>闭包是一种支持<a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>的方式。他可以引用其第一次声明时的范围内的变量，我们可以任意使用变量，赋值、当作参数传递，或者通过 return 返回都是可以的。</li><li>闭包是当一个函数开始执行的时候，js 内部自动分配的一种堆栈结构，即使函数返回了这个堆栈结构都不会被释放(这种数据结构是分配在堆上而不是栈上的!)。</li></ul><p>如下代码返回了一个函数引用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello2</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello &quot;</span> + name; <span class="hljs-comment">// Local variable</span><br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-keyword">var</span> say2 = <span class="hljs-title function_">sayHello2</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><span class="hljs-title function_">say2</span>(); <span class="hljs-comment">// logs &quot;Hello Bob&quot;</span><br></code></pre></td></tr></table></figure><p>大多数 js 工程师都能理解上述代码中函数引用作为返回值的用法。如果你不能理解，那么你应该先了解一下这部分内容然后再继续学习闭包。一个 C 语言工程师可能会认为这个函数返回了另一个函数的指针，变量<code>say</code>和<code>say2</code>都是函数指针。<br>但是在 js 中上述代码和函数指针有一个重大的不同。在 js 中，你可以把函数引用理解为<strong>函数指针+闭包的隐形引用</strong>。<br>上述代码由于匿名函数<code>function() &#123; console.log(text); &#125;</code>声明在另一个函数(sayHello2)中，所以可以称之为闭包。在 javascript 中，如果你在一个方法中使用<code>function</code>这个关键字，你就创建了一个闭包。<br>在大部分语言中，在一个函数返回后，所有局部变量就都不能访问了，因为他们的堆栈结构都被销毁了。<br>在 js 中，如果你在一个函数中定义另一个函数，在外部函数返回后，外部函数的局部变量仍可以被内部函数访问，上述代码就是这个现象的演示。我们在<code>sayHello2()</code>函数返回后去调用<code>say2()</code>，注意<code>text</code>这个变量是<code>sayHello2()</code>的局部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text); &#125; <span class="hljs-comment">// Output of say2.toString();</span><br></code></pre></td></tr></table></figure><p>上述代码为 say2.toString()的值，我们可以看到上述代码中引用了变量<code>text</code>。这个匿名函数可以引用<code>text</code>这个变量(值为<code>Hello Bob</code>)，这是因为<code>sayHello()</code>的局部变量被保存在了闭包中。<br>神奇之处在于 js 中函数的引用会包含一个隐形的引用指向外部函数的闭包–相当于包含一个函数的指针+一个隐形的对象引用。</p><h4 id="三、更多的栗子"><a href="#三、更多的栗子" class="headerlink" title="三、更多的栗子"></a>三、更多的栗子</h4><p>在你阅读闭包释义的时候很难理解其中奥妙，但是当你看一些例子之后就会明白他们是如何工作的。我建议把下列例子仔细弄明白。如果你在使用闭包之前没有对其有充分的理解，你可能会制造一些十分诡异的 bug。</p><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h5><p>这个例子说明了局部变量并不是被拷贝的–闭包中存的是他们的引用。可以理解为当外部函数退出时，变量的堆栈结构被存储在了内存中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say667</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>  &#125;;<br>  num++;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-keyword">var</span> sayNumber = <span class="hljs-title function_">say667</span>();<br><span class="hljs-title function_">sayNumber</span>(); <span class="hljs-comment">// logs 43</span><br></code></pre></td></tr></table></figure><h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h5><p>这三个全局函数持有同一个闭包的引用，因为他们都被定义在了函数<code>setupSomeGlobals()</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> gLogNumber, gIncreaseNumber, gSetNumber;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupSomeGlobals</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">42</span>;<br>  <span class="hljs-comment">// Store some references to functions as global variables</span><br>  gLogNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>  &#125;;<br>  gIncreaseNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    num++;<br>  &#125;;<br>  gSetNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    num = x;<br>  &#125;;<br>&#125;<br><br><span class="hljs-title function_">setupSomeGlobals</span>();<br><span class="hljs-title function_">gIncreaseNumber</span>();<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 43</span><br><span class="hljs-title function_">gSetNumber</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">var</span> oldLog = gLogNumber;<br><br><span class="hljs-title function_">setupSomeGlobals</span>();<br><span class="hljs-title function_">gLogNumber</span>(); <span class="hljs-comment">// 42</span><br><br><span class="hljs-title function_">oldLog</span>(); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>这三个函数共享同一个闭包–函数<code>setupSomeGlobals()</code>的局部变量。<br>注意在以上例子中，如果你又调用了一次<code>setupSomeGlobals()</code>函数，一个新的闭包(堆栈结构)就会被创建。旧的<code>gLogNumber</code>、<code>gIncreaseNumber</code>、<code>gSetNumber</code>这三个变量会被拥有新闭包的新函数覆盖。(在 js 中，当你创建这种嵌套 function 的关系后，每次调用外部函数都会生成新的闭包)。</p><h5 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h5><p>这个例子向我们说明了，闭包会涵盖外部函数结束前声明的所有局部变量。注意变量<code>alice</code>实际上是在匿名函数之后声明的。匿名函数先声明，但是在匿名函数之中可以访问<code>alice</code>变量(js 有<a href="https://stackoverflow.com/a/3725763/1269037">变量提升</a>的机制)。<code>sayAlice()()</code>直接调用<code>sayAlice()</code>返回的函数引用-这样调用哦不需要临时变量。</p><blockquote><p><code>say</code>这个变量也被保存在闭包中，所有在<code>sayAlice()</code>中声明的内部函数都可以调用他，甚至<code>say()</code>函数中也可以进行递归调用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayAlice</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> say = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(alice);<br>  &#125;;<br>  <span class="hljs-comment">// Local variable that ends up within closure</span><br>  <span class="hljs-keyword">var</span> alice = <span class="hljs-string">&quot;Hello Alice&quot;</span>;<br>  <span class="hljs-keyword">return</span> say;<br>&#125;<br><span class="hljs-title function_">sayAlice</span>()(); <span class="hljs-comment">// logs &quot;Hello Alice&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6"></a>Example 6</h5><p>这个例子很多人已经理解原因了，所以你也要了解一下。当我们在循环中定义方法的时候要格外小心，闭包中包含的局部变量可能会出人意料。<br>在看这个例子之前，你要先理解之前提到的变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildList</span>(<span class="hljs-params">list</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> item = <span class="hljs-string">&quot;item&quot;</span> + i;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item + <span class="hljs-string">&quot; &quot;</span> + list[i]);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> fnlist = <span class="hljs-title function_">buildList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>  <span class="hljs-comment">// Using j only to help prevent confusion -- could use i.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; fnlist.<span class="hljs-property">length</span>; j++) &#123;<br>    fnlist[j]();<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">testList</span>(); <span class="hljs-comment">//logs &quot;item2 undefined&quot; 3 times</span><br></code></pre></td></tr></table></figure><p><code>result.push( function() &#123;console.log(item + &#39; &#39; + list[i])&#125; );</code>这行三次将匿名函数的引用加入到<code>result</code>数组中，如果你对匿名函数不了解，你可以将其看作如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pointer = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item + <span class="hljs-string">&quot; &quot;</span> + list[i]);<br>&#125;;<br>result.<span class="hljs-title function_">push</span>(pointer);<br></code></pre></td></tr></table></figure><p>这段代码的输出是三次<code>item2 undefined</code>!其中的原因类似之前的例子，这三个匿名函数包含同一个<code>buildList</code>闭包(其中包含<code>result</code>、<code>i</code>和<code>item</code>变量)。当<code>fnlist[j]();</code>这句代码运行的时候，他们使用的都是同一个闭包，同一组变量。这时<code>i</code>循环完毕，被累加到 3(<code>i++</code>),<code>item</code>变量一次次被覆盖，最后结果为<code>item2</code>。</p><p>当我们使用块级作用域声明<code>item</code>(通过<code>let</code>关键字)而不是使用函数作用域(通过<code>var</code>关键字)的时候，在<code>result</code>数组中存放的每个匿名函数都会有一个单独的闭包。输出会变为下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">item0 <span class="hljs-literal">undefined</span><br>item1 <span class="hljs-literal">undefined</span><br>item2 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>如果再把循环中使用的<code>i</code>通过<code>let</code>改为块级作用域的时候，我们会发现结果正常了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">item0 <span class="hljs-number">1</span><br>item1 <span class="hljs-number">2</span><br>item2 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="Example-7"><a href="#Example-7" class="headerlink" title="Example 7"></a>Example 7</h5><p>最后一个例子，每次调用<code>newClosure()</code>函数的时候都会新建一个单独的闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newClosure</span>(<span class="hljs-params">someNum, someRef</span>) &#123;<br>  <span class="hljs-comment">// Local variables that end up within closure</span><br>  <span class="hljs-keyword">var</span> num = someNum;<br>  <span class="hljs-keyword">var</span> anArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">var</span> ref = someRef;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    num += x;<br>    anArray.<span class="hljs-title function_">push</span>(num);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">&quot;num: &quot;</span> +<br>        num +<br>        <span class="hljs-string">&quot;; anArray: &quot;</span> +<br>        anArray.<span class="hljs-title function_">toString</span>() +<br>        <span class="hljs-string">&quot;; ref.someVar: &quot;</span> +<br>        ref.<span class="hljs-property">someVar</span> +<br>        <span class="hljs-string">&quot;;&quot;</span><br>    );<br>  &#125;;<br>&#125;<br>obj = &#123; <span class="hljs-attr">someVar</span>: <span class="hljs-number">4</span> &#125;;<br>fn1 = <span class="hljs-title function_">newClosure</span>(<span class="hljs-number">4</span>, obj);<br>fn2 = <span class="hljs-title function_">newClosure</span>(<span class="hljs-number">5</span>, obj);<br><span class="hljs-title function_">fn1</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// num: 5; anArray: 1,2,3,5; ref.someVar: 4;</span><br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// num: 6; anArray: 1,2,3,6; ref.someVar: 4;</span><br>obj.<span class="hljs-property">someVar</span>++;<br><span class="hljs-title function_">fn1</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;</span><br><span class="hljs-title function_">fn2</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;</span><br></code></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>如果还有任何不清晰的地方，可以自己再研究运行下上面的例子。通过代码梳理思路比看释义要简单的多。我对闭包的堆栈结构之类的分析，在技术上来讲不完全准确–但这样解释可以明显的简化概念，便于理解。先搞懂大体的逻辑，具体的细节可以在日后使用的时候慢慢理解。</p><h4 id="五、知识点"><a href="#五、知识点" class="headerlink" title="五、知识点"></a>五、知识点</h4><ul><li>每当你在一个函数中声明另一个函数中时，闭包就出现了。</li><li>当你在一个函数中使用<code>eval()</code>时，闭包出现。你在参数中可以调用外部函数的局部变量，在<code>eval</code>内你甚至可以通过<code>eval(&#39;var foo=...&#39;)</code>来创建新的局部变量。</li><li>当你在一个函数中使用<code>new Function(...)</code>(函数的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">构造器</a>，并不会产生闭包(在内部函数中不能使用外部函数的局部变量)。</li><li>闭包包含所有外部函数中的所有局部变量，只要在外部函数返回前声明的都会包含。</li><li>我们可以这么想，一个闭包只是创建了一个函数入口，局部变量被加入到闭包中。</li><li>每当外部函数被调用时，一个新的闭包被创建。</li><li>两个函数可能内容相同，但是运行出来的结果不同，这可能是因为隐藏的闭包。</li><li>函数的多层嵌套是可能的，你可能获得多级的闭包。(即内部函数的内部函数可以访问外部函数的局部变量)。</li><li>我通常认为闭包是函数声明和局部变量的集合体，虽然我在本篇文章中没有使用这个方式定义。</li><li>我怀疑 js 中的闭包和一般的函数式语言的实现方式不同。</li></ul><h4 id="六、相关链接"><a href="#六、相关链接" class="headerlink" title="六、相关链接"></a>六、相关链接</h4><ul><li>Douglas Crockford 通过闭包来实现<a href="http://www.crockford.com/javascript/private.html">私有方法和私有变量的模拟</a>。</li><li>一个很好的<a href="https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited">例子</a>，这个例子解释了闭包在 IE 中是如何导致内存泄漏的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue基础篇:动画和过渡</title>
    <link href="/2018/05/24/2018-05-24-vue%E5%9F%BA%E7%A1%80%E7%AF%87:%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/"/>
    <url>/2018/05/24/2018-05-24-vue%E5%9F%BA%E7%A1%80%E7%AF%87:%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>动态效果是可以大幅度提高网站美观度的，vue 当然也进行了相应的封装。下面总结一下这些效果的用法。</p><h4 id="二、过渡"><a href="#二、过渡" class="headerlink" title="二、过渡"></a>二、过渡</h4><p>过渡是可以在元素创建、删除、更新时(<code>v-if</code>、<code>v-show</code>)附加上的动态效果。</p><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isDisplay&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test-enter-active</span>,<br><span class="hljs-selector-class">.test-leave-active</span> &#123;<br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span>;<br>&#125;<br><span class="hljs-selector-class">.test-enter</span>,<br><span class="hljs-selector-class">.test-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本原理是 vue 引擎在侦测到 transition 组件存在的时候，会在恰当的时机对目标元素插入 css 类，插入的类总体有六个，示意图如下(按照添加顺序排列)，六个类的第一个单词应替换为 transition 组件中的 name：<br><img src="https://cn.vuejs.org/images/transition.png" alt="过渡的css类加载流程"></p><p>通过在 transition 属性中自定义过渡类别和持续时间，我们可以实现很丰富的动态效果。</p><h4 id="三、动画"><a href="#三、动画" class="headerlink" title="三、动画"></a>三、动画</h4><p>将过渡的用法稍微改变一下:在 css 代码中将 transition 替换为 animation+keyframes，就可以将 css 中的动画附加到过渡效果中，举个栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test-enter-active</span> &#123;<br>  <span class="hljs-attribute">animation</span>: test <span class="hljs-number">0.5s</span>;<br>&#125;<br><span class="hljs-selector-class">.test-leave-active</span> &#123;<br>  <span class="hljs-attribute">animation</span>: test <span class="hljs-number">0.5s</span> reverse;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> test &#123;<br>  <span class="hljs-number">20%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">40%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">60%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">80%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50px</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50px</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这动画效果最后会走出一个菱形。总体来说，动画和过渡都依赖于 transition 这个属性，在 css 属性上过渡使用 transition 属性，动画使用 animation 属性。</p><h4 id="四、自定义类名"><a href="#四、自定义类名" class="headerlink" title="四、自定义类名"></a>四、自定义类名</h4><p>一些简单的动画和过渡效果我们可以手动编写，但是遇到一些复杂的动态效果再手动编写就不太方便了。所以 vue 提供了自定义类名的功能。栗子继续(需要事先引入第三方库<a href="https://github.com/daneden/animate.css">animate.css</a>)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">&quot;animated tada&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">&quot;animated bounceOutRight&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样，对应之前提到的 6 个状态分别有 6 个类：<br><code>enter-class</code>、<code>enter-active-class</code>、<code>enter-to-class</code>、<code>leave-class</code>、<code>leave-active-class</code>、<code>leave-to-class</code></p><p>通过这种方式我们就可以方便的使用第三方库中已经封装好的动态效果。</p><blockquote><p>transition 组件可以通过传递 duration 属性来确定动画时间，如<code>:duration=&quot;&#123;enter: 1000, leave: 2000&#125;&quot;</code>指的是进入效果 1s，离开效果 2s，如果只是一个数字则进入离开都是这个时间。</p></blockquote><h4 id="五、javascript-钩子"><a href="#五、javascript-钩子" class="headerlink" title="五、javascript 钩子"></a>五、javascript 钩子</h4><p>transition 不光可以和第三方 css 库结合，还可以和第三方 js 库结合，通过 js 钩子的形式，动态效果的编写变得更加灵活简单。可用的钩子有<code>@before-enter</code>、<code>@enter</code>、<code>@after-enter</code>、<code>@enter-cancelled</code>、<code>@before-leave</code>、<code>@leave</code>、<code>@after-leave</code>、<code>@leave-cancelled</code>，字面意思很直观的表现出了具体对应哪个阶段。代码片段如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> @<span class="hljs-attr">enter</span>=<span class="hljs-string">&quot;enter&quot;</span>&gt;</span><br>  xxx<br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">enter</span>(<span class="hljs-params">el, done</span>) &#123;<br>    <span class="hljs-title class_">Velocity</span>(el, &#123;<span class="hljs-attr">translateX</span>: <span class="hljs-string">&#x27;50px&#x27;</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>&#125;,&#123; <span class="hljs-attr">duration</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">complete</span>: done &#125;);<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>类似如此写法就可以轻易的将第三方 js 库 velocity.js 融入到 vuejs 中，相当方便。需要注意的是如果使用的是 enter 或 leave 这两个钩子，在最后需要手动调用 done 方法，上述代码就是在 Velocity 的回调中调用了 done 方法。</p><h4 id="六、初始渲染"><a href="#六、初始渲染" class="headerlink" title="六、初始渲染"></a>六、初始渲染</h4><p>在最初渲染时也有对应的一套钩子和属性，初始渲染可以这么写:<code>&lt;transition appear&gt;&lt;/transition&gt;</code>，css 对应的属性为<code>appear-class</code>、<code>appear-to-class</code>、<code>appear-active-class</code>这三个，用法和第三节自定义类名相同。<br>钩子对应的是<code>@before-appear</code>、<code>@appear</code>、<code>@after-appear</code>、<code>@appear-cancelled</code>这四个，用法同第五节。</p><h4 id="七、transition-group"><a href="#七、transition-group" class="headerlink" title="七、transition-group"></a>七、transition-group</h4><p>截止当前，transition 的相关使用方式已经讲解的差不多了。但是 transition 有个知名弱点就是他不能同时包裹多个元素。但多个元素同时添加过渡效果又是很常用的场景，所以<code>transition-group</code>闪亮登场。</p><p><code>transition-group</code>的使用方式和<code>transition</code>极其类似，前几章列举的集中用法:js 钩子、自定义类、初始渲染、动画，都可以直接用在<code>transition-group</code>上。</p><p>下面说多出的特性：</p><ol><li>这个组件在 vue 引擎渲染的时候会自动退化为一个 span 元素，可以通过 tag 属性来设置退化成的元素类型。比如<code>tag=&quot;ul&quot;</code>就会让组件自动退化成 ul 元素，这在子元素是 li 循环的时候是很好用的。</li><li><code>v-move</code>特性，这个特性让一个，他会在元素改变定位的过程中使用。比如，多个元素换位置，这个过程既不是新增又不是删除，之前说的<code>v-enter</code>、<code>v-leave</code>那一套都控制不了这个过程，这时<code>v-move</code>就派上用场了，用法和<code>v-leave</code>相同，都是将<code>v-</code>替换成相应的前缀即可，这样在所有元素进行为止移动的时候都会按照<code>v-move</code>定义的方式进行动态效果渲染。</li><li>多个组件渲染过渡效果就有了一个先后顺序的问题。官方网站给出的例子是使用<strong>js 钩子</strong>+<strong>Velocity.js</strong>+<strong>setTimeOut</strong>,通过回调方法，来随时间推移设置过渡，代码如下:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">enter</span>(<span class="hljs-params">el, done</span>) &#123;<br>  <span class="hljs-keyword">const</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">500</span>;<br>  <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title class_">Velocity</span>(el, &#123;..&#125;, &#123;<span class="hljs-attr">complete</span>: done&#125;);<br>  &#125;, delay);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顺带一提，el.dataset.index 的方式可以从 el 元素上提取附带的数据。html 中的写法是<code>&lt;x data-index=&quot;&quot;&gt;&lt;/x&gt;</code>,这是 html 规范，并不是 vuejs 中定义的内容。</p></blockquote><h4 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h4><p>vue 过渡的用法封装的简单明了，最后附上导图以便理清思路:<br><img src="https://i.loli.net/2018/05/24/5b06699797362.png" alt="Vue过渡与动画导图.png"></p>]]></content>
    
    
    <categories>
      
      <category>javascript框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
