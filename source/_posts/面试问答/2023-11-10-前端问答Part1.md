# 前端工程师面试问题集

## 浏览器技术

### 浏览器的关键进程和线程
**问题**: 请讲讲浏览器有哪些关键的进程和线程。
**回答**: 
在现代浏览器中，尤其是像Google Chrome这样的浏览器，主要包含以下几种类型的进程和线程：

1. **主进程**：负责浏览器界面的显示和交互，处理用户输入、各种事件的派发、子进程的创建和销毁等。它还负责文件的下载和基本的UI展示。

2. **渲染进程**：每个浏览器标签通常对应一个渲染进程，负责页面的渲染，包括HTML的解析、CSS样式的计算、JS脚本的执行等。在多标签的浏览器中，每个标签页一般都有自己的渲染进程。

3. **GPU进程**：用于3D绘制等操作，随着现代网页越来越多地采用CSS动画和WebGL等技术，GPU进程变得越发重要。

4. **网络进程**：处理页面的网络资源加载。

5. **插件进程**：对于每个插件，浏览器为其创建一个独立的进程。

这些进程相互独立，保证了浏览器的稳定性和安全性。当一个页面崩溃时，它不会影响到浏览器中的其他页面。

此外，还有一些关键的线程，如：

- **GUI渲染线程**：负责渲染浏览器的UI界面。
- **JavaScript引擎线程**：用于解析和执行JavaScript代码。
- **事件触发线程**：用于控制事件循环，处理事件和执行回调函数。
- **定时器触发线程**：负责执行异步的setTimeout和setInterval。
- **异步HTTP请求线程**：用于执行异步请求的回调。

这些线程和进程共同构成了浏览器的基础架构，确保了浏览器的快速、稳定和安全运行。

## Web API 和 JavaScript

### RequestAnimationFrame方法和RequestIdleCallback方法
**问题**: 了解RequestAnimationFrame方法和RequestIdleCallback方法吗，讲一讲他们是什么和用途。
**回答**: 
`requestAnimationFrame`和`requestIdleCallback`是现代浏览器提供的两个重要的API，用于优化JavaScript动画和背景任务的性能。

- **requestAnimationFrame**:
  - `requestAnimationFrame`主要用于优化动画的性能。传统的使用`setTimeout`或`setInterval`方法的动画可能会导致动画不流畅或过度绘制，而`requestAnimationFrame`提供了一种更高效的方式来请求浏览器在下次重绘前执行动画更新。
  - 它与浏览器的刷新率同步，可以在浏览器绘制的每一帧中运行动画，从而确保动画的流畅性和高效性。

- **requestIdleCallback**:
  - `requestIdleCallback`则用于在浏览器的空闲时段内调用函数，以便不影响关键事件和动画的响应能力。
  - 它允许开发者在浏览器空闲时执行低优先级或不急迫的任务，如数据预取、分析和背景日志记录等。
  - 这有助于改善页面的性能，尤其是在复杂或资源密集型应用中，可以在不影响用户体验的情况下完成必要的背景工作。

这两个API在现代Web开发中越来越重要，它们帮助开发者更有效地利用浏览器的能力来提高应用性能和用户体验。

## HTTP 和网络

### 常见的Http头字段及其用途
**问题**: 举几个常见的Http头字段，他们分别有什么用途。
**回答**: 
在HTTP通信中，头字段用于传递关于请求和响应的额外信息。常见的HTTP头字段包括：

- **Content-Type**: 指示资源的MIME类型，如`text/html`、`application/json`等。
- **Content-Length**: 表示响应体的长度。
- **User-Agent**: 包含有关发起请求的客户端信息，如浏览器类型和版本。
- **Cookie**: 从服务器发送到客户端并存储在客户端的小数据片段，用于状态管理。
- **Set-Cookie**: 由服务器发送，告诉客户端设置一个Cookie。
- **Accept**: 表示客户端可以处理的内容类型。
- **Authorization**: 包含用于认证的凭据信息，通常用于验证请求。
- **Cache-Control**: 指示缓存行为的指令。
- **Host**: 指定请求的服务器的域名和端口号。
- **Referer**: 表示请求发起的源页面地址。
- **Accept-Encoding**: 表示客户端支持的内容编码，如gzip。
- **Connection**: 控制客户端和服务器之间的连接管理。

这些头字段在HTTP请求和响应中起着至关重要的作用，它们影响着资源的加载方式、性能优化、安全策略、用户验证等方面。

### Cookie常用的字段
**问题**: 你提到了cookie，我们知道cookie常用于身份验证，举几个cookie常用的字段的例子。
**回答**: 
Cookie是由服务器发送到用户浏览器并存储的小数据片段，用于状态管理和用户跟踪。常见的Cookie字段包括：

- **Name**: Cookie的名称。
- **Value**: 与Cookie名称关联的值。
- **Expires/Max-Age**: 定义Cookie的有效期。Expires设置一个过期日期，Max-Age设置Cookie存在的秒数。
- **Domain**: 指定哪些域可以接收Cookie。如果未指定，默认为发起请求的域。
- **Path**: 指定与Cookie关联的网页路径。
- **Secure**: 指示Cookie仅应通过安全协议发送，如HTTPS。
- **HttpOnly**: 指示Cookie不应该被JavaScript访问。
- **SameSite**: 用于防止CSRF攻击和用户跟踪，它可以有Strict、Lax和None三个值。

这些字段控制着Cookie的发送、过期和安全性，对于Web应用中的身份验证、会话管理和个性化设置非常重要。

## 服务器端渲染 (SSR)

### SSR和SEO
**问题**: SSR和SEO相关了解吗，具体讲讲。
**回答**: 
服务器端渲染（SSR）是一种在服务器上生成完整HTML页面的技术，对搜索引擎优化（SEO）非常有益。在SSR中，页面的初始渲染发生在服务器上，生成的HTML然后被发送到客户端。这对SEO有几个主要的好处：

1. **更快的加载时间**: SSR可以提供更快的页面加载时间，因为浏览器可以更快地开始渲染页面，不需要等待所有JavaScript下载并执行。

2. **更好的搜索引擎抓取**: 由于页面的HTML是预先生成的，搜索引擎抓取器（如Googlebot）可以更容易地抓取和索引内容。

3. **改进的可见性和索引**: 对于不执行JavaScript的搜索引擎抓取器，SSR确保了页面内容的可见性，从而有助于更好地理解和索引页面内容。

4. **首屏内容快速呈现**: SSR还有助于快速呈现首屏内容，这对于用户体验和搜索引擎排名都是至关重要的。

尽管如此，SSR也带来了一些挑战，如服务器负载的增加、开发复杂性和可能的延迟渲染问题。但总的来说，SSR是提高Web应用SEO性能的有效手段。

### SSR的缺点
**问题**: 简单讲讲SSR的缺点。
**回答**: 
尽管服务器端渲染（SSR）对于SEO和首屏加载时间有显著好处，但它也有一些缺点：

1. **服务器负载**: SSR增加了服务器的负载，因为每个页面请求都需要服务器动态生成HTML。这对于高流量网站来说可能成为一个问题。

2. **开发复杂性**: SSR可能增加应用的开发和维护复杂性。开发者需要确保代码在服务器和客户端都能正常运行。

3. **时间到首字节（TTFB）延迟**: 由于服务器需要处理更多的渲染工作，这可能导致时间到首字节（即从请求开始到接收到第一个响应字节的时间）的延迟。

4. **缓存策略限制**: 使用SSR时，缓存策略可能更难实现，因为每个请求可能需要动态渲染内容。

5. **水合（Hydration）问题**: 在SSR中，客户端JavaScript需要“水合”服务器渲染的HTML。如果处理不当，这可能导致客户端和服务器渲染内容不同步的问题。

因此，选择SSR还是客户端渲染（CSR）应根据应用的特定需求和资源来决定。

### SSR和异步请求数据
**问题**: SSR每次都返回整个网页，那是不是浏览器就不用进行异步请求数据并部分更新网页了？
**回答**: 
在服务器端渲染（SSR）中，虽然初始页面是由服务器完整生成的，但这并不意味着客户端不需要进行异步请求数据或更新页面部分内容。在以下情况中，客户端依然需要进行异步请求：

1. **动态内容更新**: 对于动态网站，页面上的某些内容可能需要根据用户交互或其他事件动态更新。这些情况下，客户端JavaScript仍然需要发起异步请求来获取最新数据，并更新DOM。

2. **客户端路由**: 在单页应用（SPA）中，即使使用了SSR，客户端路由（如使用React Router或Vue Router）依然需要在用户浏览不同页面时请求新数据。

3. **用户特定数据**: 对于需要根据不同用户展示不同内容的网站，客户端可能需要请求特定于用户的数据，如个人资料信息、购物车内容等。

4. **数据预取和懒加载**: 为了优化性能和用户体验，客户端可能会采用数据预取或懒加载策略，这也需要异步请求。

因此，即使在SSR中，异步请求仍然是现代Web应用的重要组成部分。

## 前端框架和库

### Vue如何实现SSR
**问题**: 简单讲讲vue如何实现SSR。
**回答**: 
Vue.js实现服务器端渲染（SSR）的核心是使用`vue-server-renderer`包。基本流程大致如下：

1. **服务器设置**: 首先，需要设置一个可以处理服务器端渲染的Node.js服务器。这通常涉及到创建一个Express或Koa的服务器。

2. **创建Vue实例**: 在服务器上，创建一个新的Vue实例，这与在客户端创建Vue应用类似，但是它会针对服务器环境进行优化。

3. **路由处理**: 使用`vue-router`在服务器上处理路由。当一个请求到达时，服务器需要解析URL并渲染相应的Vue组件。

4. **组件渲染**: 使用`vue-server-renderer`将Vue实例渲染为HTML。这个过程涉及到将Vue组件和其子组件渲染成服务器端的HTML字符串。

5. **数据预取和状态管理**: 对于需要异步获取数据的组件，服务器渲染过程需要等待这些数据获取完成，才能进行渲染。这通常通过在组件的生命周期钩子中获取数据并利用Vuex进行状态管理来实现。

6. **客户端激活**: 服务器发送生成的HTML到客户端后，客户端的Vue应用会“激活”这些静态标记。这个过程称为“水合”（Hydration），Vue会将静态内容转化为动态的应用，使其能够响应用户交互。

7. **HTML发送至客户端**: 最后，服务器将渲染好的HTML发送给客户端。这个HTML是应用的初始状态，客户端的Vue应用会在此基础上进行交互。

SSR在Vue.js中可以提升首次加载性能，改善SEO，但也增加了开发和服务器处理的复杂性。

### Vue和React的区别
**问题**: 讲一讲vue和React的区别。
**回答**: 
Vue和React是两个流行的前端JavaScript框架，它们各有特点和优势：

1. **设计哲学**:
   - Vue更倾向于提供一个更全面的解决方案，它在核心库以外提供了诸如路由器（vue-router）、状态管理（Vuex）等官方库。
   - React更专注于UI层，它提供了更多的灵活性，允许开发者选择其他库来处理路由、状态管理等功能。

2. **模板语法 vs JSX**:
   - Vue使用基于HTML的模板语法，这使得编写和理解组件变得非常直观。
   - React使用JSX，这是一种JavaScript的语法扩展，允许在JavaScript代码中写入类似HTML的标记。

3. **响应式系统**:
   - Vue的响应式系统更简单直观，它使用基于getter/setter的系统自动追踪依赖。
   - React则使用基于状态（state）和属性（props）的概念，通过setState方法来更新UI。

4. **生态系统和社区**:
   - React由Facebook支持，拥有更大的社区和生态系统。有大量的第三方库和工具可用。
   - Vue虽然社区规模较小，但它拥有一个非常活跃和友好的社区，以及一套完整的官方支持库。

5. **学习曲线**:
   - Vue通常被认为更容易上手，特别是对于那些熟悉HTML和JavaScript的开发者。
   - React的学习曲线可能略高一些，特别是对于初学者来说，理解JSX和组件生命周期可能需要一些时间。

总的来说，Vue和React都是优秀的选择，但它们在设计理念、开发模式和生态系统支持上存在差异。选择哪个框架更多地取决于个人或团队的偏好、项目需求以及期望的开发体验。

## 前端工程化

### 前端工程化的理解
**问题**: 如何理解前端的工程化？
**回答**: 
前端工程化是指将软件工程的方法和实践应用于前端开发，旨在提高代码质量、提升开发效率、促进团队协作和确保项目可持续性。主要包括以下方面：

1. **代码规范化**: 实现代码风格的统一，使用如ESLint、Prettier等工具来自动化代码格式化和质量检查。

2. **模块化和组件化**: 将大型代码库分解为可重用的模块和组件，提高代码的可维护性和复用性。

3. **自动化构建和部署**: 使用Webpack、Gulp等工具自动化完成构建流程，结合CI/CD实现自动化测试和部署。

4. **依赖管理**: 使用npm、yarn等包管理工具管理项目依赖。

5. **性能优化**: 通过各种策略和实践，如代码分割、懒加载、资源压缩等，提升应用的加载速度和运行效率。

6. **测试**: 实施单元测试、集成测试、端到端测试等，确保代码质量。

7. **版本控制**: 使用Git等版本控制系统管理代码变更和协作。

8. **文档和知识共享**: 编写文档和建立知识共享机制，以促进团队成员之间的信息共享和协作。

9. **团队协作和流程优化**: 通过代码审查、敏捷开发方法等提高团队协作效率。

前端工程化不仅关注技术层面的提升，还关注团队协作和项目管理，使得前端开发更加系统化和规范化。

### ESLint中自定义规则的创建
**问题**: 你知道eslint中如何自定义规则吗，举个例子。
**回答**: 
在ESLint中自定义规则意味着创建一套自己的代码风格或质量检查规则。这通常涉及以下步骤：

1. **创建规则文件**: 首先创建一个JavaScript文件来定义规则。

2. **定义规则逻辑**: 在文件中定义一个对象，该对象包含`create`方法，该方法返回一个规则对象。这个对象定义了对特定AST节点的处理逻辑。

3. **使用AST节点**: 根据需要检查的代码特征，选择相应的AST节点类型。例如，可以选择`VariableDeclaration`节点来检查变量声明。

4. **编写检查逻辑**: 在规则对象中，针对选定的AST节点编写具体的检查逻辑。

例如，创建一个规则来确保所有的变量声明都使用`const`而非`let`或`var`:

```javascript
module.exports = {
    create: function(context) {
        return {
            VariableDeclaration(node) {
                if (node.kind !== 'const') {
                    context.report({
                        node,
                        message: 'Use const instead of let or var for variable declarations.'
                    });
                }
            }
        };
    }
};
```

配置ESLint: 将自定义规则添加到ESLint配置中。
通过这种方式，可以根据团队的编码标准和最佳实践自定义ESLint规则。

ESLint规则钩子的使用
问题: 你提到了eslint的create钩子，除了这个还有其他的钩子吗？
回答:
在ESLint中创建规则时，除了create方法外，还可以使用其他钩子来指定不同的行为。这些钩子对应于JavaScript源代码的AST（抽象语法树）中的不同节点类型。当ESLint解析代码时，会触发与这些节点匹配的钩子函数。以下是一些常用的钩子：

- **FunctionDeclaration**: 当遇到函数声明时触发。
- **CallExpression**: 当遇到函数或方法调用表达式时触发。
- **Literal**: 当遇到字面量（如字符串、数字）时触发。
- **IfStatement**: 当遇到if语句时触发。
- **VariableDeclaration**: 当遇到变量声明时触发。
- **ArrowFunctionExpression**: 当遇到箭头函数表达式时触发。
- **MemberExpression**: 当遇到对象成员表达式（如`obj.property`）时触发。
- **AssignmentExpression**: 当遇到赋值表达式时触发。
- **ImportDeclaration**: 当遇到ES6模块导入时触发。

使用这些钩子，可以针对特定的代码模式或结构编写定制的检查逻辑，从而创建出适应特定代码风格和要求的ESLint规则。

## 前端性能优化

### 前端性能指标
**问题**: 举几个最关键的前端性能指标，系统性的讲讲如何针对他们进行优化。
**回答**: 
关键的前端性能指标主要包括：

1. **首次内容绘制（First Contentful Paint, FCP）**: 表示从页面加载开始到页面内容的第一部分被渲染的时间。优化FCP的方法包括减少关键渲染路径的资源、最小化主线程工作、延迟加载非关键资源。

2. **首次有意义绘制（First Meaningful Paint, FMP）**: 表示主要内容开始出现在屏幕上的时间。优化策略包括优先加载关键内容、使用服务端渲染。

3. **可交互时间（Time to Interactive, TTI）**: 页面变得完全可交互的时间。可以通过代码分割、减少JavaScript执行时间、优化页面元素加载优先级来提高TTI。

4. **总阻塞时间（Total Blocking Time, TBT）**: FCP和TTI之间主线程被阻塞的总时长。减少长任务、拆分大型JavaScript文件可以减少TBT。

5. **最大内容绘制（Largest Contentful Paint, LCP）**: 页面中最大文本块或图像元素完全加载的时间。优化图像、使用更快的服务端响应、客户端渲染优化可以提高LCP。

6. **累积布局偏移（Cumulative Layout Shift, CLS）**: 页面加载过程中视觉布局变化的总和。优化策略包括为图像和视频指定尺寸、动态内容加载时避免突然布局变化。

对这些性能指标的优化有助于提升用户体验、提高应用的可访问性和搜索引擎排名。

### 白屏时间对应的指标
**问题**: 白屏时间对应的哪个指标？
**回答**: 白屏时间通常对应于“首次内容绘制”（First Contentful Paint, FCP）这个性能指标。FCP指的是从页面开始加载到页面上的第一个内容元素（如文本、图片）被绘制的时间。在这个时间点之前，用户通常会看到一个空白屏幕，这就是所谓的“白屏”。

## Webpack配置和优化

### 配置资源Preload和Prefetch
**问题**: 在webpack5的项目中，如何配置资源preload和prefetch？
**回答**: 
在Webpack 5中，你可以使用`HtmlWebpackPlugin`来配置资源的预加载（preload）和预获取（prefetch）。这可以通过以下步骤实现：

1. **使用`HtmlWebpackPlugin`**:
   - 该插件用于生成HTML文件，并可以通过配置来包含特定的资源。
   - 安装`html-webpack-plugin`并在webpack配置中添加它。

2. **配置Preload**:
   - 使用`preload-webpack-plugin`或在`HtmlWebpackPlugin`配置中手动指定`preload`属性来预加载关键资源。
   - 这对于需要尽快加载的资源（如CSS、关键脚本和字体文件）非常有用。

3. **配置Prefetch**:
   - 通过在`import()`语句中添加`webpackPrefetch: true`注释来实现资源的预获取。
   - 这适用于将来可能需要但优先级较低的资源，例如在用户执行特定操作时才需要的脚本。

这种配置方法可以优化资源加载时间和应用性能，特别是对于提高首次内容绘制（FCP）和首次有意义绘制（FMP）非常有效。

### Preload、Defer和Async的区别
**问题**: preload和script标签的defer、async有什么区别？
**回答**: 
`preload`、`defer`和`async`是HTML中用于控制资源加载行为的不同属性，主要区别如下：

- **Preload**:
  - 用于告诉浏览器页面必须立即获取的资源。
  - 通过`<link rel="preload" href="...">`标签实现。
  - 对于关键资源，如关键CSS和JavaScript文件，非常有用。

- **Defer**:
  - 用于延迟执行脚本，直到HTML文档被完全解析和显示后。
  - 通过在`<script>`标签中设置`defer`属性实现。
  - 保证脚本按照它们在文档中出现的顺序执行，对于依赖DOM的脚本非常有用。

- **Async**:
  - 允许脚本异步加载。
  - 通过在`<script>`标签中设置`async`属性实现。
  - 当脚本可用时立即执行，适用于不依赖DOM或其他脚本的独立模块。

这些属性允许开发者更精细地控制资源的加载和执行，从而优化页面加载性能和用户体验。

### 配置Async或Defer
**问题**: 在webpack5组织的项目中，如何配置以使用async或defer呢？
**回答**: 
在Webpack 5项目中，可以通过以下方式配置使用`async`或`defer`:

- **配置Defer**:
  - 使用`html-webpack-plugin`，可以在其配置中指定`scriptLoading: 'defer'`，这会为所有通过Webpack插入的脚本标签添加`defer`属性。
  - 这适用于那些需要在文档解析完成后执行，但在DOMContentLoaded事件之前执行的脚本。

- **配置Async**:
  - 对于`async`属性，没有直接的Webpack插件配置。
  - 可以手动编辑生成的HTML文件或使用自定义的HTML模板来添加`async`属性。
  - 适用于那些与DOM的解析顺序无关，并且可以独立于页面其余部分加载和执行的脚本。

通过这些方法，可以更好地控制脚本的加载和执行顺序，优化页面加载时间和用户体验。

### 将所有Chunk加上Defer的必要性
**问题**: 有必要将生成的所有chunk都加上defer吗？
**回答**: 
是否将所有生成的chunk都加上`defer`属性取决于应用的特定需求。`defer`属性的使用适合于那些不会改变DOM结构的脚本，以及那些直到页面完全加载后才需要执行的脚本。以下是考虑是否为所有chunk添加`defer`属性的几个关键点：

1. **非阻塞加载**:
   - 使用`defer`可以使脚本在HTML解析过程中以非阻塞的方式加载，这有助于改善页面的加载性能。
   - 当脚本不依赖于其他脚本，并且不需要在DOM构建的早期运行时，使用`defer`是合适的。

2. **执行顺序**:
   - `defer`脚本保证按照它们在HTML中出现的顺序执行。
   - 如果应用中的脚本有依赖关系或特定的执行顺序要求，`defer`可以保证这种顺序。

3. **脚本依赖**:
   - 对于依赖DOM或其他脚本的脚本，可能需要在DOM构建的过程中立即执行，这种情况下使用`defer`可能不合适。

4. **首次交互时间**:
   - 对于影响用户首次交互的脚本，使用`defer`可以延迟其执行，从而不会阻碍页面的初始渲染。

综上所述，将所有chunk加上`defer`可以提升页面加载性能，尤其是对于大型应用或含有多个脚本的页面。然而，这需要根据具体的应用架构和脚本依赖关系来决定是否适用。
